/* 
 * Fractal Zoomer, Copyright (C) 2020 hrkalona2
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package fractalzoomer.core;

import fractalzoomer.core.antialiasing.AntialiasingAlgorithm;
import fractalzoomer.core.blending.*;
import fractalzoomer.core.domain_coloring.*;
import fractalzoomer.core.rendering_algorithms.BoundaryTracingRender;
import fractalzoomer.core.rendering_algorithms.SuccessiveRefinementGuessingRender;
import fractalzoomer.core.interpolation.*;
import fractalzoomer.core.iteration_algorithm.FractalIterationAlgorithm;
import fractalzoomer.core.iteration_algorithm.IterationAlgorithm;
import fractalzoomer.core.iteration_algorithm.JuliaIterationAlgorithm;
import fractalzoomer.core.la.LAReference;
import fractalzoomer.core.location.Location;
import fractalzoomer.core.location.normal.CartesianLocationNormalApfloatArbitrary;
import fractalzoomer.core.location.normal.PolarLocationNormalApfloatArbitrary;
import fractalzoomer.core.mpfr.LibMpfr;
import fractalzoomer.core.mpfr.MpfrBigNum;
import fractalzoomer.core.mpir.LibMpir;
import fractalzoomer.core.mpir.MpirBigNum;
import fractalzoomer.fractal_options.iteration_statistics.*;
import fractalzoomer.fractal_options.orbit_traps.OrbitTrap;
import fractalzoomer.functions.Fractal;
import fractalzoomer.functions.barnsley.Barnsley1;
import fractalzoomer.functions.barnsley.Barnsley2;
import fractalzoomer.functions.barnsley.Barnsley3;
import fractalzoomer.functions.formulas.coupled.CoupledMandelbrot;
import fractalzoomer.functions.formulas.coupled.CoupledMandelbrotBurningShip;
import fractalzoomer.functions.formulas.general.mathtype.*;
import fractalzoomer.functions.formulas.general.newtonvariant.*;
import fractalzoomer.functions.formulas.kaliset.*;
import fractalzoomer.functions.formulas.m_like_generalization.*;
import fractalzoomer.functions.formulas.m_like_generalization.c_azb_dze.*;
import fractalzoomer.functions.formulas.m_like_generalization.c_azb_dze_f_g.*;
import fractalzoomer.functions.formulas.m_like_generalization.zab_zde_fg.Formula40;
import fractalzoomer.functions.formulas.m_like_generalization.zab_zde_fg.Formula41;
import fractalzoomer.functions.general.*;
import fractalzoomer.functions.lambda.Lambda;
import fractalzoomer.functions.lambda.Lambda2;
import fractalzoomer.functions.lambda.Lambda3;
import fractalzoomer.functions.lambda.LambdaFnFn;
import fractalzoomer.functions.magnet.*;
import fractalzoomer.functions.mandelbrot.*;
import fractalzoomer.functions.math.*;
import fractalzoomer.functions.root_finding_methods.abbasbandy.*;
import fractalzoomer.functions.root_finding_methods.abbasbandy2.*;
import fractalzoomer.functions.root_finding_methods.abbasbandy3.*;
import fractalzoomer.functions.root_finding_methods.aberth_ehrlich.*;
import fractalzoomer.functions.root_finding_methods.bairstow.*;
import fractalzoomer.functions.root_finding_methods.changbum_chun1.*;
import fractalzoomer.functions.root_finding_methods.changbum_chun2.*;
import fractalzoomer.functions.root_finding_methods.changbum_chun3.*;
import fractalzoomer.functions.root_finding_methods.chun_ham.*;
import fractalzoomer.functions.root_finding_methods.chun_kim.*;
import fractalzoomer.functions.root_finding_methods.contra_harmonic_newton.*;
import fractalzoomer.functions.root_finding_methods.durand_kerner.*;
import fractalzoomer.functions.root_finding_methods.euler_chebyshev.*;
import fractalzoomer.functions.root_finding_methods.ezzati_saleki1.*;
import fractalzoomer.functions.root_finding_methods.ezzati_saleki2.*;
import fractalzoomer.functions.root_finding_methods.feng.*;
import fractalzoomer.functions.root_finding_methods.halley.*;
import fractalzoomer.functions.root_finding_methods.harmonic_simpson_newton.*;
import fractalzoomer.functions.root_finding_methods.homeier1.*;
import fractalzoomer.functions.root_finding_methods.homeier2.*;
import fractalzoomer.functions.root_finding_methods.householder.*;
import fractalzoomer.functions.root_finding_methods.householder3.*;
import fractalzoomer.functions.root_finding_methods.jaratt.*;
import fractalzoomer.functions.root_finding_methods.jaratt2.*;
import fractalzoomer.functions.root_finding_methods.kim_chun.*;
import fractalzoomer.functions.root_finding_methods.king1.*;
import fractalzoomer.functions.root_finding_methods.king3.*;
import fractalzoomer.functions.root_finding_methods.kou_li_wang1.*;
import fractalzoomer.functions.root_finding_methods.laguerre.*;
import fractalzoomer.functions.root_finding_methods.maheshweri.*;
import fractalzoomer.functions.root_finding_methods.midpoint.*;
import fractalzoomer.functions.root_finding_methods.muller.*;
import fractalzoomer.functions.root_finding_methods.nedzhibov.*;
import fractalzoomer.functions.root_finding_methods.newton.*;
import fractalzoomer.functions.root_finding_methods.newton_hines.*;
import fractalzoomer.functions.root_finding_methods.noor_gupta.*;
import fractalzoomer.functions.root_finding_methods.parhalley.*;
import fractalzoomer.functions.root_finding_methods.popovski1.*;
import fractalzoomer.functions.root_finding_methods.rafis_rafiullah.*;
import fractalzoomer.functions.root_finding_methods.rafiullah1.*;
import fractalzoomer.functions.root_finding_methods.schroder.*;
import fractalzoomer.functions.root_finding_methods.secant.*;
import fractalzoomer.functions.root_finding_methods.simpson_newton.*;
import fractalzoomer.functions.root_finding_methods.steffensen.*;
import fractalzoomer.functions.root_finding_methods.stirling.*;
import fractalzoomer.functions.root_finding_methods.super_halley.*;
import fractalzoomer.functions.root_finding_methods.third_order_newton.*;
import fractalzoomer.functions.root_finding_methods.traub_ostrowski.*;
import fractalzoomer.functions.root_finding_methods.weerakoon_fernando.*;
import fractalzoomer.functions.root_finding_methods.whittaker.*;
import fractalzoomer.functions.root_finding_methods.whittaker_double_convex.*;
import fractalzoomer.functions.szegedi_butterfly.SzegediButterfly1;
import fractalzoomer.functions.szegedi_butterfly.SzegediButterfly2;
import fractalzoomer.functions.user_formulas.*;
import fractalzoomer.main.CommonFunctions;
import fractalzoomer.main.Constants;
import fractalzoomer.main.ImageExpanderWindow;
import fractalzoomer.main.MainWindow;
import fractalzoomer.main.app_settings.*;
import fractalzoomer.palettes.PaletteColor;
import fractalzoomer.palettes.transfer_functions.*;
import fractalzoomer.parser.Parser;
import fractalzoomer.true_coloring_algorithms.TrueColorAlgorithm;
import fractalzoomer.utils.*;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.QRDecomposition;
import org.apache.commons.math3.linear.RealVector;
import org.apfloat.Apfloat;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.util.List;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.LongAccumulator;
import java.util.concurrent.atomic.LongAdder;
import java.util.stream.Collectors;

/**
 *
 * @author hrkalona
 */
public abstract class TaskRender implements Runnable {
    private static  double pi2 = Math.PI * 0.5;

    /**
     * ** MODES ***
     */
    public static final int NORMAL = 0;
    public static final int FAST_JULIA = 1;
    public static final int COLOR_CYCLING = 2;
    public static final int APPLY_PALETTE_AND_FILTER = 3;
    public static final int JULIA_MAP = 4;
    public static final int ROTATE_3D_MODEL = 5;
    public static final int POLAR = 6;
    public static final int FAST_JULIA_POLAR = 7;
    public static final int JULIA_MAP_POLAR = 8;
    public static final int APPLY_PALETTE_AND_FILTER_3D_MODEL = 9;
    public static final int DOMAIN = 10;
    public static final int DOMAIN_POLAR = 11;
    public static final int NORMAL_EXPANDER = 12;
    public static final int POLAR_EXPANDER = 13;
    public static final int DOMAIN_EXPANDER = 14;
    public static final int DOMAIN_POLAR_EXPANDER = 15;
    public static final int POST_PROCESSING_WITH_AA_AND_FILTER = 16;
    public static final int APPLY_PALETTE_AND_POST_PROCESSING_WITH_AA_AND_FILTER = 17;
    /**
     * ************
     */

    /**
     * ** Thread Related / Synchronization ***
     */
    protected int FROMx;
    protected int TOx;
    protected int FROMy;
    protected int TOy;

    public static double LCHab_CONSTANT_L = 50;
    public static double LCHab_CONSTANT_C = 100;

    public static double LCHuv_CONSTANT_L = 50;
    public static double LCHuv_CONSTANT_C = 130;

    public static float HSB_CONSTANT_S = 1;
    public static float HSB_CONSTANT_B = 1;

    public static double USER_CONVERGENT_BAILOUT;

    public static boolean CHUNK_SIZE_PER_ROW = false;

    protected static final int THREAD_CHUNK_SIZE = 500;
    protected static final int SUCCESSIVE_REFINEMENT_EXPONENT = 7;
    protected static final int SUCCESSIVE_REFINEMENT_MAX_SIZE = 2 << (SUCCESSIVE_REFINEMENT_EXPONENT - 1);
    protected static final int[] THREAD_CHUNK_SIZE_PER_LEVEL = {2, 4, 8, 16, 32, 64, 128, 256};
    protected static final int[] THREAD_CHUNK_SIZE_PER_LEVEL2 = {2, 4, 4, 8, 8, 16, 16, 32, 32, 64, 64, 128, 128, 256, 256};

    protected static final int[] SUCCESSIVE_REFINEMENT_SPLIT1 = {SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7};

    protected static final int[] SUCCESSIVE_REFINEMENT_SPLIT2 = {SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7};


    protected static final int[] SUCCESSIVE_REFINEMENT_SPLIT3 = {SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7};

    protected static final int[] SUCCESSIVE_REFINEMENT_SPLIT4 = {SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 1, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 2, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 3, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 4, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 5, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6,
            SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 6, SUCCESSIVE_REFINEMENT_MAX_SIZE >> 7};


    public static int SUCCESSIVE_REFINEMENT_SQUARE_RECT_SPLIT_ALGORITHM = 0;

    public static boolean COMPRESS_REFERENCE_IF_POSSIBLE = false;

    public static boolean TWO_PASS_SUCCESSIVE_REFINEMENT = false;
    public static boolean TWO_PASS_CHECK_CENTER = true;
    public static int SQUARE_RECT_CHUNK_AGGERAGATION = 0;

    protected static int[] SUCCESSIVE_REFINEMENT_CHUNK_X;
    protected static int[] SUCCESSIVE_REFINEMENT_CHUNK_Y;

    public static boolean QUICKRENDER_SUCCESSIVE_REFINEMENT = false;
    public static boolean USE_QUICKRENDER_ON_GREEDY_SUCCESSIVE_REFINEMENT = true;
    public static boolean ALWAYS_SAVE_EXTRA_PIXEL_DATA_ON_AA = true;
    public static boolean ALWAYS_SAVE_EXTRA_PIXEL_DATA_ON_AA_WITH_PP = true;
    public static boolean USE_RI_ON_BLA2 = false;
    public static boolean DISABLE_RI_ON_BLA2 = false;

    public static boolean USE_FAST_DELTA_LOCATION = true;
    public static int BUILT_IT_BIGNUM_IMPLEMENTATION = 0;

    public static int FAST_JULIA_IMAGE_SIZE = 252;
    protected static int randomNumber;

    public static boolean USE_DIRECT_COLOR;
    public static int COLOR_SMOOTHING_METHOD;

    public static LongAccumulator PostProcessingCalculationTime;

    protected int rendering_done;
    protected int task_calculated;
    protected int task_completed = -1;
    protected int task_post_processed = -1;
    protected int task_calculated_extra;
    protected long pixel_calculation_time_per_task;
    protected long post_processing_calculation_time_per_task;

    public static final int MAX_GROUPING = 64;
    protected long[] task_pixel_grouping = new long[MAX_GROUPING];//hopefully that is enough

    protected boolean usesSquareChunks;

    protected static int[] algorithm_colors;
    protected static int[] algorithm_colors2;

    protected int taskId;
    protected String doneByThreadName;
    protected long doneByThreadId;

    private boolean createPreview;
    private boolean zoomToCursor;
    protected boolean createFullImageAfterPreview;
    private static AtomicInteger finalize_sync;
    private static CyclicBarrier normalize_find_ranges_sync;
    private static CyclicBarrier normalize_sync;
    private static CyclicBarrier normalize_sync2;
    private static CyclicBarrier normalize_find_ranges_sync_3d;

    protected static CyclicBarrier initialize_jobs_sync;
    private static CyclicBarrier post_processing_sync;
    private static CyclicBarrier calculate_vectors_sync;
    private static AtomicInteger painting_sync;

    public static AtomicInteger number_of_tasks;
    private static AtomicInteger height_scaling_sync;
    private static CyclicBarrier height_scaling_sync2;
    private static AtomicInteger height_scaling_sync3;
    private static CyclicBarrier height_scaling_sync4;
    private static CyclicBarrier height_function_sync;
    private static AtomicInteger gaussian_scaling_sync;
    private static AtomicInteger remove_outliers_sync;
    private static AtomicInteger remove_outliers_sync3;
    private static CyclicBarrier remove_outliers_sync2;
    private static CyclicBarrier remove_outliers_sync4;
    private static CyclicBarrier gaussian_scaling_sync2;
    private static CyclicBarrier shade_color_height_sync;
    private static LongAdder total_calculated;
    private static LongAdder total_completed;
    private static LongAdder total_post_processed;
    private static LongAdder[] total_pixel_grouping;
    public static LongAccumulator max_pixel_calculation_time;
    private static LongAdder total_calculated_extra;
    protected static AtomicInteger normal_rendering_algorithm_pixel;
    protected static AtomicInteger normal_rendering_algorithm_pixel2;
    protected static AtomicInteger[] quick_render_rendering_algorithm_pixel;
    protected static AtomicInteger[] successive_refinement_rendering_algorithm_pixel;
    protected static AtomicInteger[] successive_refinement_rendering_algorithm2_pixel;
    protected static AtomicInteger render_squares_pixel;
    protected static CyclicBarrier quick_render_rendering_algorithm_barrier;
    protected static CyclicBarrier successive_refinement_rendering_algorithm_barrier;
    protected static AtomicInteger normal_rendering_algorithm_apply_palette;
    protected static AtomicInteger normal_rendering_algorithm_apply_palette2;
    protected static AtomicInteger normal_rendering_algorithm_post_processing;
    protected static AtomicInteger normal_rendering_algorithm_post_processing2;
    protected static AtomicInteger apply_skipped_color_pixel;
    protected static AtomicInteger normal_rendering_algorithm_histogram;
    private static CyclicBarrier color_cycling_filters_sync;
    private static CyclicBarrier color_cycling_restart_sync;
    private static ReadWriteLock color_cycling_toggle_lock;
    protected static ReadWriteLock successive_refinement_lock;
    protected static AtomicInteger reference_calc_sync;
    protected static CyclicBarrier reference_sync;

    protected static boolean STOP_SUCCESSIVE_REFINEMENT;
    public static boolean DONE;

    public static void stopSuccessiveRefinement() {
        try {
            successive_refinement_lock.lockWrite();
        }
        catch (InterruptedException ex) {

        }
        STOP_SUCCESSIVE_REFINEMENT = true;
        successive_refinement_lock.unlockWrite();
    }

    protected static int getThreadChunkSize(int width, boolean per_row) {
        if (per_row) {
            return width;
        }
        return THREAD_CHUNK_SIZE;
    }

    static {
        setSuccessiveRefinementChunks();
    }

    public static void setSuccessiveRefinementChunks() {

        if(SUCCESSIVE_REFINEMENT_SQUARE_RECT_SPLIT_ALGORITHM == 1) {
            SUCCESSIVE_REFINEMENT_CHUNK_X = SUCCESSIVE_REFINEMENT_SPLIT1;
            SUCCESSIVE_REFINEMENT_CHUNK_Y = SUCCESSIVE_REFINEMENT_SPLIT2;
        }
        else if(SUCCESSIVE_REFINEMENT_SQUARE_RECT_SPLIT_ALGORITHM == 2) {
            SUCCESSIVE_REFINEMENT_CHUNK_X = SUCCESSIVE_REFINEMENT_SPLIT2;
            SUCCESSIVE_REFINEMENT_CHUNK_Y = SUCCESSIVE_REFINEMENT_SPLIT1;
        }
        else if(SUCCESSIVE_REFINEMENT_SQUARE_RECT_SPLIT_ALGORITHM == 3) {
            SUCCESSIVE_REFINEMENT_CHUNK_X = SUCCESSIVE_REFINEMENT_SPLIT3;
            SUCCESSIVE_REFINEMENT_CHUNK_Y = SUCCESSIVE_REFINEMENT_SPLIT4;
        }
        else if(SUCCESSIVE_REFINEMENT_SQUARE_RECT_SPLIT_ALGORITHM == 4) {
            SUCCESSIVE_REFINEMENT_CHUNK_X = SUCCESSIVE_REFINEMENT_SPLIT4;
            SUCCESSIVE_REFINEMENT_CHUNK_Y = SUCCESSIVE_REFINEMENT_SPLIT3;
        }
        else {
            SUCCESSIVE_REFINEMENT_CHUNK_X = null;
            SUCCESSIVE_REFINEMENT_CHUNK_Y = null;
        }

    }

    private static BufferedImage window_image;

    public static void loadWindowImage(int id) {
        try {
            if(id == 1) {
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "windows.png"));
            }
            else if (id == 2){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "windows2.png"));
            }
            else if (id == 3){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "arch_windows.png"));
            }
            else if (id == 4){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "arch_windows2.png"));
            }
            else if (id == 5){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "gothic_windows.png"));
            }
            else if (id == 6){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "round_windows.png"));
            }
            else if (id == 7){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "round_windows2.png"));
            }
            else if (id == 8){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "round_windows3.png"));
            }
            else if (id == 9){
                window_image = ImageIO.read(MainWindow.class.getResource("/fractalzoomer/icons/" + "door_windows.png"));
            }
            else {
                window_image = null;
            }
        }
        catch (Exception ex) {

        }
    }
    /**
     * ****************************
     */

    /**
     * ** 3D ***
     */
    private static long D3RenderingCalculationTime;
    protected boolean d3;
    protected D3Settings d3s;
    private int detail;
    private double fiX, fiY, scale, m20, m21, m22;
    private double d3_height_scale;
    private int max_range;
    private int min_range;
    private int max_scaling;
    private int height_algorithm;
    private boolean gaussian_scaling;
    private boolean bilateral_scaling;

    private boolean remove_outliers_pre;
    private boolean remove_outliers_post;

    private int outliers_method;
    private double sigma_r;
    private double sigma_s_reciprocal;
    private int gaussian_kernel_size;
    public static double[][] vert;
    public static int[][] vert_color;
    private static float[][][] vert1;
    private static float[][][] Norm1z;
    private static double[] gaussian_kernel;
    private static double[][] temp_array;
    private double color_3d_blending;
    private boolean shade_height;
    private int shade_choice;
    private int shade_algorithm;
    private boolean shade_invert;
    private int d3_color_type;
    private static double max;
    private static double min;

    private static double lowerFence;
    private static double upperFence;
    private boolean preHeightScaling;

    /**
     * *********
     */
    /**
     * ** Histogram Coloring ***
     */
    private static double maxIterationEscaped;
    private static double maxIterationNotEscaped;
    private static double minIterationsNotEscaped;
    private static double minIterationsEscaped;

    private static double upperFenceEscaped;
    private static double lowerFenceEscaped;

    private static double upperFenceNotEscaped;
    private static double lowerFenceNotEscaped;
    private static int[] escapedCounts;
    private static int[] notEscapedCounts;
    private static double[] arrayEscaped;
    private static double[] arraynotEscaped;
    private static int totalEscaped;
    private static int totalNotEscaped;
    private static double denominatorEscaped;
    private static double denominatorNotEscaped;

    /**
     * *********
     */
    /**
     * ** Filters ***
     */
    protected FiltersSettings fs;
    private boolean[] filters;
    protected int[] filters_options_vals;
    protected int[][] filters_options_extra_vals;
    protected boolean fast_julia_filters;
    private Color[] filters_colors;
    private Color[][] filters_extra_colors;
    private int[] filters_order;
    private static long FilterCalculationTime;
    /**
     * **************
     */

    /**
     * ** Image Related ***
     */
    protected BufferedImage image;
    protected int[] rgbs;
    public static double[] image_iterations;
    protected static double[] domain_image_data_re;
    protected static double[] domain_image_data_im;
    protected static double[] image_iterations_fast_julia;
    protected static boolean[] escaped_fast_julia;
    protected static boolean[] escaped;
    public static int WIDTH;
    public static int HEIGHT;
    /**
     * ********************
     */

    /**
     * ** Post Processing ***
     */
    protected static final int MAX_BUMP_MAPPING_DEPTH = 100;
    protected static final int DEFAULT_BUMP_MAPPING_STRENGTH = 50;
    private int dem_color;
    private int[] post_processing_order;
    private boolean usePaletteForInColoring;
    private LightSettings ls;
    private NumericalDistanceEstimatorSettings ndes;
    private SlopeSettings ss;
    protected BumpMapSettings bms;
    private EntropyColoringSettings ens;
    private RainbowPaletteSettings rps;
    private FakeDistanceEstimationSettings fdes;
    private ContourColoringSettings cns;
    private OffsetColoringSettings ofs;
    private GreyscaleColoringSettings gss;
    private PaletteGradientMergingSettings pbs;
    private HistogramColoringSettings hss;

    /**
     * **********************
     */
    /**
     * ** Traps ***
     */
    private OrbitTrapSettings ots;
    /**
     * **********************
     */

    /**
     * **********************
     */
    /**
     * ** Statistics ***
     */
    private StatisticsSettings sts;
    /**
     * **********************
     */


    /**
     * ** Color Cycling ***
     */
    private static boolean color_cycling;
    private int color_cycling_location_outcoloring;
    private int color_cycling_location_incoloring;
    private int gradient_offset;

    private ColorCyclingSettings ccs;

    /**
     * ********************
     */

    protected Apfloat xCenter;
    protected Apfloat yCenter;
    protected Apfloat size;
    protected Apfloat[] rotation_center;
    protected Apfloat[] rotation_vals;
    protected Fractal fractal;
    protected IterationAlgorithm iteration_algorithm;
    protected boolean domain_coloring;

    private Map<Coordinate, Double> edgeData;
    private Map<Coordinate, PixelExtraData> edgeAAData;
    private DomainColoringSettings ds;
    private boolean usesTrueColorIn;
    protected double height_ratio;
    protected boolean polar_projection;
    protected double circle_period;
    private int fractal_color;
    private int max_iterations;
    public static PaletteColor palette_outcoloring;
    public static PaletteColor palette_incoloring;
    private TransferFunction color_transfer_outcoloring;
    private TransferFunction color_transfer_incoloring;
    private Blending blending;
    private Blending ens_blending;
    private Blending rps_blending;

    private Blending ndes_blending;

    private Blending hss_blending;
    private Blending ofs_blending;

    private InterpolationMethod method;

    private GeneratedPaletteSettings gps;
    private BlendingSettings color_blending;
    protected DomainColoring domain_color;
    protected JitterSettings js;
    private double contourFactor;
    protected MainWindow ptr;
    private ImageExpanderWindow ptrExpander;
    protected JProgressBar progress;
    protected int action;
    private boolean quickRender;
    protected int tile;
    protected boolean julia;
    private static String default_init_val;
    private static double convergent_bailout;
    public static int TILE_SIZE = 5;
    public static int QUICK_RENDER_DELAY = 1500; //msec
    public static int SKIPPED_PIXELS_ALG = 0;
    public static int SKIPPED_PIXELS_COLOR = 0xFFFFFFFF;
    public static int[] gradient;
    public static boolean HIGH_PRECISION_CALCULATION = false;
    public static boolean PERTURBATION_THEORY = false;
    public static int APPROXIMATION_ALGORITHM = 4;
    public static int SERIES_APPROXIMATION_TERMS = ApproximationDefaultSettings.SERIES_APPROXIMATION_TERMS;
    public static boolean USE_FULL_FLOATEXP_FOR_ALL_ZOOM = false;
    public static boolean USE_CUSTOM_FLOATEXP_REQUIREMENT = true;
    public static boolean USE_FULL_FLOATEXP_FOR_DEEP_ZOOM = false;
    public static long SERIES_APPROXIMATION_OOM_DIFFERENCE = ApproximationDefaultSettings.SERIES_APPROXIMATION_OOM_DIFFERENCE;
    public static int SERIES_APPROXIMATION_MAX_SKIP_ITER = ApproximationDefaultSettings.SERIES_APPROXIMATION_MAX_SKIP_ITER;
    public static boolean BIGNUM_AUTOMATIC_PRECISION = true;
    public static int BIGNUM_PRECISION = 996;
    public static int BIGNUM_PRECISION_FACTOR = 1;
    public static boolean CALCULATE_PERIOD_EVERY_TIME_FROM_START = false;

    public static boolean USE_THREADS_IN_BIGNUM_LIBS = true;
    public static int BIGNUM_LIBRARY = Constants.BIGNUM_AUTOMATIC;
    public static int HIGH_PRECISION_LIB = Constants.ARBITRARY_AUTOMATIC;
    public static boolean USE_THREADS_FOR_SA = false;
    public static int BLA_BITS = ApproximationDefaultSettings.BLA_BITS;
    public static boolean USE_THREADS_FOR_BLA = true;
    public static boolean USE_THREADS_FOR_BLA2 = true;
    public static boolean DETECT_PERIOD = true;
    public static int PERIOD_DETECTION_ALGORITHM = 2;
    public static boolean STOP_REFERENCE_CALCULATION_AFTER_DETECTED_PERIOD = true;
    public static int PERTUBATION_PIXEL_ALGORITHM = 0;
    public static int BLA_STARTING_LEVEL = ApproximationDefaultSettings.BLA_STARTING_LEVEL;
    public static int NANOMB1_N = ApproximationDefaultSettings.NANOMB1_N;
    public static int NANOMB1_M = ApproximationDefaultSettings.NANOMB1_M;
    public static boolean GATHER_PERTURBATION_STATISTICS = false;
    public static boolean GATHER_HIGHPRECISION_STATISTICS = false;
    public static boolean CHECK_BAILOUT_DURING_DEEP_NOT_FULL_FLOATEXP_MODE = false;
    public static boolean GREEDY_ALGORITHM = true;
    public static boolean GREEDY_ALGORITHM_CHECK_ITER_DATA = true;
    public static boolean GATHER_TINY_REF_INDEXES = true;
    public static int GREEDY_ALGORITHM_SELECTION = Constants.CIRCULAR_SUCCESSIVE_REFINEMENT;
    public static int BRUTE_FORCE_ALG = 0;
    public static int GUESS_BLOCKS_SELECTION = 3;
    public static boolean USE_SMOOTHING_FOR_PROCESSING_ALGS = true;
    public static boolean RENDER_IMAGE_PREVIEW = false;
    public static boolean LOAD_MPFR = true;
    public static boolean LOAD_MPIR = true;
    public static String MPIR_LIB = "mpir_skylake_avx2.dll";
    public static final String[] mpirWinLibs = {"mpir_skylake_avx2.dll", "mpir_haswell_avx2.dll", "mpir_sandybridge_ivybridge.dll"};
    public static Random generator;
    public static int D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS = 1;
    public static int CIRCULAR_COMPARE_ALG = 0;
    public static boolean CIRCULAR_REVERT_ALG = false;
    public static boolean CIRCULAR_REPEAT_ALG = false;
    public static double CIRCULAR_REPEAT_SPACING = 25;
    public static double CIRCULAR_N = 2.0;
    public static boolean LOAD_RENDERING_ALGORITHM_FROM_SAVES = false;
    public static int MANTEXPCOMPLEX_FORMAT = 0;
    public static long SEED = 0;

    public static boolean SMOOTH_DATA = false;
    public static ThreadPoolExecutor la_thread_executor;
    public static ThreadPoolExecutor reference_thread_executor;
    //public static ThreadPoolExecutor reference_thread_executor2;
    public static ThreadPoolExecutor thread_calculation_executor;
    public static ThreadPoolExecutor julia_map_thread_calculation_executor;
    public static ExecutorService single_thread_executor;
    public static ThreadPoolExecutor action_thread_executor;

    public static void shutdownThreadPools() {
        if(reference_thread_executor != null) {
            reference_thread_executor.shutdownNow();
        }
//        if(reference_thread_executor2 != null) {
//            reference_thread_executor2.shutdown();
//        }
        if(thread_calculation_executor != null) {
            thread_calculation_executor.shutdownNow();
        }
        if(julia_map_thread_calculation_executor != null) {
            julia_map_thread_calculation_executor.shutdownNow();
        }
        if(single_thread_executor != null) {
            single_thread_executor.shutdownNow();
        }
        if(action_thread_executor != null) {
            action_thread_executor.shutdownNow();
        }
        if(la_thread_executor != null) {
            la_thread_executor.shutdownNow();
        }
    }

    public static long getActiveThreadCount() {
        long count = 0;

        if(reference_thread_executor != null) {
            count += reference_thread_executor.getActiveCount();
        }
//        if(reference_thread_executor2 != null) {
//            count += reference_thread_executor2.getActiveCount();
//        }
        if(thread_calculation_executor != null) {
            count += thread_calculation_executor.getActiveCount();
        }
        if(julia_map_thread_calculation_executor != null) {
            count += julia_map_thread_calculation_executor.getActiveCount();
        }
        if(action_thread_executor != null) {
            count += action_thread_executor.getActiveCount();
        }
        if(la_thread_executor != null) {
            count += la_thread_executor.getActiveCount();
        }

        count += ForkJoinPool.commonPool().getActiveThreadCount();

        return count;
    }

    public static void reSeed() {
        if(SEED == 0) {
            generator = new Random(System.currentTimeMillis());
        }
        else {
            generator = new Random(SEED);
        }
        randomNumber = generator.nextInt(100000);
    }
    

    static {

        reSeed();
        default_init_val = "c";
        convergent_bailout = 0;
        List<Color> colors = ColorGenerator.generate(600, 0, 0);
        algorithm_colors = new int[colors.size()];

        for (int i = 0; i < algorithm_colors.length; i++) {
            algorithm_colors[i] = colors.get(i).getRGB();
        }

        algorithm_colors2 = new int[200];
        setAlgorithmColors();

        if (Runtime.getRuntime().availableProcessors() >= 2) {
            reference_thread_executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);
        }

//        if (Runtime.getRuntime().availableProcessors() >= 3) {
//            reference_thread_executor2 = (ThreadPoolExecutor) Executors.newFixedThreadPool(3);
//        }
    }

    public static void setAlgorithmColors() {
        Random random = new Random(5);
        for (int i = 0; i < algorithm_colors2.length; i++) {
            algorithm_colors2[i] = Color.HSBtoRGB(random.nextFloat(), TaskRender.HSB_CONSTANT_S, TaskRender.HSB_CONSTANT_B);
        }
    }

    public TaskRender() {

    }

    private void setPostProcessingData(PostProcessSettings pps) {
        ls = pps.ls;
        ss = pps.ss;
        bms = pps.bms;
        fdes = pps.fdes;
        sts = pps.sts;
        ens = pps.ens;
        rps = pps.rps;
        ots = pps.ots;
        cns = pps.cns;
        hss = pps.hss;
        gss = pps.gss;
        ofs = pps.ofs;
        ndes = pps.ndes;

        setPostProcessingBlending();
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, D3Settings d3s, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, boolean periodicity_checking, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, DomainColoringSettings ds, boolean inverse_dem, boolean quickRender, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsFractal(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, d3s, ptr, fractal_color, dem_color, image, fs, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, periodicity_checking, fns.plane_type, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.perturbation_user_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.initial_value_user_formula, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, ds, inverse_dem, quickRender, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, fns.laguerre_deg, color_blending, fns.kleinianLine, fns.kleinianK, fns.kleinianM, post_processing_order, pbs, fns.gcs, fns.durand_kerner_init_val, fns.mps, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.gcps, fns.igs, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.root_initialization_method, fns.preffs, fns.postffs, fns.ips, fns.defaultNovaInitialValue, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.period, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower);
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, ImageExpanderWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, boolean periodicity_checking, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, DomainColoringSettings ds, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsFractalExpander(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, ptr, fractal_color, dem_color, image, fs, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, periodicity_checking, fns.plane_type, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.perturbation_user_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.initial_value_user_formula, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, ds, inverse_dem, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, fns.laguerre_deg, color_blending, fns.kleinianLine, fns.kleinianK, fns.kleinianM, post_processing_order, pbs, fns.gcs, fns.durand_kerner_init_val, fns.mps, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.gcps, fns.igs, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.root_initialization_method, fns.preffs, fns.postffs, fns.ips, fns.defaultNovaInitialValue, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.period, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower);
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, D3Settings d3s, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, boolean periodicity_checking, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, DomainColoringSettings ds, boolean inverse_dem, boolean quickRender, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsJulia(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, d3s, ptr, fractal_color, dem_color, image, fs, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, periodicity_checking, fns.plane_type, fns.apply_plane_on_julia, fns.apply_plane_on_julia_seed, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, ds, inverse_dem, quickRender, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, color_blending, post_processing_order, pbs, fns.gcs, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.laguerre_deg, fns.gcps, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.preffs, fns.postffs, fns.ips, fns.juliter, fns.juliterIterations, fns.juliterIncludeInitialIterations, fns.defaultNovaInitialValue, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.perturbation_user_formula, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.initial_value_user_formula, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower, xJuliaCenter, yJuliaCenter);
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, ImageExpanderWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, boolean periodicity_checking, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, DomainColoringSettings ds, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsJuliaExpander(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, ptr, fractal_color, dem_color, image, fs, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, periodicity_checking, fns.plane_type, fns.apply_plane_on_julia, fns.apply_plane_on_julia_seed, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, ds, inverse_dem, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, color_blending, post_processing_order, pbs, fns.gcs, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.laguerre_deg, fns.gcps, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.preffs, fns.postffs, fns.ips, fns.juliter, fns.juliterIterations, fns.juliterIncludeInitialIterations, fns.defaultNovaInitialValue, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.perturbation_user_formula, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.initial_value_user_formula, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower, xJuliaCenter, yJuliaCenter);
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, boolean periodicity_checking, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsJuliaMap(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, ptr, fractal_color, dem_color, image, fs, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, periodicity_checking, fns.plane_type, fns.apply_plane_on_julia, fns.apply_plane_on_julia_seed, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, inverse_dem, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, color_blending, post_processing_order, pbs, fns.gcs, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.laguerre_deg, fns.gcps, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.preffs, fns.postffs, fns.ips, fns.juliter, fns.juliterIterations, fns.juliterIncludeInitialIterations, fns.defaultNovaInitialValue, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.perturbation_user_formula, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.initial_value_user_formula, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower);
    }

    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, FunctionSettings fns, MainWindow ptr, Color fractal_color, Color dem_color, boolean fast_julia_filters, BufferedImage image, boolean periodicity_checking, FiltersSettings fs, int color_cycling_location, int color_cycling_location2, boolean exterior_de, double exterior_de_factor, double height_ratio, boolean polar_projection, double circle_period, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, JitterSettings js, PostProcessSettings pps, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {
        this.contourFactor = contourFactor;
        setPostProcessingData(pps);
        SMOOTH_DATA = needsSmoothing(fns, ndes, ls, ss, bms, cns, ens, rps, fdes, sts);
        this.gps = gps;
        this.js = js;
        settingsJuliaPreview(FROMx, TOx, FROMy, TOy, xCenter, yCenter, size, max_iterations, fns.bailout_test_algorithm, fns.bailout, fns.bailout_test_user_formula, fns.bailout_test_user_formula2, fns.bailout_test_comparison, fns.n_norm, ptr, fractal_color, dem_color, fast_julia_filters, image, periodicity_checking, fns.plane_type, fns.apply_plane_on_julia, fns.apply_plane_on_julia_seed, fns.out_coloring_algorithm, fns.user_out_coloring_algorithm, fns.outcoloring_formula, fns.user_outcoloring_conditions, fns.user_outcoloring_condition_formula, fns.in_coloring_algorithm, fns.user_in_coloring_algorithm, fns.incoloring_formula, fns.user_incoloring_conditions, fns.user_incoloring_condition_formula, SMOOTH_DATA, fs, fns.burning_ship, fns.mandel_grass, fns.mandel_grass_vals, fns.function, fns.z_exponent, fns.z_exponent_complex, color_cycling_location, color_cycling_location2, fns.rotation_vals, fns.rotation_center, fns.coefficients, fns.z_exponent_nova, fns.relaxation, fns.nova_method, fns.user_formula, fns.user_formula2, fns.bail_technique, fns.user_plane, fns.user_plane_algorithm, fns.user_plane_conditions, fns.user_plane_condition_formula, fns.user_formula_iteration_based, fns.user_formula_conditions, fns.user_formula_condition_formula, exterior_de, exterior_de_factor, height_ratio, fns.plane_transform_center, fns.plane_transform_angle, fns.plane_transform_radius, fns.plane_transform_scales, fns.plane_transform_wavelength, fns.waveType, fns.plane_transform_angle2, fns.plane_transform_sides, fns.plane_transform_amount, fns.escaping_smooth_algorithm, fns.converging_smooth_algorithm, polar_projection, circle_period, fns.coupling, fns.user_formula_coupled, fns.coupling_method, fns.coupling_amplitude, fns.coupling_frequency, fns.coupling_seed, inverse_dem, color_intensity, transfer_function, color_density, color_intensity2, transfer_function2, color_density2, usePaletteForInColoring, color_blending, post_processing_order, pbs, fns.gcs, fns.coefficients_im, fns.lpns.lyapunovFinalExpression, fns.lpns.useLyapunovExponent, gradient_offset, fns.lpns.lyapunovFunction, fns.lpns.lyapunovExponentFunction, fns.lpns.lyapunovVariableId, fns.user_fz_formula, fns.user_dfz_formula, fns.user_ddfz_formula, fns.user_dddfz_formula, fns.user_relaxation_formula, fns.user_nova_addend_formula, fns.laguerre_deg, fns.gcps, fns.lfns, fns.newton_hines_k, fns.tcs, fns.lpns.lyapunovInitialValue, fns.lpns.lyapunovInitializationIteratons, fns.lpns.lyapunovskipBailoutCheck, fns.preffs, fns.postffs, fns.ips, fns.juliter, fns.juliterIterations, fns.juliterIncludeInitialIterations, fns.defaultNovaInitialValue, fns.perturbation, fns.perturbation_vals, fns.variable_perturbation, fns.user_perturbation_algorithm, fns.perturbation_user_formula, fns.user_perturbation_conditions, fns.user_perturbation_condition_formula, fns.init_val, fns.initial_vals, fns.variable_init_value, fns.user_initial_value_algorithm, fns.initial_value_user_formula, fns.user_initial_value_conditions, fns.user_initial_value_condition_formula, fns.cbs, fns.useGlobalMethod, fns.globalMethodFactor, fns.variable_re, fns.variable_im, fns.inflections_re, fns.inflections_im, fns.inflectionsPower, xJuliaCenter, yJuliaCenter);
    }
    //Fractal
    private void settingsFractal(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, D3Settings d3s, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, int plane_type, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, String perturbation_user_formula, boolean init_val, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, String initial_value_user_formula, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, DomainColoringSettings ds, boolean inverse_dem, boolean quickRender, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    double[] laguerre_deg, BlendingSettings color_blending,   double[] kleinianLine, double kleinianK, double kleinianM, int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] durand_kernel_init_val, MagneticPendulumSettings mps, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_relaxation_formula, String user_nova_addend_formula, GenericCpAZpBCSettings gcps, InertiaGravityFractalSettings igs, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs, String lyapunovInitialValue,  int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, int root_initialization_method, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean defaultNovaInitialValue, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, int period, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_center = rotation_center;
        this.rotation_vals = rotation_vals;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptr = ptr;
        this.fs = fs;
        this.filters = fs.filters;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.height_ratio = height_ratio;
        this.d3 = d3s.d3;
        //this.d3_draw_method = d3_draw_method;
        this.detail = d3s.detail;
        this.fiX = d3s.fiX;
        this.fiY = d3s.fiY;
        this.d3_height_scale = d3s.d3_height_scale;
        this.height_algorithm = d3s.height_algorithm;
        scale = d3s.d3_size_scale;
        this.color_3d_blending = d3s.color_3d_blending;
        this.gaussian_scaling = d3s.gaussian_scaling;
        bilateral_scaling = d3s.bilateral_scaling;
        this.remove_outliers_pre = d3s.remove_outliers_pre;
        this.remove_outliers_post = d3s.remove_outliers_post;
        this.outliers_method = d3s.outliers_method;
        this.sigma_r = d3s.sigma_r;
        this.sigma_s_reciprocal = 1 / d3s.sigma_s;
        this.gaussian_kernel_size = d3s.gaussian_kernel;
        this.max_range = d3s.max_range;
        this.min_range = d3s.min_range;
        this.max_scaling = d3s.max_scaling;
        this.shade_height = d3s.shade_height;
        this.shade_choice = d3s.shade_choice;
        this.shade_algorithm = d3s.shade_algorithm;
        this.shade_invert = d3s.shade_invert;
        this.d3_color_type = d3s.d3_color_type;
        this.preHeightScaling = d3s.preHeightScaling;
        this.d3s = d3s;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        this.domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptr.getProgressBar();

        if (domain_coloring) {
            if (polar_projection) {
                action = DOMAIN_POLAR;
            } else {
                action = DOMAIN;
            }
        } else if (polar_projection) {
            action = POLAR;
        } else {
            action = NORMAL;
        }

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        this.quickRender = quickRender;
        tile = TILE_SIZE;

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = fractalFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, plane_type, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, kleinianLine, kleinianK, kleinianM, laguerre_deg, durand_kernel_init_val, mps, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_relaxation_formula, user_nova_addend_formula, gcps, igs, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, root_initialization_method, preffs, postffs, ips, defaultNovaInitialValue, cbs, useGlobalMethod, globalMethodFactor, period, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = fractalFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, plane_type, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, kleinianLine, kleinianK, kleinianM, laguerre_deg, durand_kernel_init_val, mps, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_relaxation_formula, user_nova_addend_formula, gcps, igs, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, root_initialization_method, preffs, postffs, ips, defaultNovaInitialValue, cbs, useGlobalMethod, globalMethodFactor, period, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(false);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new FractalIterationAlgorithm(fractal);

        default_init_val = fractal.getInitialValue();

        convergent_bailout = fractal.getConvergentBailout();

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rendering_done = 0;
        task_calculated = 0;
        task_calculated_extra = 0;

    }

    //Fractal-Expander
    private void settingsFractalExpander(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, ImageExpanderWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, int plane_type, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, String perturbation_user_formula, boolean init_val, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, String initial_value_user_formula, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, DomainColoringSettings ds, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    double[] laguerre_deg, BlendingSettings color_blending,   double[] kleinianLine, double kleinianK, double kleinianM, int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] durand_kernel_init_val, MagneticPendulumSettings mps, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_relaxation_formula, String user_nova_addend_formula, GenericCpAZpBCSettings gcps, InertiaGravityFractalSettings igs, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs, String lyapunovInitialValue,  int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, int root_initialization_method, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean defaultNovaInitialValue, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, int period, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_center = rotation_center;
        this.rotation_vals = rotation_vals;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptrExpander = ptr;
        this.fs = fs;
        this.filters = fs.filters;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.height_ratio = height_ratio;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        this.domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptrExpander.getProgressBar();

        if (domain_coloring) {
            if (polar_projection) {
                action = DOMAIN_POLAR_EXPANDER;
            } else {
                action = DOMAIN_EXPANDER;
            }
        } else if (polar_projection) {
            action = POLAR_EXPANDER;
        } else {
            action = NORMAL_EXPANDER;
        }

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        tile = TILE_SIZE;

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = fractalFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, plane_type, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, kleinianLine, kleinianK, kleinianM, laguerre_deg, durand_kernel_init_val, mps, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_relaxation_formula, user_nova_addend_formula, gcps, igs, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, root_initialization_method, preffs, postffs, ips, defaultNovaInitialValue, cbs, useGlobalMethod, globalMethodFactor, period, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = fractalFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, plane_type, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, kleinianLine, kleinianK, kleinianM, laguerre_deg, durand_kernel_init_val, mps, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_relaxation_formula, user_nova_addend_formula, gcps, igs, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, root_initialization_method, preffs, postffs, ips, defaultNovaInitialValue, cbs, useGlobalMethod, globalMethodFactor, period, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(false);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new FractalIterationAlgorithm(fractal);

        default_init_val = fractal.getInitialValue();

        convergent_bailout = fractal.getConvergentBailout();

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rendering_done = 0;
        task_calculated = 0;
        task_calculated_extra = 0;

    }

    //Julia
    private void settingsJulia(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, D3Settings d3s, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, int plane_type, boolean apply_plane_on_julia, boolean apply_plane_on_julia_seed, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, DomainColoringSettings ds, boolean inverse_dem, boolean quickRender, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    BlendingSettings color_blending,   int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, String user_relaxation_formula, String user_nova_addend_formula, double[] laguerre_deg, GenericCpAZpBCSettings gcps, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs,  String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean juliter, int juliterIterations, boolean juliterIncludeInitialIterations, boolean defaultNovaInitialValue, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String perturbation_user_formula, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, boolean init_value, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String initial_value_user_formula, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_vals = rotation_vals;
        this.rotation_center = rotation_center;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptr = ptr;
        this.fs = fs;
        this.filters = fs.filters;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.d3 = d3s.d3;
        //this.d3_draw_method = d3_draw_method;
        this.detail = d3s.detail;
        this.fiX = d3s.fiX;
        this.fiY = d3s.fiY;
        this.height_ratio = height_ratio;
        this.d3_height_scale = d3s.d3_height_scale;
        this.height_algorithm = d3s.height_algorithm;
        scale = d3s.d3_size_scale;
        this.color_3d_blending = d3s.color_3d_blending;
        this.gaussian_scaling = d3s.gaussian_scaling;
        bilateral_scaling = d3s.bilateral_scaling;
        this.remove_outliers_pre = d3s.remove_outliers_pre;
        this.remove_outliers_post =d3s.remove_outliers_post;
        this.outliers_method = d3s.outliers_method;
        this.sigma_r = d3s.sigma_r;
        this.sigma_s_reciprocal = 1 / d3s.sigma_s;
        this.gaussian_kernel_size = d3s.gaussian_kernel;
        this.max_range = d3s.max_range;
        this.min_range = d3s.min_range;
        this.max_scaling = d3s.max_scaling;
        this.shade_height = d3s.shade_height;
        this.shade_choice = d3s.shade_choice;
        this.shade_algorithm = d3s.shade_algorithm;
        this.shade_invert = d3s.shade_invert;
        this.d3_color_type = d3s.d3_color_type;
        this.preHeightScaling = d3s.preHeightScaling;
        this.d3s = d3s;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        this.domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptr.getProgressBar();

        if (domain_coloring) {
            if (polar_projection) {
                action = DOMAIN_POLAR;
            } else {
                action = DOMAIN;
            }
        } else if (polar_projection) {
            action = POLAR;
        } else {
            action = NORMAL;
        }

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs, useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs, useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(true);
                ((Equicontinuity) fractal.getStatisticInstance()).setJuliIter(juliter);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new JuliaIterationAlgorithm(fractal);

        this.quickRender = quickRender;
        tile = TILE_SIZE;

        default_init_val = fractal.getInitialValue();

        convergent_bailout = fractal.getConvergentBailout();

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rendering_done = 0;
        task_calculated = 0;
        task_calculated_extra = 0;
        julia = true;

    }

    //Julia-Expander
    private void settingsJuliaExpander(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, ImageExpanderWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, int plane_type, boolean apply_plane_on_julia, boolean apply_plane_on_julia_seed, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, DomainColoringSettings ds, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    BlendingSettings color_blending,   int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, String user_relaxation_formula, String user_nova_addend_formula, double[] laguerre_deg, GenericCpAZpBCSettings gcps, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs,  String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean juliter, int juliterIterations, boolean juliterIncludeInitialIterations, boolean defaultNovaInitialValue, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String perturbation_user_formula, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, boolean init_value, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String initial_value_user_formula, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_vals = rotation_vals;
        this.rotation_center = rotation_center;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptrExpander = ptr;
        this.fs = fs;
        this.filters = fs.filters;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.height_ratio = height_ratio;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;


        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        this.domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptrExpander.getProgressBar();

        if (domain_coloring) {
            if (polar_projection) {
                action = DOMAIN_POLAR_EXPANDER;
            } else {
                action = DOMAIN_EXPANDER;
            }
        } else if (polar_projection) {
            action = POLAR_EXPANDER;
        } else {
            action = NORMAL_EXPANDER;
        }

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs,  useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs,  useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(true);
                ((Equicontinuity) fractal.getStatisticInstance()).setJuliIter(juliter);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new JuliaIterationAlgorithm(fractal);

        tile = TILE_SIZE;

        default_init_val = fractal.getInitialValue();

        convergent_bailout = fractal.getConvergentBailout();

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rendering_done = 0;
        task_calculated = 0;
        task_calculated_extra = 0;
        julia = true;

    }

    //Julia Map
    private void settingsJuliaMap(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, FiltersSettings fs, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, int plane_type, boolean apply_plane_on_julia, boolean apply_plane_on_julia_seed, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    BlendingSettings color_blending,   int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, String user_relaxation_formula, String user_nova_addend_formula, double[] laguerre_deg, GenericCpAZpBCSettings gcps, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs,  String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean juliter, int juliterIterations, boolean juliterIncludeInitialIterations, boolean defaultNovaInitialValue, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String perturbation_user_formula, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, boolean init_value, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String initial_value_user_formula, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_vals = rotation_vals;
        this.rotation_center = rotation_center;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptr = ptr;
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.height_ratio = height_ratio;

        this.color_blending = color_blending;

        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        this.post_processing_order = post_processing_order;

        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        progress = ptr.getProgressBar();

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        if (polar_projection) {
            action = JULIA_MAP_POLAR;
        } else {
            action = JULIA_MAP;
        }

        Apfloat xJuliaCenter, yJuliaCenter;

        if (polar_projection) {

            PolarLocationNormalApfloatArbitrary location = new PolarLocationNormalApfloatArbitrary(xCenter, yCenter, size, height_ratio, image.getWidth(), image.getHeight(), circle_period);
            BigPoint p = location.getPoint((int)(FROMx + (TOx - FROMx) * 0.5), (int)(FROMy + (TOy - FROMy) * 0.5));
            p = MathUtils.rotatePointRelativeToPoint(p, rotation_vals, rotation_center);

            xJuliaCenter = p.x;
            yJuliaCenter = p.y;
        } else {
            CartesianLocationNormalApfloatArbitrary location = new CartesianLocationNormalApfloatArbitrary(xCenter, yCenter, size, height_ratio, image.getWidth(), image.getHeight());
            BigPoint p = location.getPoint((int)(FROMx + (TOx - FROMx) * 0.5), (int)(FROMy + (TOy - FROMy) * 0.5));

            p = MathUtils.rotatePointRelativeToPoint(p, rotation_vals, rotation_center);

            xJuliaCenter = p.x;
            yJuliaCenter = p.y;
        }

        double mapxCenter = 0;
        double mapyCenter = 0;

        if (function == MainWindow.FORMULA27) {
            mapxCenter = -2;
        }

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = juliaFactory(function, mapxCenter, mapyCenter, size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs,  useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);
        fractal.setJuliaMap(true);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = juliaFactory(function, mapxCenter, mapyCenter, size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs, useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);
            f2.setJuliaMap(true);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(true);
                ((Equicontinuity) fractal.getStatisticInstance()).setJuliIter(juliter);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new JuliaIterationAlgorithm(fractal);

        default_init_val = fractal.getInitialValue();

        convergent_bailout = fractal.getConvergentBailout();

        rendering_done = 0;
        julia = true;

    }

    //Julia Preview
    private void settingsJuliaPreview(int FROMx, int TOx, int FROMy, int TOy, Apfloat xCenter, Apfloat yCenter, Apfloat size, int max_iterations, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, MainWindow ptr, Color fractal_color, Color dem_color, boolean fast_julia_filters, BufferedImage image, boolean periodicity_checking, int plane_type, boolean apply_plane_on_julia, boolean apply_plane_on_julia_seed, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, FiltersSettings fs, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, int function, double z_exponent, double[] z_exponent_complex, int color_cycling_location, int color_cycling_location2, Apfloat[] rotation_vals, Apfloat[] rotation_center, double[] coefficients, double[] z_exponent_nova, double[] relaxation, int nova_method, String user_formula, String user_formula2, int bail_technique, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, boolean exterior_de, double exterior_de_factor, double height_ratio, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, int escaping_smooth_algorithm, int converging_smooth_algorithm,  boolean polar_projection, double circle_period,   double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, boolean inverse_dem, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring,    BlendingSettings color_blending,   int[] post_processing_order,   PaletteGradientMergingSettings pbs,  GenericCaZbdZeSettings gcs, double[] coefficients_im, String[] lyapunovExpression, boolean useLyapunovExponent, int gradient_offset, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, String user_relaxation_formula, String user_nova_addend_formula, double[] laguerre_deg, GenericCpAZpBCSettings gcps, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs,  String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean juliter, int juliterIterations, boolean juliterIncludeInitialIterations, boolean defaultNovaInitialValue, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String perturbation_user_formula, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, boolean init_value, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String initial_value_user_formula, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower, Apfloat xJuliaCenter, Apfloat yJuliaCenter) {

        this.xCenter = xCenter;
        this.yCenter = yCenter;
        this.size = size;

        this.rotation_vals = rotation_vals;
        this.rotation_center = rotation_center;

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.max_iterations = max_iterations;
        this.ptr = ptr;
        this.fast_julia_filters = fast_julia_filters;
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.height_ratio = height_ratio;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        this.pbs = pbs;

        this.polar_projection = polar_projection;
        this.circle_period = circle_period;

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        progress = ptr.getProgressBar();

        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        if (polar_projection) {
            action = FAST_JULIA_POLAR;
        } else {
            action = FAST_JULIA;
        }

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        fractal = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs, useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);

        if(sts.statistic && sts.statisticGroup == 2) {
            Fractal f2 = fractal = juliaFactory(function, xCenter.doubleValue(), yCenter.doubleValue(), size, size.doubleValue(), max_iterations, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, Settings.fromDDArray(rotation_vals), Settings.fromDDArray(rotation_center), burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, z_exponent, z_exponent_complex, coefficients, coefficients_im, z_exponent_nova, relaxation, nova_method, bail_technique, user_formula, user_formula2, user_formula_iteration_based, user_formula_conditions, user_formula_condition_formula, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, gcs, lyapunovExpression, ots, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, converging_smooth_algorithm, sts, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, gcps, lfns, newton_hines_k, tcs, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, preffs, postffs, ips, juliter, juliterIterations, juliterIncludeInitialIterations, defaultNovaInitialValue, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, cbs, useGlobalMethod, globalMethodFactor, variable_re, variable_im, inflections_re, inflections_im, inflectionsPower, xJuliaCenter, yJuliaCenter);
            if(fractal.getStatisticInstance() != null) {
                ((Equicontinuity) fractal.getStatisticInstance()).setFractal(f2);
                ((Equicontinuity) fractal.getStatisticInstance()).setJulia(true);
                ((Equicontinuity) fractal.getStatisticInstance()).setJuliIter(juliter);
            }
        }

        setTrueColoringOptions(tcs);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        iteration_algorithm = new JuliaIterationAlgorithm(fractal);

        task_calculated = -1;
        julia = true;

    }

    //Color Cycling
    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, int max_iterations, MainWindow ptr, Color fractal_color, Color dem_color, BufferedImage image, int color_cycling_location, int color_cycling_location2, FiltersSettings fs, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, DomainColoringSettings ds, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, PostProcessSettings pps, ColorCyclingSettings ccs) {

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.ptr = ptr;
        this.max_iterations = max_iterations;
        this.image = image;
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.contourFactor = contourFactor;
        this.gps = gps;

        action = COLOR_CYCLING;

        this.ccs = ccs;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        setPostProcessingData(pps);

        this.bms = new BumpMapSettings(bms);
        this.ls = new LightSettings(ls);
        this.ss = new SlopeSettings(ss);
        this.pbs = pbs;

        domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptr.getProgressBar();

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        task_calculated = -1;

    }

    //Apply Filter
    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, int max_iterations, MainWindow ptr, BufferedImage image, Color fractal_color, Color dem_color, int color_cycling_location, int color_cycling_location2, FiltersSettings fs, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, DomainColoringSettings ds, int gradient_offset, double contourFactor, boolean smoothing, GeneratedPaletteSettings gps, PostProcessSettings pps) {

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.ptr = ptr;
        this.max_iterations = max_iterations;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.contourFactor = contourFactor;
        action = APPLY_PALETTE_AND_FILTER;
        this.gps = gps;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        setPostProcessingData(pps);

        this.pbs = pbs;

        domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        progress = ptr.getProgressBar();

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        if (domain_coloring) {
            domainColoringFactory(ds, COLOR_SMOOTHING_METHOD);
        }

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        rendering_done = 0;

        task_calculated = -1;

    }

    //Rotate 3d model
    public TaskRender(int FROMx, int TOx, int FROMy, int TOy, D3Settings d3s, boolean render_action, MainWindow ptr, BufferedImage image, FiltersSettings fs, BlendingSettings color_blending, double contourFactor, boolean smoothing, GeneratedPaletteSettings gps) {

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.ptr = ptr;
        this.image = image;
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.d3 = true;
        this.detail = d3s.detail;
        this.fiX = d3s.fiX;
        this.fiY = d3s.fiY;
        //this.d3_draw_method = d3_draw_method;
        this.color_3d_blending = d3s.color_3d_blending;
        this.contourFactor = contourFactor;

        this.color_blending = color_blending;

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        scale = d3s.d3_size_scale;

        d3_color_type = d3s.d3_color_type;

        progress = ptr.getProgressBar();

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        if (render_action) {
            action = ROTATE_3D_MODEL;
        } else {
            action = APPLY_PALETTE_AND_FILTER_3D_MODEL;
            rendering_done = 0;
        }

        task_calculated = -1;

    }

    //AA Palette and Post Processing
    public TaskRender(int action , int FROMx, int TOx, int FROMy, int TOy, int max_iterations, MainWindow ptr, BufferedImage image, Color fractal_color, Color dem_color, int color_cycling_location, int color_cycling_location2, FiltersSettings fs, double color_intensity, int transfer_function, double color_density, double color_intensity2, int transfer_function2, double color_density2, boolean usePaletteForInColoring, BlendingSettings color_blending, int[] post_processing_order, PaletteGradientMergingSettings pbs, int gradient_offset, double contourFactor, GeneratedPaletteSettings gps, PostProcessSettings pps, DomainColoringSettings ds) {

        this.FROMx = FROMx;
        this.TOx = TOx;
        this.FROMy = FROMy;
        this.TOy = TOy;
        this.ptr = ptr;
        this.max_iterations = max_iterations;
        this.image = image;
        this.fractal_color = fractal_color.getRGB();
        this.dem_color = dem_color.getRGB();
        this.color_cycling_location_outcoloring = color_cycling_location;
        this.color_cycling_location_incoloring = color_cycling_location2;
        this.gradient_offset = gradient_offset;
        this.fs = fs;
        this.filters = fs.filters;
        this.filters_colors = fs.filters_colors;
        this.filters_extra_colors = fs.filters_extra_colors;
        this.filters_order = fs.filters_order;
        this.filters_options_vals = fs.filters_options_vals;
        this.filters_options_extra_vals = fs.filters_options_extra_vals;
        this.contourFactor = contourFactor;
        this.action = action;
        this.gps = gps;

        this.domain_coloring = ds.domain_coloring;
        ColorAlgorithm.DomainColoringBypass = domain_coloring;

        this.color_blending = color_blending;

        this.post_processing_order = post_processing_order;

        setPostProcessingData(pps);

        this.pbs = pbs;

        progress = ptr.getProgressBar();

        this.usePaletteForInColoring = usePaletteForInColoring;
        colorTransferFactory(transfer_function, transfer_function2, color_intensity, color_intensity2, color_density, color_density2);

        blending = blendingFactory(COLOR_SMOOTHING_METHOD, color_blending.color_blending);
        blending.setReverseColors(color_blending.blending_reversed_colors);

        interpolationFactory(COLOR_SMOOTHING_METHOD);

        rgbs = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

        rendering_done = 0;

        task_calculated = -1;

    }

    @Override
    public void run() {

        Thread t = Thread.currentThread();
        doneByThreadName = t.getName();
        doneByThreadId = t.getId();

        try {
            switch (action) {

                case NORMAL:
                    if (quickRender) {
                        quickRendering();
                    } else {
                        rendering();
                    }
                    break;
                case FAST_JULIA:
                    fastJuliaRendering();
                    break;
                case COLOR_CYCLING:
                    colorCycling();
                    break;
                case APPLY_PALETTE_AND_FILTER:
                    applyPaletteAndFilter();
                    break;
                case JULIA_MAP:
                    juliaMapRendering();
                    break;
                case ROTATE_3D_MODEL:
                    rotate3DModel();
                    break;
                case APPLY_PALETTE_AND_FILTER_3D_MODEL:
                    applyPaletteAndFilter3DModel();
                    break;
                case POLAR:
                    if (quickRender) {
                        quickPolarRendering();
                    } else {
                        polarRendering();
                    }
                    break;
                case FAST_JULIA_POLAR:
                    fastJuliaRenderingPolar();
                    break;
                case JULIA_MAP_POLAR:
                    juliaMapPolarRendering();
                    break;
                case DOMAIN:
                    if (quickRender) {
                        quickDomainRendering();
                    } else {
                        domainRendering();
                    }
                    break;
                case DOMAIN_POLAR:
                    if (quickRender) {
                        quickDomainPolarRendering();
                    } else {
                        domainPolarRendering();
                    }
                    break;
                case NORMAL_EXPANDER:
                    expanderRendering();
                    break;
                case POLAR_EXPANDER:
                    polarExpanderRendering();
                    break;
                case DOMAIN_EXPANDER:
                    domainExpanderRendering();
                    break;
                case DOMAIN_POLAR_EXPANDER:
                    domainPolarExpanderRendering();
                    break;
                case POST_PROCESSING_WITH_AA_AND_FILTER:
                    applyPostProcessingWithAAandFilter();
                    break;
                case APPLY_PALETTE_AND_POST_PROCESSING_WITH_AA_AND_FILTER:
                    applyPaletteAndFilterWithAA();
                    break;
            }
        } catch (OutOfMemoryError e) {
            if (ptrExpander != null) {
                JOptionPane.showMessageDialog(ptrExpander, "Maximum Heap size was reached.\nPlease set the maximum Heap size to a higher value.\nThe application will terminate.", "Error!", JOptionPane.ERROR_MESSAGE);
                ptrExpander.savePreferences();
            } else {
                JOptionPane.showMessageDialog(ptr, "Maximum Heap size was reached.\nThe application will terminate.", "Error!", JOptionPane.ERROR_MESSAGE);
                ptr.savePreferences();
            }
            e.printStackTrace();
            TaskRender.deleteLibs();
            TaskRender.shutdownThreadPools();
            System.exit(-1);
        }
        catch (IllegalMonitorStateException ex) {

        }
        catch (Exception ex) {
            if (ptrExpander != null) {
                JOptionPane.showMessageDialog(ptrExpander, "An error has occurred.", "Error!", JOptionPane.ERROR_MESSAGE);
                ptrExpander.savePreferences();
            } else {
                JOptionPane.showMessageDialog(ptr, "An error has occurred.", "Error!", JOptionPane.ERROR_MESSAGE);
                ptr.savePreferences();
            }
            ex.printStackTrace();
            TaskRender.deleteLibs();
            TaskRender.shutdownThreadPools();
            System.exit(-1);
        }
        DONE = true;
        int number = number_of_tasks.decrementAndGet();

        if(ptr != null && number == 0) {
            ptr.getMainPanel().stopTimer();
        }
    }


    public TaskStatistic getTaskStatistic() {

        if(action == COLOR_CYCLING) {
            return null;
        }

        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;

        int supersampling_num;
        if(!filters[MainWindow.ANTIALIASING]) {
            supersampling_num = 1;
        }
        else {
            supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod) + 1;
        }

        return new TaskStatistic(taskId, doneByThreadName, pixel_calculation_time_per_task, post_processing_calculation_time_per_task, task_calculated, task_calculated_extra, task_completed, task_post_processed, WIDTH * HEIGHT, supersampling_num, new Color(algorithm_colors[(int)(getRandomThreadId() % algorithm_colors.length)]));
    }

    private long getRandomThreadId() {
        return (doneByThreadId + randomNumber ) * 19;
    }

    private void domainExpanderRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            renderDomainAntialiased(image_width, image_height, false);
        } else {
            renderDomain(image_width, image_height, false);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptrExpander.getNumberOfThreads()) {

            image_iterations = null;
            escaped = null;

            applyFilters();

            progress.setValue(progress.getMaximum());

            ptrExpander.writeImageToDisk();

            ptrExpander.setOptions(true);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    private String _getBigNumLibString(String name) {
        return "<li>BigNum Library: <b>" + name + "<b><br>";
    }

    private String _getBigNumLibPrecString(long val) {
        return "<li>BigNum Precision: <b>" + val + " bits</b><br>";
    }

    private String getFloatExpString(boolean isDeep) {

        if(!domain_coloring && !HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && fractal.supportsPerturbationTheory()) {
            if(isDeep) {
                return "<li>Deltas Library: <b>Extended Range</b><br>" +
                        "<li>Complex Extended Range Format: " +
                        (MANTEXPCOMPLEX_FORMAT == 0 ? "<b>Combined Exponent</b>" : "<b>Two Exponents</b>") + "<br>";
            }
            else {
                return "<li>Deltas Library: <b>Double</b><br>";
            }
        }
        return "";
    }
    private String getBigNumString(int bigNumLib, int arbitraryLib) {

        if(!domain_coloring && HIGH_PRECISION_CALCULATION && fractal.supportsPerturbationTheory()) {
            if(arbitraryLib == Constants.ARBITRARY_BUILT_IN && fractal.supportsBignum()) {
                return _getBigNumLibString(BigNum.getName()) + _getBigNumLibPrecString(BigNum.getPrecision());
            }
            else if(arbitraryLib == Constants.ARBITRARY_BIGINT && fractal.supportsBigIntnum()) {
                return _getBigNumLibString("Fixed Point BigInteger") + _getBigNumLibPrecString(BigIntNum.getPrecision());
            }
            else if(arbitraryLib == Constants.ARBITRARY_MPFR && fractal.supportsMpfrBignum()) {
                return _getBigNumLibString("MPFR " + LibMpfr.mpfr_version) + _getBigNumLibPrecString(MpfrBigNum.precision);
            }
            else if(arbitraryLib == Constants.ARBITRARY_MPIR && fractal.supportsMpirBignum()) {
                return _getBigNumLibString("MPIR " + LibMpir.__mpir_version) + _getBigNumLibPrecString(MpirBigNum.precision);
            }
            else if(arbitraryLib == Constants.ARBITRARY_DOUBLEDOUBLE) {
                return _getBigNumLibString("DoubleDouble") + _getBigNumLibPrecString(106);
            }
            else if(arbitraryLib == Constants.ARBITRARY_APFLOAT) {
                return _getBigNumLibString("Apfloat");
            }
        }
        else if(!domain_coloring && PERTURBATION_THEORY && fractal.supportsPerturbationTheory()) {
            if(bigNumLib == Constants.BIGNUM_BUILT_IN && fractal.supportsBignum()) {
                return _getBigNumLibString(BigNum.getName()) + _getBigNumLibPrecString(BigNum.getPrecision());
            }
            else if(bigNumLib == Constants.BIGNUM_BIGINT && fractal.supportsBigIntnum()) {
                return _getBigNumLibString("Fixed Point BigInteger") + _getBigNumLibPrecString(BigIntNum.getPrecision());
            }
            else if(bigNumLib == Constants.BIGNUM_MPFR && fractal.supportsMpfrBignum()) {
                return _getBigNumLibString("MPFR " + LibMpfr.mpfr_version) + _getBigNumLibPrecString(MpfrBigNum.precision);
            }
            else if(bigNumLib == Constants.BIGNUM_MPIR && fractal.supportsMpirBignum()) {
                return _getBigNumLibString("MPIR " + LibMpir.__mpir_version) + _getBigNumLibPrecString(MpirBigNum.precision);
            }
            else if(bigNumLib == Constants.BIGNUM_DOUBLE) {
                return _getBigNumLibString("Double") + _getBigNumLibPrecString(MpfrBigNum.doublePrec);
            }
            else if(bigNumLib == Constants.BIGNUM_DOUBLEDOUBLE) {
                return _getBigNumLibString("DoubleDouble") + _getBigNumLibPrecString(106);
            }
            else if(bigNumLib == Constants.BIGNUM_APFLOAT) {
                return _getBigNumLibString("Apfloat");
            }
        }
        return "";
    }

    private String getPixelsString(long total, long total_calculated_pixels, long total_calculated_extra_pixels, long total_completed_pixels, long total_pp, int supersampling_num) {
        if(filters[MainWindow.ANTIALIASING] && !quickRender) {

            long totalWithSuperSampling = total * supersampling_num;
            long totalCalculatedWithSuperSampling = total_calculated_pixels * supersampling_num;
            long totalExtraWithSuperSampling = total_calculated_extra_pixels * supersampling_num;
            long totalCompletedWithSuperSampling = total_completed_pixels * supersampling_num;
            long totalPPWithSuperSampling = total_pp * supersampling_num;

            String val = "<li>Anti-Aliasing Samples: <b>" +  supersampling_num + "x</b><br>" +
                    IMAGE_SIZE_LABEL + supersampling_num + "x" +  WIDTH + "x" +  HEIGHT + " (" + (supersampling_num * WIDTH * HEIGHT) + " Pixels)</b><br>" +
                    PIXELS_CALCULATED_COUNT_LABEL +  totalCalculatedWithSuperSampling + " / " + totalWithSuperSampling + " (" +String.format("%f", (((double) totalCalculatedWithSuperSampling) / totalWithSuperSampling) * 100) + "%)</b><br>";

            if(totalCompletedWithSuperSampling >= 0) {
                val += PIXELS_COMPLETED_COUNT_LABEL + totalCompletedWithSuperSampling + " / " + (totalWithSuperSampling) + " (" + String.format("%f", (((double) totalCompletedWithSuperSampling) / (totalWithSuperSampling)) * 100) + "%)</b><br>";
            }

            if(TaskRender.GREEDY_ALGORITHM) {// && (!createFullImageAfterPreview || filters[MainWindow.ANTIALIASING])) {
                val += PIXELS_GUESSED_COUNT_LABEL + (totalCompletedWithSuperSampling - totalCalculatedWithSuperSampling) + " / " + (totalCompletedWithSuperSampling) + " (" + String.format("%f", (((double) (totalCompletedWithSuperSampling - totalCalculatedWithSuperSampling)) / (totalWithSuperSampling)) * 100) + "%)</b><br>";
            }

            if(totalPPWithSuperSampling > 0) {
                val += PIXELS_POST_PROCESSED_COUNT_LABEL + totalPPWithSuperSampling + " / " + (totalWithSuperSampling) + " (" + String.format("%f", (((double) totalPPWithSuperSampling) / (totalWithSuperSampling)) * 100) + "%)</b><br>";
            }

            if(totalExtraWithSuperSampling != 0) {
                val += EXTRA_PIXELS_CALCULATED_COUNT_LABEL + totalExtraWithSuperSampling + "</b><br>";
            }

            return val;
        }
        else {
            String val = IMAGE_SIZE_LABEL + WIDTH + "x" +  HEIGHT + " (" + (WIDTH * HEIGHT) + " Pixels)</b><br>" +
                    PIXELS_CALCULATED_COUNT_LABEL + total_calculated_pixels + " / " + (total) + " (" + String.format("%f", (((double) total_calculated_pixels) / (total)) * 100) + "%)</b><br>";

            if(total_completed_pixels >= 0) {
                val += PIXELS_COMPLETED_COUNT_LABEL + total_completed_pixels + " / " + (total) + " (" + String.format("%f", (((double) total_completed_pixels) / (total)) * 100) + "%)</b><br>";
            }

            if(TaskRender.GREEDY_ALGORITHM && !quickRender) {// && (!createFullImageAfterPreview || filters[MainWindow.ANTIALIASING])) {
                val += PIXELS_GUESSED_COUNT_LABEL + (total_completed_pixels - total_calculated_pixels) + " / " + (total_completed_pixels) + " (" + String.format("%f", (((double) (total_completed_pixels - total_calculated_pixels)) / (total_completed_pixels)) * 100) + "%)</b><br>";
            }

            if(total_pp > 0 && !quickRender) {
                val += PIXELS_POST_PROCESSED_COUNT_LABEL + total_pp + " / " + (total) + " (" + String.format("%f", (((double) total_pp) / (total)) * 100) + "%)</b><br>";
            }

            if(total_calculated_extra_pixels != 0) {
                val += EXTRA_PIXELS_CALCULATED_COUNT_LABEL + total_calculated_extra_pixels + "</b><br>";
            }
            return val;
        }
    }

    private String getPixelStringSmall(boolean juliaMap, boolean afterAA, long total, long total_pp, int supersampling_num) {

        long total_calculated_pixels = total;
        long total_completed_pixels = total;

        if(filters[MainWindow.ANTIALIASING] && (juliaMap || afterAA)) {

            long totalWithSuperSampling = total * supersampling_num;
            long totalCalculatedWithSuperSampling = total_calculated_pixels * supersampling_num;
            long totalCompletedWithSuperSampling = total_completed_pixels * supersampling_num;
            long totalPPWithSuperSampling = total_pp * supersampling_num;

            String val = "<li>Anti-Aliasing Samples: <b>" +  supersampling_num + "x</b><br>" +
                    IMAGE_SIZE_LABEL + supersampling_num + "x" +  WIDTH + "x" +  HEIGHT + " (" + (supersampling_num * WIDTH * HEIGHT) + " Pixels)</b><br>" +
                    (juliaMap ? PIXELS_CALCULATED_COUNT_LABEL +  totalCalculatedWithSuperSampling + " / " + totalWithSuperSampling + " (" +String.format("%f", (((double) totalCalculatedWithSuperSampling) / totalWithSuperSampling) * 100) + "%)</b><br>" : "") +
                    PIXELS_COMPLETED_COUNT_LABEL + totalCompletedWithSuperSampling + " / " + (totalWithSuperSampling) + " (" + String.format("%f", (((double) totalCompletedWithSuperSampling) / (totalWithSuperSampling)) * 100) + "%)</b><br>";

            if(totalPPWithSuperSampling > 0) {
                val += PIXELS_POST_PROCESSED_COUNT_LABEL + totalPPWithSuperSampling + " / " + (totalWithSuperSampling) + " (" + String.format("%f", (((double) totalPPWithSuperSampling) / (totalWithSuperSampling)) * 100) + "%)</b><br>";
            }


            return val;
        }
        else {
            String val = IMAGE_SIZE_LABEL + WIDTH + "x" +  HEIGHT + " (" + (WIDTH * HEIGHT) + " Pixels)</b><br>" +
                    //PIXELS_CALCULATED_COUNT_LABEL + total_calculated_pixels + " / " + (total) + " (" + String.format("%f", (((double) total_calculated_pixels) / (total)) * 100) + "%)</b><br>" +
                    PIXELS_COMPLETED_COUNT_LABEL + total_completed_pixels + " / " + (total) + " (" + String.format("%f", (((double) total_completed_pixels) / (total)) * 100) + "%)</b><br>";

            if(total_pp > 0) {
                val += PIXELS_POST_PROCESSED_COUNT_LABEL + total_pp + " / " + (total) + " (" + String.format("%f", (((double) total_pp) / (total)) * 100) + "%)</b><br>";
            }

            return val;
        }
    }

    public static final String PIXEL_GROUPING_STRING_LABEL = "Guessed Pixels Group";
    private String getPixelGroupingString(int supersampling_num) {

        String result = "";

        long total = 0;
        for(LongAdder a : total_pixel_grouping) {
            total += a.sum();
        }

        total = total * supersampling_num;

        int i = 1;
        for(LongAdder a : total_pixel_grouping) {
            long v = a.sum() * supersampling_num;
            if(v != 0) {
                result += "<li>" + PIXEL_GROUPING_STRING_LABEL + " " + i + ": <b>" + v + " / " + total + " (" +String.format("%f", (((double) v) / total) * 100) + "%)" + "</b><br>";
            }
            i++;
        }

        return result;
    }

    private String getAlgorithmUsed() {

        if(!domain_coloring && (PERTURBATION_THEORY && !HIGH_PRECISION_CALCULATION) && fractal.supportsPerturbationTheory()) {
            return "<li>Using <b>Perturbation Theory</b><br>";
        }
        else if(!domain_coloring && HIGH_PRECISION_CALCULATION && fractal.supportsPerturbationTheory()) {
            return "<li>Using <b>Arbitrary Precision</b><br>";
        }
        else {
            return "<li>Using <b>Double Precision</b><br>";
        }
    }

    private String getCompressionInfo(int refPointIterations, int secondRefPointIterations) {

        int waypoints = 0;
        int waypoints2 = 0;

        String referenceDataWaypoints = "" + waypoints;
        if(Fractal.referenceDeepData != null && Fractal.referenceDeepData.exists()) {
            ArrayList<Integer> waypointsList = Fractal.referenceDeepData.getWaypointsLength();
            waypoints = waypointsList.stream().mapToInt(v -> v).max().orElse(0);
            if(waypointsList.size() == 1) {
                referenceDataWaypoints = "" + waypointsList.get(0);
            }
            else {
                referenceDataWaypoints = "[" + String.join(", ", waypointsList.stream().map(i -> "" + i).collect(Collectors.toList())) + "]";
            }
        }
        else if(Fractal.referenceData != null && Fractal.referenceData.exists()) {
            ArrayList<Integer> waypointsList = Fractal.referenceData.getWaypointsLength();
            waypoints = waypointsList.stream().mapToInt(v -> v).max().orElse(0);
            if(waypointsList.size() == 1) {
                referenceDataWaypoints = "" + waypointsList.get(0);
            }
            else {
                referenceDataWaypoints = "[" + String.join(", ", waypointsList.stream().map(i -> "" + i).collect(Collectors.toList())) + "]";
            }
        }

        String result =  "<li>Reference Compression Waypoints: <b>" + referenceDataWaypoints + "</b><br>";
        result += "<li>Reference Compression Ratio: <b>" + (waypoints > 0 ?  (refPointIterations) + " / " + (waypoints) + " (" + String.format("%.4f", refPointIterations / ((double)waypoints)) + "x)" : "N/A")  + "</b><br>";

        if(fractal.needsSecondReference()) {

            String referenceDataWaypoints2 = "" + waypoints2;
            if(Fractal.secondReferenceDeepData != null && Fractal.secondReferenceDeepData.exists()) {
                ArrayList<Integer> waypointsList = Fractal.secondReferenceDeepData.getWaypointsLength();
                waypoints2 = waypointsList.stream().mapToInt(v -> v).max().orElse(0);
                if(waypointsList.size() == 1) {
                    referenceDataWaypoints2 = "" + waypointsList.get(0);
                }
                else {
                    referenceDataWaypoints2 = "[" + String.join(", ", waypointsList.stream().map(i -> "" + i).collect(Collectors.toList())) + "]";
                }
            }
            else if(Fractal.secondReferenceData != null && Fractal.secondReferenceData.exists()) {
                ArrayList<Integer> waypointsList = Fractal.secondReferenceData.getWaypointsLength();
                waypoints2 = waypointsList.stream().mapToInt(v -> v).max().orElse(0);
                if(waypointsList.size() == 1) {
                    referenceDataWaypoints2 = "" + waypointsList.get(0);
                }
                else {
                    referenceDataWaypoints2 = "[" + String.join(", ", waypointsList.stream().map(i -> "" + i).collect(Collectors.toList())) + "]";
                }
            }

            result += "<li>Julia Extra Reference Compression Waypoints: <b>" + referenceDataWaypoints2 + "</b><br>";
            result += "<li>Julia Extra Reference Compression Ratio: <b>" + (waypoints2 > 0 ?  (secondRefPointIterations) + " / " + (waypoints2) + " (" + String.format("%.4f", secondRefPointIterations / ((double)waypoints2)) + "x)" : "N/A")  + "</b><br>";

        }

        return result;
    }

    private String getApproximationString(boolean supportsPerturbation) {

        if(!(!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation)) {
            return "";
        }

        String approximation = "<li>Approximation: ";
        if(APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation()) {
            approximation += "<b>Series Approximation</b><br>";
        }
        else if(APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation()) {
            approximation += "<b>Bilinear Approximation (claude)</b><br>";
        }
        else if(APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1()) {
            approximation += "<b>Nanomb1</b><br>";
        }
        else if(APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2()) {
            approximation += "<b>Bilinear Approximation (Zhuoran)</b><br>";
        }
        else {
            approximation += "<b>No Approximation</b><br>";
        }

        return approximation;
    }

    public void setFullToolTipMessage(int total) {

        long time =  ptr != null ? ptr.getCalculationTime() : ptrExpander.getCalculationTime();
        int threads = ptr != null ? ptr.getNumberOfThreads() : ptrExpander.getNumberOfThreads();

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num;

        if(!filters[MainWindow.ANTIALIASING]) {
            supersampling_num = 1;
        }
        else {
            supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod) + 1;
        }

        if(quickRender) {
            supersampling_num = 1;
        }

        long total_calculated_pixels = total_calculated.sum();
        long total_calculated_extra_pixels = total_calculated_extra.sum();
        long total_completed_pixels = total_completed.sum();

        if(d3) {
            total = detail * detail;
        }

        long total_time = System.currentTimeMillis() - time;

        int bigNumLib = getBignumLibrary(size, fractal);

        int arbitraryLib = getHighPrecisionLibrary(size, fractal);

        boolean isDeep = useExtendedRange(size, fractal);

        String oldValue = "";
        if(createFullImageAfterPreview) {
            oldValue = progress.getToolTipText();
            oldValue = oldValue.replace("<html>", "");
            oldValue = oldValue.replace("</html>", "");
        }

        int refPointIterations = fractal.getReferenceFinalIterationNumber(false, Fractal.referenceData) + 1;
        int secondRefPointIterations = Fractal.secondReferenceData.MaxRefIteration + 1;

        boolean supportsPerturbation = fractal.supportsPerturbationTheory() && !domain_coloring;

        long total_pp = total_post_processed.sum();

        progress.setToolTipText("<html><li>Total Elapsed Time: <b>" + total_time + " ms</b><br>" +
                getPixelsString(total, total_calculated_pixels, total_calculated_extra_pixels, total_completed_pixels, total_pp, supersampling_num) +
                "<li>Logical Processors: <b>" + Runtime.getRuntime().availableProcessors() + "</b><br>" +
                "<li>Threads Used: <b>" + threads + "</b><br>" +
                getAlgorithmUsed() +
                ((PERTURBATION_THEORY || HIGH_PRECISION_CALCULATION) && supportsPerturbation ? "<li>Arbitrary Precision: <b>" + MyApfloat.precision + " digits</b><br>" : "") +
                getBigNumString(bigNumLib, arbitraryLib) +
                getFloatExpString(isDeep) +
                PIXEL_CALCULATION_ELAPSED_TIME_STRING_LABEL + max_pixel_calculation_time.get() + " ms</b><br>" +
                (!quickRender && total_pp > 0 && PostProcessingCalculationTime.get() != Long.MIN_VALUE ? POST_PROCESSING_ELAPSED_TIME_STRING_LABEL + PostProcessingCalculationTime.get() + " ms</b><br>" : "") +
                (!quickRender && FilterCalculationTime > 0? IMAGE_FILTERS_TIME_STRING_LABEL + FilterCalculationTime + " ms</b><br>" : "")+
                (d3 && D3RenderingCalculationTime > 0? D3_RENDER_TIME_STRING_LABEL + D3RenderingCalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && Fractal.ReferenceCalculationTime > 0 ? REFERENCE_CALCULATION_ELAPSED_TIME_STRING_LABEL + Fractal.ReferenceCalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation  ? "<li>Reference Point Iterations: <b>" + refPointIterations + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && Fractal.ReferenceCalculationTime > 0 && Fractal.calculatedReferenceIterations > 0 ? "<li>Reference Point Iterations per second: <b>" + String.format("%.4f", Fractal.calculatedReferenceIterations / ((double)Fractal.ReferenceCalculationTime / 1000.0)) + "</b><br>" : "") +

                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && fractal.needsSecondReference() && Fractal.SecondReferenceCalculationTime > 0 ? JULIA_EXTRA_REFERENCE_CALCULATION_ELAPSED_TIME_STRING_LABEL + Fractal.SecondReferenceCalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation  && fractal.needsSecondReference() ? "<li>Julia Extra Reference Point Iterations: <b>" + secondRefPointIterations + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation  && fractal.needsSecondReference() && Fractal.SecondReferenceCalculationTime > 0 && Fractal.calculatedSecondReferenceIterations > 0 ? "<li>Julia Extra Reference Point Iterations per second: <b>" + String.format("%.4f", Fractal.calculatedSecondReferenceIterations / ((double)Fractal.SecondReferenceCalculationTime / 1000.0)) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && COMPRESS_REFERENCE_IF_POSSIBLE && fractal.supportsReferenceCompression() ? getCompressionInfo(refPointIterations, secondRefPointIterations) : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && DETECT_PERIOD && fractal.supportsPeriod()  ? "<li>Detected Period: <b>" + (Fractal.DetectedPeriod != 0 ? Fractal.DetectedPeriod : "N/A") + "</b><br>" : "") + //&& Fractal.DetectedPeriod != 0
                //(!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && DETECT_PERIOD && fractal.supportsPeriod() && Fractal.DetectedPeriod != Fractal.DetectedAtomPeriod ? "<li>Detected Atom Period: <b>" + Fractal.DetectedAtomPeriod + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && fractal.supportsPeriod() && fractal.getPeriod()  != 0 && Fractal.SAskippedIterations == 0 ? "<li>Used Period: <b>" + fractal.getPeriod() + "</b><br>" : "") +
                getApproximationString(supportsPerturbation) +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation() && Fractal.SAskippedIterations != 0 && Fractal.SATerms != 0 && Fractal.SACalculationTime > 0? SA_CALCULATION_ELAPSED_TIME_LABEL + Fractal.SACalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation() && Fractal.SAskippedIterations != 0 && Fractal.SATerms != 0 ? "<li>SA Terms Used: <b>" + Fractal.SATerms + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation() && Fractal.SAskippedIterations != 0 && Fractal.SATerms != 0 ? SA_SKIPPED_ITERATIONS_STRING_LABEL + Fractal.SAskippedIterations + "</b><br>": "") +

                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1() && Fractal.Nanomb1CalculationTime > 0 ? NANOMB1_CALCULATION_ELAPSED_TIME_LABEL + Fractal.Nanomb1CalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1() ? "<li>Nanomb1 M: <b>" + NANOMB1_M + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1() ? "<li>Nanomb1 N: <b>" + NANOMB1_N + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1() ? NANOMB1_SKIPPED_ITERATIONS_PER_PIXEL_STRING_LABEL + String.format("%.4f", Fractal.total_nanomb1_skipped_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>": "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2() && Fractal.BLACalculationTime > 0) ? BLA_CALCULATION_ELAPSED_TIME_LABEL + Fractal.BLACalculationTime + " ms</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation()  ? "<li>BLA Precision: <b>" + TaskRender.BLA_BITS + " bits</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation()  ? "<li>BLA Starting Level: <b>" + TaskRender.BLA_STARTING_LEVEL + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() || APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? "<li>BLA Entries: <b>" + fractal.getBLAEntries() + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? BLA_ITERATIONS_PER_PIXEL_STRING_LABEL +  String.format("%.4f", Fractal.total_bla_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? "<li>BLA Iterations Per BLA Step: <b>" +  (Fractal.total_bla_steps.sum() == 0 ? "N/A" : String.format("%.4f", Fractal.total_bla_iterations.sum() / ((double)Fractal.total_bla_steps.sum()))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? PERTURBATION_ITERATIONS_PER_PIXEL_STRING_LABEL +  String.format("%.4f", Fractal.total_perturb_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? "<li>BLA Steps Per Pixel: <b>" + String.format("%.4f", Fractal.total_bla_steps.sum() / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() ||  APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2())  ? "<li>Total Steps Per Pixel: <b>" + String.format("%.4f", (Fractal.total_bla_steps.sum() + Fractal.total_perturb_iterations.sum()) / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && TaskRender.PERTUBATION_PIXEL_ALGORITHM == 1 && fractal.supportsScaledIterations() && isDeep ? EXTENDED_RANGE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_float_exp_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && TaskRender.PERTUBATION_PIXEL_ALGORITHM == 1 && fractal.supportsScaledIterations() && isDeep ? SCALED_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_scaled_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && TaskRender.PERTUBATION_PIXEL_ALGORITHM == 1 && fractal.supportsScaledIterations() && isDeep ? NORMAL_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_double_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && (TaskRender.PERTUBATION_PIXEL_ALGORITHM == 0 || !fractal.supportsScaledIterations()) && isDeep ? EXTENDED_RANGE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_float_exp_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && (TaskRender.PERTUBATION_PIXEL_ALGORITHM == 0 || !fractal.supportsScaledIterations()) && isDeep ? NORMAL_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_double_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && !isDeep ? NORMAL_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL +  (String.format("%.4f", Fractal.total_double_iterations.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation && (APPROXIMATION_ALGORITHM != 2 || !fractal.supportsBilinearApproximation()) && (APPROXIMATION_ALGORITHM != 4 || !fractal.supportsBilinearApproximation2()) && TaskRender.PERTUBATION_PIXEL_ALGORITHM == 1 && fractal.supportsScaledIterations() && isDeep ? "<li>Re-Aligns Per Pixel: <b>" +  (String.format("%.4f", Fractal.total_realigns.sum() / ((double) total_calculated_pixels * (supersampling_num)))) + "</b><br>" : "") +
                (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY && supportsPerturbation ? "<li>Rebases Per Pixel: <b>" +  String.format("%.4f", Fractal.total_rebases.sum() / ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (((HIGH_PRECISION_CALCULATION && GATHER_HIGHPRECISION_STATISTICS) || (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY)) && supportsPerturbation ? "<li>Average Iterations Per Pixel: <b>" +  String.format("%.4f", (Fractal.total_iterations.sum())/ ((double) total_calculated_pixels * (supersampling_num))) + "</b><br>" : "") +
                (((HIGH_PRECISION_CALCULATION && GATHER_HIGHPRECISION_STATISTICS) || (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY)) && supportsPerturbation ? "<li>Minimum Iterations: <b>" +  Fractal.total_min_iterations.get() + "</b><br>" : "") +
                (((HIGH_PRECISION_CALCULATION && GATHER_HIGHPRECISION_STATISTICS) || (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY)) && supportsPerturbation ? "<li>Maximum Iterations: <b>" +  Fractal.total_max_iterations.get() + "</b><br>" : "") +
                (((HIGH_PRECISION_CALCULATION && GATHER_HIGHPRECISION_STATISTICS) || (!HIGH_PRECISION_CALCULATION && GATHER_PERTURBATION_STATISTICS && PERTURBATION_THEORY)) && supportsPerturbation ? "<li>Maximum Iterations (Ignore Not Escaped Points): <b>" +  Fractal.total_max_iterations_ignore_max_iter.get() + "</b><br>" : "") +
                getPixelGroupingString(supersampling_num) +



                "</html>");

        if(createFullImageAfterPreview) {
            String newValue =  progress.getToolTipText();
            newValue = newValue.replace("<html>", "");
            newValue = newValue.replace("</html>", "");
            progress.setToolTipText("<html><center><b><u>" + FIRST_PASS_STRING_LABEL + "</u></b></center><br>" + oldValue + "<br><center><b><u>" + SECOND_PASS_STRING_LABEL + "</u></b></center><br>" + newValue + "</html>");
        }


    }

    public static final String FIRST_PASS_STRING_LABEL = "First Pass";
    public static final String SECOND_PASS_STRING_LABEL = "Second Pass";

    public static final String PERTURBATION_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>Perturbation Iterations Per Pixel: <b>";
    public static final String BLA_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>BLA Iterations Per Pixel: <b>";
    public static final String NORMAL_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>Normal Double Iterations Per Pixel: <b>";
    public static final String EXTENDED_RANGE_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>Extended Range Iterations Per Pixel: <b>";
    public static final String SCALED_DOUBLE_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>Scaled Double Iterations Per Pixel: <b>";
    public static final String SA_SKIPPED_ITERATIONS_STRING_LABEL = "<li>SA Skipped Iterations: <b>";
    public static final String NANOMB1_SKIPPED_ITERATIONS_PER_PIXEL_STRING_LABEL = "<li>Nanomb1 Skipped Iterations Per Pixel: <b>";
    public static int getExtraSamples(int aaSamplesIndex, int aaMethod) {
        int supersampling_num;
        if(aaSamplesIndex == 0) {
            supersampling_num = 4;
        }
        else if(aaSamplesIndex < 4) {
            supersampling_num = 8 * aaSamplesIndex;
        }
        else if(aaSamplesIndex == 4) {
            supersampling_num = Location.MAX_AA_SAMPLES_48;
        }
        else if(aaSamplesIndex == 5) {
            supersampling_num = Location.MAX_AA_SAMPLES_80;
        }
        else if(aaSamplesIndex == 6) {
            supersampling_num = Location.MAX_AA_SAMPLES_120;
        }
        else if(aaSamplesIndex == 7) {
            supersampling_num = Location.MAX_AA_SAMPLES_168;
        }
        else if(aaSamplesIndex == 8) {
            supersampling_num = Location.MAX_AA_SAMPLES_224;
        }
        else {
            supersampling_num = Location.MAX_AA_SAMPLES_288;
        }
        return aaMethod == 5 ? Math.min(supersampling_num, Location.MAX_AA_SAMPLES_24) : supersampling_num;
    }

    public void setSmallToolTipMessage(int total, boolean juliaMap, boolean afterAA) {

        long time =  ptr != null ? ptr.getCalculationTime() : ptrExpander.getCalculationTime();

        int threads;
        if(action == JULIA_MAP || action == JULIA_MAP_POLAR) {
            threads = ptr != null ? ptr.getJuliaMapSlices() : 0;
        }
        else {
            threads = ptr != null ? ptr.getNumberOfThreads() : ptrExpander.getNumberOfThreads();
        }

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num;

        if(!filters[MainWindow.ANTIALIASING]) {
            supersampling_num = 1;
        }
        else {
            supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod) + 1;
        }

        long total_time = System.currentTimeMillis() - time;

        long pixel_time = max_pixel_calculation_time.get();

        long total_pp = total_post_processed.sum();

        progress.setToolTipText("<html><li>Total Elapsed Time: <b>" + total_time + " ms</b><br>" +
                getPixelStringSmall(juliaMap, afterAA, total, total_pp, supersampling_num) +
                "<li>Logical Processors: <b>" + Runtime.getRuntime().availableProcessors() + "</b><br>" +
                "<li>Threads Used: <b>" + threads + "</b><br>" +
                (juliaMap ? "<li>Using <b>Double Precision</b><br>" : "" )+
                (pixel_time != Long.MIN_VALUE ? PIXEL_CALCULATION_ELAPSED_TIME_STRING_LABEL + pixel_time  + " ms</b><br>" : "") +
                (total_pp > 0 && PostProcessingCalculationTime.get() != Long.MIN_VALUE ? POST_PROCESSING_ELAPSED_TIME_STRING_LABEL + PostProcessingCalculationTime.get() + " ms</b><br>" : "") +
                (FilterCalculationTime > 0 ? IMAGE_FILTERS_TIME_STRING_LABEL + FilterCalculationTime + " ms</b><br>" : "" )+
                (d3 && D3RenderingCalculationTime > 0 ? D3_RENDER_TIME_STRING_LABEL + D3RenderingCalculationTime + " ms</b><br>" : "") +
                "</html>");


    }

    public static final String IMAGE_SIZE_LABEL = "<li>Image Size: <b>";

    public static final String PIXELS_CALCULATED_COUNT_LABEL = "<li>Pixels Calculated: <b>";
    public static final String EXTRA_PIXELS_CALCULATED_COUNT_LABEL = "<li>Extra Pixels Calculated: <b>";
    public static final String PIXELS_POST_PROCESSED_COUNT_LABEL = "<li>Pixels Post Processed: <b>";
    public static final String PIXELS_COMPLETED_COUNT_LABEL = "<li>Pixels Completed: <b>";
    public static final String PIXELS_GUESSED_COUNT_LABEL = "<li>Pixels Guessed: <b>";

    public static final String D3_RENDER_TIME_STRING_LABEL = "<li>3D Rendering Elapsed Time:  <b>";
    public static final String IMAGE_FILTERS_TIME_STRING_LABEL = "<li>Image Filters Elapsed Time: <b>";
    public static final String PIXEL_CALCULATION_ELAPSED_TIME_STRING_LABEL = "<li>Pixel Calculation Elapsed Time: <b>";
    public static final String POST_PROCESSING_ELAPSED_TIME_STRING_LABEL = "<li>Post Processing Elapsed Time: <b>";
    public static final String REFERENCE_CALCULATION_ELAPSED_TIME_STRING_LABEL = "<li>Reference Calculation Elapsed Time: <b>";
    public static final String JULIA_EXTRA_REFERENCE_CALCULATION_ELAPSED_TIME_STRING_LABEL = "<li>Julia Extra Reference Calculation Elapsed Time: <b>";
    public static final String SA_CALCULATION_ELAPSED_TIME_LABEL = "<li>SA Calculation Elapsed Time: <b>";
    public static final String NANOMB1_CALCULATION_ELAPSED_TIME_LABEL = "<li>Nanomb1 Calculation Elapsed Time: <b>";
    public static final String BLA_CALCULATION_ELAPSED_TIME_LABEL = "<li>BLA Calculation Elapsed Time: <b>";

    private void domainPolarExpanderRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            renderDomainAntialiased(image_width, image_height, true);
        } else {
            renderDomain(image_width, image_height, true);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptrExpander.getNumberOfThreads()) {
            image_iterations = null;
            escaped = null;

            applyFilters();

            progress.setValue(progress.getMaximum());

            ptrExpander.writeImageToDisk();

            ptrExpander.setOptions(true);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    private void polarExpanderRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            try {
                renderAntialiased(image_width, image_height, true);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        } else {
            try {
                render(image_width, image_height, true);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        for(int i = 0; i < task_pixel_grouping.length; i++) {
            if(task_pixel_grouping[i] != 0) {
                total_pixel_grouping[i].add(task_pixel_grouping[i]);
            }
        }

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptrExpander.getNumberOfThreads()) {
            image_iterations = null;
            escaped = null;

            applyFilters();

            progress.setValue(progress.getMaximum());

            ptrExpander.writeImageToDisk();

            ptrExpander.setOptions(true);

            setFullToolTipMessage(image_width * image_height);

        }
    }

    private void expanderRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            try {
                renderAntialiased(image_width, image_height, false);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        } else {
            try {
                render(image_width, image_height, false);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        for(int i = 0; i < task_pixel_grouping.length; i++) {
            if(task_pixel_grouping[i] != 0) {
                total_pixel_grouping[i].add(task_pixel_grouping[i]);
            }
        }

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptrExpander.getNumberOfThreads()) {
            image_iterations = null;
            escaped = null;

            applyFilters();

            progress.setValue(progress.getMaximum());

            ptrExpander.writeImageToDisk();

            ptrExpander.setOptions(true);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    public static void updateMode(MainWindow ptr, boolean d3, boolean julia, boolean julia_map, boolean domain_coloring) {
        if(domain_coloring) {
            if (d3) {
                ptr.updateValues("3D mode");
            } else {
                ptr.updateValues("Domain C. mode");
            }
        }
        else if(julia_map) {
            ptr.updateValues("Julia Map mode");
        }
        else {
            if (d3) {
                ptr.updateValues("3D mode");
            } else if (julia) {
                ptr.updateValues("Julia mode");
            } else {
                ptr.updateValues("Normal mode");
            }
        }
    }

    private void rendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (d3) {
            if (filters[MainWindow.ANTIALIASING]) {
                render3DAntialiased(image_width, image_height, false);
            } else {
                render3D(image_width, image_height, false);
            }
        } else if (filters[MainWindow.ANTIALIASING]) {
            try {
                renderAntialiased(image_width, image_height, false);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        } else {
            try {
                render(image_width, image_height, false);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        for(int i = 0; i < task_pixel_grouping.length; i++) {
            if(task_pixel_grouping[i] != 0) {
                total_pixel_grouping[i].add(task_pixel_grouping[i]);
            }
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            BoundaryTracingRender.examined = null;
            SuccessiveRefinementGuessingRender.examined = null;
            applyFilters();

            updateMode(ptr, d3, iteration_algorithm.isJulia(), false, false);

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();

            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    private void quickRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        quickRender(image_width, image_height,false);

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            updateMode(ptr, false, iteration_algorithm.isJulia(), false, false);

            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            if(!createPreview && !QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                ptr.getMainPanel().repaint();
            }

            setFullToolTipMessage(image_width * image_height);

            ptr.setProgressBarVisibility(false);

            ptr.createCompleteImage(createPreview ? 0 : QUICK_RENDER_DELAY, false, createPreview, zoomToCursor);
        }
    }

    private void quickPolarRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        quickRender(image_width, image_height, true);

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            updateMode(ptr, false, iteration_algorithm.isJulia(), false, false);

            ptr.setWholeImageDone(true);
            ptr.reloadTitle();

            if(!createPreview && !QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                ptr.getMainPanel().repaint();
            }

            setFullToolTipMessage(image_width * image_height);

            ptr.setProgressBarVisibility(false);

            ptr.createCompleteImage(createPreview ? 0 : QUICK_RENDER_DELAY, false, createPreview, zoomToCursor);
        }
    }

    private void domainRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (d3) {
            if (filters[MainWindow.ANTIALIASING]) {
                renderDomain3DAntialiased(image_width, image_height, false);
            } else {
                renderDomain3D(image_width, image_height, false);
            }
        } else if (filters[MainWindow.ANTIALIASING]) {
            renderDomainAntialiased(image_width, image_height, false);
        } else {
            renderDomain(image_width, image_height, false);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);
        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            updateMode(ptr, d3, false, false, true);

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    private void quickDomainRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        quickRenderDomain(image_width, image_height, false);

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);
        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            updateMode(ptr, false, false, false, true);

            ptr.setWholeImageDone(true);
            ptr.reloadTitle();

            if(!createPreview && !QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                ptr.getMainPanel().repaint();
            }

            setFullToolTipMessage(image_width * image_height);

            ptr.setProgressBarVisibility(false);

            ptr.createCompleteImage(createPreview ? 0 : QUICK_RENDER_DELAY, false, createPreview, zoomToCursor);
        }
    }

    private void quickDomainPolarRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        quickRenderDomain(image_width, image_height, true);

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);
        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            updateMode(ptr, false, false, false, true);

            ptr.setWholeImageDone(true);
            ptr.reloadTitle();

            if(!createPreview && !QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                ptr.getMainPanel().repaint();
            }

            setFullToolTipMessage(image_width * image_height);

            ptr.setProgressBarVisibility(false);

            ptr.createCompleteImage(createPreview ? 0 : QUICK_RENDER_DELAY, false, createPreview, zoomToCursor);
        }
    }

    private void polarRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (d3) {
            if (filters[MainWindow.ANTIALIASING]) {
                render3DAntialiased(image_width, image_height, true);
            } else {
                render3D(image_width, image_height, true);
            }
        } else if (filters[MainWindow.ANTIALIASING]) {
            try {
                renderAntialiased(image_width, image_height, true);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        } else {
            try {
                render(image_width, image_height, true);
            }
            catch (StopSuccessiveRefinementException ex) {
                return;
            }
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        for(int i = 0; i < task_pixel_grouping.length; i++) {
            if(task_pixel_grouping[i] != 0) {
                total_pixel_grouping[i].add(task_pixel_grouping[i]);
            }
        }

        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            BoundaryTracingRender.examined = null;
            SuccessiveRefinementGuessingRender.examined = null;
            applyFilters();

            updateMode(ptr, d3, iteration_algorithm.isJulia(), false, false);

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    private void domainPolarRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (d3) {
            if (filters[MainWindow.ANTIALIASING]) {
                renderDomain3DAntialiased(image_width, image_height, true);
            } else {
                renderDomain3D(image_width, image_height, true);
            }
        } else if (filters[MainWindow.ANTIALIASING]) {
            renderDomainAntialiased(image_width, image_height, true);
        } else {
            renderDomain(image_width, image_height, true);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        total_calculated.add(task_calculated);
        total_calculated_extra.add(task_calculated_extra);
        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);
        if(task_completed >= 0) {
            total_completed.add(task_completed);
        }
        else {
            total_completed.add(task_calculated);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            updateMode(ptr, d3, false, false, true);

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);

            setFullToolTipMessage(image_width * image_height);
        }
    }

    protected abstract void render(int image_with, int image_height, boolean polar) throws StopSuccessiveRefinementException;

    protected int getFinalColor(double result, boolean escaped) {

        int color;

        if (USE_DIRECT_COLOR) {
            return 0xFF000000 | (0x00FFFFFF & (int) result);
        }
        else if (fractal != null && fractal.hasTrueColor()) {
            fractal.resetTrueColor();
            color = fractal.getTrueColorValue();

            if (pbs.palette_gradient_merge) {
                color = result < 0 ? getPaletteMergedColor(result * pbs.gradient_intensity - 2 * color_cycling_location_outcoloring, color) : getPaletteMergedColor(result * pbs.gradient_intensity + 2 * color_cycling_location_outcoloring, color);
            }
        }
        else if(sts.statistic) {
            if (sts.statisticGroup == 2 && sts.equicontinuityOverrideColoring &&
                    !((!sts.statisticIncludeNotEscaped && (!escaped || isMaximumIterations(result)))
                            || (!sts.statisticIncludeEscaped && escaped && !isMaximumIterations(result)))) {
                color = getEquicontinuityColor(result, escaped);
            }
            else if ((sts.statisticGroup == 3 || sts.normalMapCombineWithOtherStatistics) &&
                    !((!sts.statisticIncludeNotEscaped && (!escaped || isMaximumIterations(result)))
                            || (!sts.statisticIncludeEscaped && escaped && !isMaximumIterations(result)))) {
                color = getNormalMapColor(result, escaped);
            }
            else if (sts.statisticGroup == 4 &&
                    !((!sts.statisticIncludeNotEscaped && (!escaped || isMaximumIterations(result)))
                            || (!sts.statisticIncludeEscaped && escaped && !isMaximumIterations(result)))) {
                color = getRootColor(result, escaped);
            }
            else {
                color = getStandardColor(result, escaped);
            }
        }
        else {
            color = getStandardColor(result, escaped);
        }

        if (ots.useTraps && !((!ots.trapIncludeNotEscaped && (!escaped || isMaximumIterations(result)))
                || (!ots.trapIncludeEscaped && escaped && !isMaximumIterations(result)))) {
            return getTrapColor(color);
        }

        return color;

    }

    private boolean isMaximumIterations(double result) {
        result = Math.abs(result);
        return result == ColorAlgorithm.MAXIMUM_ITERATIONS || result == ColorAlgorithm.MAXIMUM_ITERATIONS_DE;
    }

    private int getEquicontinuityColor(double result, boolean escaped) {
        GenericStatistic statistic = fractal.getStatisticInstance();

        if(statistic == null) {
            return getStandardColor(result, escaped);
        }

        double L = escaped ? statistic.getValueForColoring() : statistic.getValueNotEscapedForColoring();

        double argValue = 0;
        if(sts.equicontinuityArgValue == 0) {
            argValue = statistic.getZ().arg();
        }
        else if(sts.equicontinuityArgValue == 1) {
            argValue = statistic.getStart().arg();
        }
        else if(sts.equicontinuityArgValue == 2) {
            argValue = statistic.getPixel().arg();
        }
        else if(sts.equicontinuityArgValue == 3) {
            argValue = statistic.getC().arg();
        }

        double arg = (Math.PI + argValue) / (Math.PI * 2);

        int[] rgb;

        if(sts.equicontinuityColorMethod == 0) {
            rgb = ColorSpaceConverter.HSLtoRGB(arg, sts.equicontinuitySatChroma, L);
        }
        else if(sts.equicontinuityColorMethod == 1) {
            rgb = ColorSpaceConverter.HSBtoRGB(arg, sts.equicontinuitySatChroma, L);
        }
        else if(sts.equicontinuityColorMethod == 2) {
            rgb = ColorSpaceConverter.LCH_abtoRGB(L * 100, sts.equicontinuitySatChroma * 140, arg * 360);
        }
        else {

            int color2 = 0;

            if(sts.equicontinuityColorMethod == 3) {
                color2 = getStandardColor(arg * getPaletteLength(escaped), escaped);
            }
            else {
                color2 = getStandardColor(result, escaped);
            }

            int red = (color2 >> 16) & 0xFF;
            int green = (color2 >> 8) & 0xFF;
            int blue = color2 & 0xFF;

            return getModifiedColor(red, green, blue, L, sts.equicontinuityMixingMethod, sts.equicontinuityBlending, false);
        }

        return 0xFF000000 | rgb[0] << 16 | rgb[1] << 8 | rgb[2];
    }

    private int getNormalMapColor(double result, boolean escaped) {
        GenericStatistic statistic = fractal.getStatisticInstance();

        if(statistic == null) {
            return getStandardColor(result, escaped);
        }

        int color = getStandardColor(result, escaped);

        if(sts.normalMapOverrideColoring && sts.normalMapColoring ==  1 && !isMaximumIterations(result)) {
            color = getStandardColor(statistic.getExtraValue() * getPaletteLength(escaped), escaped);
        }

        int output_color = 0;
        if(!sts.useNormalMap || !sts.normalMapOverrideColoring) {
            output_color =  color;
        }
        else {

            int r = (color >> 16) & 0xFF;
            int g = (color >> 8) & 0xFF;
            int b = color & 0xFF;

            double L = statistic.getValueForColoring() * 2;

            double coef = L;
            coef = coef > 1 ? 1 : coef;

            double coef2 = L - 1;
            coef2 = coef2 < 0 ? 0 : coef2;
            coef2 = coef2 * sts.normalMapLightFactor;

            if (sts.normalMapColorMode == 0) { //Lab
                double[] res = ColorSpaceConverter.RGBtoLAB(r, g, b);
                int[] rgb = ColorSpaceConverter.LABtoRGB(res[0] * coef + coef2 * 100, res[1], res[2]);
                output_color = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (sts.normalMapColorMode == 1) { //HSB
                double[] res = ColorSpaceConverter.RGBtoHSB(r, g, b);

                double val = res[2] * coef + coef2;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
                output_color = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (sts.normalMapColorMode == 2) { //HSL
                double[] res = ColorSpaceConverter.RGBtoHSL(r, g, b);

                double val = res[2] * coef + coef2;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
                output_color = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (sts.normalMapColorMode == 3) { //Blending
                if (coef > 1) {
                    coef = 1;
                }
                if (coef < 0) {
                    coef = 0;
                }

                int index = (int) ((1 - coef) * (gradient.length - 1) + 0.5);
                index = gradient.length - 1 - index;

                int grad_color = getGradientColor(index + gradient_offset);

                int temp_red = (grad_color >> 16) & 0xff;
                int temp_green = (grad_color >> 8) & 0xff;
                int temp_blue = grad_color & 0xff;

                int new_color = blending.blend(temp_red, temp_green, temp_blue, r, g, b, 1 - sts.normalMapBlending);

                r = (new_color >> 16) & 0xFF;
                g = (new_color >> 8) & 0xFF;
                b = new_color & 0xFF;

                double temp = coef2 * 255;
                r = (int) (r + temp + 0.5);
                g = (int) (g + temp + 0.5);
                b = (int) (b + temp + 0.5);

                if (r > 255) {
                    r = 255;
                }
                if (g > 255) {
                    g = 255;
                }
                if (b > 255) {
                    b = 255;
                }

                if (r < 0) {
                    r = 0;
                }
                if (g < 0) {
                    g = 0;
                }
                if (b < 0) {
                    b = 0;
                }

                output_color = 0xff000000 | (r << 16) | (g << 8) | b;
            } else if (sts.normalMapColorMode == 4) { //scaling

                double temp = coef2 * 255;
                r = (int) (r * coef + temp + 0.5);
                g = (int) (g * coef + temp + 0.5);
                b = (int) (b * coef + temp + 0.5);

                if (r > 255) {
                    r = 255;
                }
                if (g > 255) {
                    g = 255;
                }
                if (b > 255) {
                    b = 255;
                }

                if (r < 0) {
                    r = 0;
                }
                if (g < 0) {
                    g = 0;
                }
                if (b < 0) {
                    b = 0;
                }

                output_color = 0xff000000 | (r << 16) | (g << 8) | b;
            }
            else {
                double[] res = ColorSpaceConverter.RGBtoOKLAB(r, g, b);
                int[] rgb = ColorSpaceConverter.OKLABtoRGB(res[0] * coef + coef2, res[1], res[2]);
                output_color = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            }
        }

        if(sts.normalMapUseDE && sts.normalMapDEAAEffect) {

            NormalMap nm;
            if(statistic instanceof  NormalMap) {
                nm = (NormalMap) statistic;
            }
            else {
                nm = ((CombinedStatisticWithNormalMap)statistic).getNm();
            }

            int r1 = (output_color >> 16) & 0xFF;
            int g1 = (output_color >> 8) & 0xFF;
            int b1 = output_color & 0xFF;

            int r2, g2, b2;
            if(sts.normalMapDEUseColorPerDepth) {
                double depth_offset = nm.getSizeOffset();
                int color_per_depth = getStandardColor(depth_offset * sts.normalMapDEOffsetFactor + sts.normalMapDEOffset, escaped);
                r2 = (color_per_depth >> 16) & 0xFF;
                g2 = (color_per_depth >> 8) & 0xFF;
                b2 = color_per_depth & 0xFF;
            }
            else {
                r2 = (dem_color >> 16) & 0xFF;
                g2 = (dem_color >> 8) & 0xFF;
                b2 = dem_color & 0xFF;
            }

            output_color = method.interpolate(r1, g1, b1, r2, g2, b2, 1 - nm.getDeCoefficient());
        }

        return output_color;
    }

    private int getRootColor(double result, boolean escaped) {
        GenericStatistic statistic = fractal.getStatisticInstance();

        if(statistic == null) {
            return getStandardColor(result, escaped);
        }

        int color = ((RootColoring)statistic).getRootColor();

        if(color == 0) {
            return fractal_color;
        }

        if(!sts.rootShading) {
            return 0xFF000000 | color;
        }

        double factor = 1 - ((RootColoring) statistic).getDepthFactor();

        if(sts.rootShadingFunction != 5) {
            switch (sts.rootShadingFunction) {
                case 1:
                    factor = SqrtInterpolation.getCoefficient(factor);
                    break;
                case 2:
                    factor = CbrtInterpolation.getCoefficient(factor);
                    break;
                case 3:
                    factor = CosineInterpolation.getCoefficient(factor);
                    break;
                case 4:
                    factor = Exponential2Interpolation.getCoefficient(factor);
                    break;
                case 6:
                    factor = AccelerationInterpolation.getCoefficient(factor);
                    break;
                case 7:
                    factor = SineInterpolation.getCoefficient(factor);
                    break;
                case 8:
                    factor = DecelerationInterpolation.getCoefficient(factor);
                    break;
                case 9:
                    factor = ThirdPolynomialInterpolation.getCoefficient(factor);
                    break;
                case 10:
                    factor = FifthPolynomialInterpolation.getCoefficient(factor);
                    break;
                case 11:
                    factor = FrthrootInterpolation.getCoefficient(factor);
                    break;
                case 12:
                    factor = SmoothTransitionFunctionInterpolation.getCoefficient(factor);
                    break;
                case 13:
                    factor = QuarterSinInterpolation.getCoefficient(factor);
                    break;
            }

            if (sts.revertRootShading) {
                factor = 1 - factor;
            }

            int r = (color >> 16) & 0xFF;
            int g = (color >> 8) & 0xFF;
            int b = color & 0xFF;

            color = getModifiedColor(r, g, b, factor, sts.rootContourColorMethod, 1 - sts.rootBlending, false);
        }

        if(!sts.highlightRoots) {
            return 0xFF000000 | color;
        }

        double highlightFactor = ((RootColoring)statistic).getHighlightFactor();

        if(highlightFactor != 0) {

            int temp_red2 = (color >> 16) & 0xff;
            int temp_green2 = (color >> 8) & 0xff;
            int temp_blue2 = color & 0xff;

            int temp_red1 = !sts.revertRootShading ? sts.rootShadingColor.getRed() : 255 - sts.rootShadingColor.getRed();
            int temp_green1 = !sts.revertRootShading ? sts.rootShadingColor.getGreen()  : 255 - sts.rootShadingColor.getGreen();
            int temp_blue1 = !sts.revertRootShading ? sts.rootShadingColor.getBlue()  : 255 - sts.rootShadingColor.getBlue();

            return method.interpolate(temp_red1, temp_green1, temp_blue1, temp_red2, temp_green2, temp_blue2, highlightFactor);

        }

        return 0xFF000000 | color;

    }

    private int getOutPaletteColor(double transfered_result) {

        if(!gps.useGeneratedPaletteOutColoring) {
            return transfered_result < 0 ? palette_outcoloring.getPaletteColor(transfered_result - color_cycling_location_outcoloring) : palette_outcoloring.getPaletteColor(transfered_result + color_cycling_location_outcoloring);
        }
        else {
            return palette_outcoloring.calculateColor(transfered_result, gps.generatedPaletteOutColoringId, color_cycling_location_outcoloring, gps.restartGeneratedOutColoringPaletteAt, gps.outColoringIQ);
        }
    }

    private int getInPaletteColor(double transfered_result) {


        if(!gps.useGeneratedPaletteInColoring) {
            return transfered_result < 0 ? palette_incoloring.getPaletteColor(transfered_result - color_cycling_location_incoloring) : palette_incoloring.getPaletteColor(transfered_result + color_cycling_location_incoloring);
        }
        else {
            return palette_incoloring.calculateColor(transfered_result, gps.generatedPaletteInColoringId, color_cycling_location_incoloring, gps.restartGeneratedInColoringPaletteAt, gps.inColoringIQ);
        }

    }

    protected int getStandardColor(double result, boolean escaped) {

        if (USE_DIRECT_COLOR) {
            return 0xFF000000 | (0x00FFFFFF & (int) result);
        }

        int colorA = 0;

        double temp_res = Math.abs(result);
        if (temp_res == ColorAlgorithm.MAXIMUM_ITERATIONS) {
            colorA = fractal_color;
        } else if (temp_res == ColorAlgorithm.MAXIMUM_ITERATIONS_DE) {
            colorA = dem_color;
        } else if (!escaped && usePaletteForInColoring) {
            double transfered_result = color_transfer_incoloring.transfer(result);
            colorA = getInPaletteColor(transfered_result);
            if (pbs.palette_gradient_merge) {
                colorA = result < 0 ? getPaletteMergedColor(result * pbs.gradient_intensity - 2 * color_cycling_location_outcoloring, colorA) : getPaletteMergedColor(result * pbs.gradient_intensity + 2 * color_cycling_location_outcoloring, colorA);
            }
        } else {
            double transfered_result = color_transfer_outcoloring.transfer(result);
            colorA = getOutPaletteColor(transfered_result);
            if (pbs.palette_gradient_merge) {
                colorA = result < 0 ? getPaletteMergedColor(result * pbs.gradient_intensity - 2 * color_cycling_location_outcoloring, colorA) : getPaletteMergedColor(result * pbs.gradient_intensity + 2 * color_cycling_location_outcoloring, colorA);
            }
        }

        return colorA;

    }

    private int getPaletteMergedColor(double result, int color) {

        double temp = (Math.abs(result) + pbs.gradient_offset) / gradient.length;

        int old_red = (color >> 16) & 0xFF;
        int old_green = (color >> 8) & 0xFF;
        int old_blue = color & 0xFF;

        if (temp > 1) {
            temp = (int) temp % 2 == 1 ? 1 - MathUtils.fract(temp) : MathUtils.fract(temp);
        }

        int index = (int) (temp * (gradient.length - 1) + 0.5);

        int grad_color = getGradientColor(index + gradient_offset);

        int temp_red = grad_color & 0xff;
        int temp_green = grad_color & 0xff;
        int temp_blue = grad_color & 0xff;

        if (pbs.merging_type == 0) { //Lab
            double[] grad = ColorSpaceConverter.RGBtoLAB(temp_red, temp_green, temp_blue);
            double[] res = ColorSpaceConverter.RGBtoLAB(old_red, old_green, old_blue);
            int[] rgb = ColorSpaceConverter.LABtoRGB(grad[0], res[1], res[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (pbs.merging_type == 1) { //HSB
            double[] grad = ColorSpaceConverter.RGBtoHSB(temp_red, temp_green, temp_blue);
            double[] res = ColorSpaceConverter.RGBtoHSB(old_red, old_green, old_blue);
            int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], grad[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (pbs.merging_type == 2) { //HSL
            double[] grad = ColorSpaceConverter.RGBtoHSL(temp_red, temp_green, temp_blue);
            double[] res = ColorSpaceConverter.RGBtoHSL(old_red, old_green, old_blue);
            int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], grad[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (pbs.merging_type == 3) {// blend
            return blending.blend(temp_red, temp_green, temp_blue, old_red, old_green, old_blue, 1 - pbs.palette_blending);
        } else if (pbs.merging_type == 4) { //scale
            double avg = ((temp_red + temp_green + temp_blue) / 3.0) / 255.0;
            old_red = (int) (old_red * avg + 0.5);
            old_green = (int) (old_green * avg + 0.5);
            old_blue = (int) (old_blue * avg + 0.5);
            return 0xff000000 | (old_red << 16) | (old_green << 8) | old_blue;
        }
        else {
            double[] grad = ColorSpaceConverter.RGBtoOKLAB(temp_red, temp_green, temp_blue);
            double[] res = ColorSpaceConverter.RGBtoOKLAB(old_red, old_green, old_blue);
            int[] rgb = ColorSpaceConverter.OKLABtoRGB(grad[0], res[1], res[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        }

    }

    private int getTrapColor(int originalColor) {

        OrbitTrap trap = fractal.getOrbitTrapInstance();

        if (trap.hasColor()) {
            int color = trap.getColor();
            if (((color >> 24) & 0xFF) == 0) {
                if(ots.showOnlyTraps) {
                    originalColor = ots.background.getRGB();
                }
                return originalColor;
            }
            return color;
        }

        if(ots.showOnlyTraps) {
            originalColor = ots.background.getRGB();
        }

        double distance = trap.getDistance();

        if ((ots.trapMaxDistance != 0 && distance > ots.trapMaxDistance) || distance == Double.MAX_VALUE) {
            return originalColor;
        }

        double maxDistance = ots.trapMaxDistance != 0 ? ots.trapMaxDistance : trap.getMaxValue();
        double minDinstance = trap.getMinValue();
        distance = (distance - minDinstance ) / (maxDistance - minDinstance);

        int trapColor = getModifiedColor((originalColor >> 16) & 0xFF, (originalColor >> 8) & 0xFF, originalColor & 0xFF, distance, ots.trapColorMethod, 1 - ots.trapBlending, true);

        if (ots.trapColorInterpolation != 0) {

            int red = (trapColor >> 16) & 0xFF;
            int green = (trapColor >> 8) & 0xFF;
            int blue = trapColor & 0xFF;

            int trapRed;
            int trapGreen;
            int trapBlue;

            if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_RANDOM) {
                int color = algorithm_colors[trap.getIteration() % algorithm_colors.length];

                trapRed = (color >> 16) & 0xFF;
                trapGreen = (color >> 8) & 0xFF;
                trapBlue = color & 0xFF;
            } else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_RANDOM_HSB) {
                int color = algorithm_colors2[trap.getIteration() % algorithm_colors2.length];

                trapRed = (color >> 16) & 0xFF;
                trapGreen = (color >> 8) & 0xFF;
                trapBlue = color & 0xFF;
            } else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ARG_PALETTE) {
                double transfered_result = color_transfer_outcoloring.transfer((trap.getTrappedPoint().arg() + Math.PI) / (2 * Math.PI) * palette_outcoloring.getPaletteLength());
                int color = getOutPaletteColor(transfered_result);

                trapRed = (color >> 16) & 0xFF;
                trapGreen = (color >> 8) & 0xFF;
                trapBlue = color & 0xFF;
            } else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_RANDOM_PALETTE) {
                double transfered_result = color_transfer_outcoloring.transfer(trap.getIteration() * 1.61803398875 * Math.PI * Math.E);
                int color = getOutPaletteColor(transfered_result);

                trapRed = (color >> 16) & 0xFF;
                trapGreen = (color >> 8) & 0xFF;
                trapBlue = color & 0xFF;
            } else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ARG_HUE_HSB) {
                int color = Color.HSBtoRGB((float) ((trap.getTrappedPoint().arg() + Math.PI) / (2 * Math.PI)), HSB_CONSTANT_S, HSB_CONSTANT_B);

                trapRed = (color >> 16) & 0xFF;
                trapGreen = (color >> 8) & 0xFF;
                trapBlue = color & 0xFF;
            } else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ARG_HUE_LCH_ab) {
                int[] rgb = ColorSpaceConverter.LCH_abtoRGB(TaskRender.LCHab_CONSTANT_L, TaskRender.LCHab_CONSTANT_C, 360 * ((trap.getTrappedPoint().arg() + Math.PI) / (2 * Math.PI)));

                trapRed = rgb[0];
                trapGreen = rgb[1];
                trapBlue = rgb[2];
            }
            else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ITER_HSB) {
                int index = trap.getIteration() % 20;

                int[] rgb = ColorSpaceConverter.HSBtoRGB(index / 20.0, 1, 1);

                trapRed = rgb[0];
                trapGreen = rgb[1];
                trapBlue = rgb[2];
            }
            else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ITER_LCH_ab) {
                int index = trap.getIteration() % 20;

                int[] rgb = ColorSpaceConverter.LCH_abtoRGB(TaskRender.LCHab_CONSTANT_L, TaskRender.LCHab_CONSTANT_C, 360 * (index / 20.0));

                trapRed = rgb[0];
                trapGreen = rgb[1];
                trapBlue = rgb[2];
            }
            else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ARG_HUE_LCH_uv) {
                int[] rgb = ColorSpaceConverter.LCH_uvtoRGB(TaskRender.LCHuv_CONSTANT_L, TaskRender.LCHuv_CONSTANT_C, 360 * ((trap.getTrappedPoint().arg() + Math.PI) / (2 * Math.PI)));

                trapRed = rgb[0];
                trapGreen = rgb[1];
                trapBlue = rgb[2];
            }
            else if (ots.trapColorFillingMethod == MainWindow.TRAP_COLOR_ITER_LCH_uv) {
                int index = trap.getIteration() % 20;

                int[] rgb = ColorSpaceConverter.LCH_uvtoRGB(TaskRender.LCHuv_CONSTANT_L, TaskRender.LCHuv_CONSTANT_C, 360 * (index / 20.0));

                trapRed = rgb[0];
                trapGreen = rgb[1];
                trapBlue = rgb[2];
            }
            else {
                trapRed = ots.trapColor1.getRed();
                trapGreen = ots.trapColor1.getGreen();
                trapBlue = ots.trapColor1.getBlue();

                if (trap.getTrapId() == 1) {
                    trapRed = ots.trapColor2.getRed();
                    trapGreen = ots.trapColor2.getGreen();
                    trapBlue = ots.trapColor2.getBlue();
                } else if (trap.getTrapId() == 2) {
                    trapRed = ots.trapColor3.getRed();
                    trapGreen = ots.trapColor3.getGreen();
                    trapBlue = ots.trapColor3.getBlue();
                }
            }

            trapColor = method.interpolate(red, green, blue, trapRed, trapGreen, trapBlue, ots.trapColorInterpolation);

        }

        if (ots.trapCellularStructure) {

            double limit = 1 - ots.trapCellularSize;
            double coef = 0;

            if (distance >= limit) {
                coef = (distance - limit) / (1 - limit);
            }

            /*double invert_limit = 1 - limit;

            if (distance <= invert_limit) {
                coef = distance / limit;
            }*/
            int trapRed = (trapColor >> 16) & 0xFF;
            int trapGreen = (trapColor >> 8) & 0xFF;
            int trapBlue = trapColor & 0xFF;

            if (ots.trapCellularInverseColor) {
                coef = 1 - coef;
            }

            trapColor = method.interpolate(ots.trapCellularColor.getRed(), ots.trapCellularColor.getGreen(), ots.trapCellularColor.getBlue(), trapRed, trapGreen, trapBlue, 1 - coef);
        }

        return trapColor;
    }

    protected void quickRenderDomain(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, image_width, image_height, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);

        int tempx, tempy;

        int color, loc2, loc, x, y;

        int current_chunk_size = tile;
        int min_chuck_size = tile;
        if(QUICKRENDER_SUCCESSIVE_REFINEMENT) {
            current_chunk_size = SUCCESSIVE_REFINEMENT_MAX_SIZE;
            min_chuck_size = prevPowerOf2(tile);
        }

        long nano_time = 0;

        for(int id = 0; current_chunk_size >= min_chuck_size; current_chunk_size >>= 1, id++) {
            long time = System.nanoTime();
            AtomicInteger ai = quick_render_rendering_algorithm_pixel[id];

            int image_width_tile = image_width % current_chunk_size  == 0 ? image_width / current_chunk_size : image_width / current_chunk_size + 1;
            int image_height_tile = image_height % current_chunk_size  == 0 ? image_height / current_chunk_size : image_height / current_chunk_size + 1;
            int condition = (image_width_tile) * (image_height_tile);
            int chunk_size = THREAD_CHUNK_SIZE_PER_LEVEL[id];

            do {

                loc = chunk_size * ai.getAndIncrement();

                if (loc >= condition) {
                    break;
                }

                for (int count = 0; count < chunk_size && loc < condition; count++, loc++) {
                    tempx = loc % image_width_tile;
                    tempy = loc / image_width_tile;

                    x = tempx * current_chunk_size;
                    y = tempy * current_chunk_size;

                    loc2 = y * image_width + x;

                    if(rgbs[loc2] >>> 24 != Constants.QUICKRENDER_CALCULATED_ALPHA) {

                        Complex val = iteration_algorithm.calculateDomain(location.getComplex(x, y));
                        image_iterations[loc2] = scaleDomainHeight(getDomainHeight(val));
                        color = domain_color.getDomainColor(val);
                        rgbs[loc2] = (color & 0xFFFFFF) | Constants.QUICKRENDER_CALCULATED_ALPHA_OFFSETED;

                        if (domain_image_data_re != null && domain_image_data_im != null) {
                            domain_image_data_re[loc2] = val.getRe();
                            domain_image_data_im[loc2] = val.getIm();
                        }

                        task_calculated++;

                        tempx = Math.min(image_width, x + current_chunk_size);
                        tempy = Math.min(image_height, y + current_chunk_size);

                        for (int i = y; i < tempy; i++) {
                            for (int j = x, loc3 = i * image_width + j; j < tempx; j++, loc3++) {
                                if (loc3 != loc2) {
                                    rgbs[loc3] = color;
                                }
                            }
                        }
                    }
                }

            } while (true);

            nano_time += System.nanoTime() - time;

            if(QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                try {
                    quick_render_rendering_algorithm_barrier.await();
                } catch (InterruptedException ex) {

                } catch (BrokenBarrierException ex) {

                }
                if(taskId == 0) {
                    ptr.setWholeImageDone(true);
                    if(id == 0) {
                        ptr.reloadTitle();
                    }
                    ptr.getMainPanel().repaint();
                }
            }
        }

        pixel_calculation_time_per_task = nano_time / 1000000;

    }

    protected int prevPowerOf2 (int x)
    {
        x = x | (x >>> 1);
        x = x | (x >>> 2);
        x = x | (x >>> 4);
        x = x | (x >>> 8);
        x = x | (x >>> 16);
        return x - (x >>> 1);
    }

    protected void initialize(Location location) {
        if(PERTURBATION_THEORY && fractal.supportsPerturbationTheory() && !HIGH_PRECISION_CALCULATION) {
            if (reference_calc_sync.getAndIncrement() == 0) {
                calculateReference(location);
            }

            try {
                reference_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }
            location.setReference(Fractal.refPoint);
        }
        else if(HIGH_PRECISION_CALCULATION && fractal.supportsPerturbationTheory()) {
            if (reference_calc_sync.getAndIncrement() == 0) {
                initializeHighPrecision();
            }

            try {
                reference_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }
        }
    }

    protected void quickRender(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, image_width, image_height, circle_period, rotation_center, rotation_vals, fractal, js, polar, (PERTURBATION_THEORY || HIGH_PRECISION_CALCULATION) && fractal.supportsPerturbationTheory());

        initialize(location);

        int color, loc2, loc, x, y;
        int tempx, tempy;

        boolean escaped_val;
        double f_val;


        int current_chunk_size = tile;
        int min_chuck_size = tile;
        if(QUICKRENDER_SUCCESSIVE_REFINEMENT) {
            current_chunk_size = SUCCESSIVE_REFINEMENT_MAX_SIZE;
            min_chuck_size = prevPowerOf2(tile);
        }

        long nano_time = 0;


        for(int id = 0; current_chunk_size >= min_chuck_size; current_chunk_size >>= 1, id++) {
            long time = System.nanoTime();
            AtomicInteger ai = quick_render_rendering_algorithm_pixel[id];

            int image_width_tile = image_width % current_chunk_size  == 0 ? image_width / current_chunk_size : image_width / current_chunk_size + 1;
            int image_height_tile = image_height % current_chunk_size  == 0 ? image_height / current_chunk_size : image_height / current_chunk_size + 1;
            int condition = (image_width_tile) * (image_height_tile);
            int chunk_size = THREAD_CHUNK_SIZE_PER_LEVEL[id];

            do {

                loc = chunk_size * ai.getAndIncrement();

                if (loc >= condition) {
                    break;
                }

                for (int count = 0; count < chunk_size && loc < condition; count++, loc++) {
                    tempx = loc % image_width_tile;
                    tempy = loc / image_width_tile;

                    x = tempx * current_chunk_size;
                    y = tempy * current_chunk_size;

                    loc2 = y * image_width + x;

                    if(rgbs[loc2] >>> 24 != Constants.QUICKRENDER_CALCULATED_ALPHA) {
                        image_iterations[loc2] = f_val = iteration_algorithm.calculate(location.getComplex(x, y));
                        escaped[loc2] = escaped_val = iteration_algorithm.escaped();
                        color = getFinalColor(f_val, escaped_val);

                        rgbs[loc2] = (color & 0xFFFFFF) | Constants.QUICKRENDER_CALCULATED_ALPHA_OFFSETED;

                        task_calculated++;

                        tempx = Math.min(image_width, x + current_chunk_size);
                        tempy = Math.min(image_height, y + current_chunk_size);

                        for (int i = y; i < tempy; i++) {
                            for (int j = x, loc3 = i * image_width + j; j < tempx; j++, loc3++) {
                                if (loc3 != loc2) {
                                    rgbs[loc3] = color;
                                }
                            }
                        }
                    }
                }

            } while (true);

            nano_time += System.nanoTime() - time;

            if(QUICKRENDER_SUCCESSIVE_REFINEMENT) {
                try {
                    quick_render_rendering_algorithm_barrier.await();
                } catch (InterruptedException ex) {

                } catch (BrokenBarrierException ex) {

                }

                if(taskId == 0) {
                    ptr.setWholeImageDone(true);
                    if(id == 0) {
                        ptr.reloadTitle();
                    }
                    ptr.getMainPanel().repaint();
                }
            }
        }

        pixel_calculation_time_per_task = nano_time / 1000000;

    }

    protected void renderDomain(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, image_width, image_height, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);

        int pixel_percent = (image_width * image_height) / 100;

        int x, y, loc;

        long time = System.currentTimeMillis();

        for(y = FROMy; y < TOy; y++) {
            location.precalculateY(y);
            for(x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {

                if(rgbs[loc] >>> 24 != Constants.NORMAL_ALPHA) {
                    Complex val = iteration_algorithm.calculateDomain(location.getComplex(x, y));
                    image_iterations[loc] = scaleDomainHeight(getDomainHeight(val));
                    rgbs[loc] = domain_color.getDomainColor(val);

                    if (domain_image_data_re != null && domain_image_data_im != null) {
                        domain_image_data_re[loc] = val.getRe();
                        domain_image_data_im[loc] = val.getIm();
                    }
                    task_calculated++;
                }

                rendering_done++;

            }

            if(rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(image_width, image_height, null, location);
        } catch (StopSuccessiveRefinementException ex) {}

    }

    protected void renderDomainAntialiased(int image_width, int image_height, boolean polar) {

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        boolean useJitter = aaMethod != 6 && ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x4) == 4;
        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, image_width, image_height, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        location.createAntialiasingSteps(aaMethod == 5, useJitter, supersampling_num);

        int pixel_percent = (image_width * image_height) / 100;

        int x, y, loc;
        int color;

        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int totalSamples = supersampling_num + 1;

        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(totalSamples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        aa.setNeedsPostProcessing(needsPostProcessing());

        boolean storeExtraData = pixelData != null;

        double f_val;

        long time = System.currentTimeMillis();

        for(y = FROMy; y < TOy; y++) {
            location.precalculateY(y);
            for(x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {

                Complex val = iteration_algorithm.calculateDomain(location.getComplex(x, y));
                image_iterations[loc] = f_val = scaleDomainHeight(getDomainHeight(val));
                color = domain_color.getDomainColor(val);

                if(storeExtraData) {
                    pixelData[loc].set(0, color, f_val, true, totalSamples);
                }

                if (domain_image_data_re != null && domain_image_data_im != null) {
                    domain_image_data_re[loc] = val.getRe();
                    domain_image_data_im[loc] = val.getIm();
                }

                aa.initialize(color);

                //Supersampling
                for (int i = 0; i < supersampling_num; i++) {
                    val = iteration_algorithm.calculateDomain(location.getAntialiasingComplex(i, loc));
                    color = domain_color.getDomainColor(val);

                    if(storeExtraData) {
                        f_val = scaleDomainHeight(getDomainHeight(val));
                        pixelData[loc].set(i + 1, color, f_val, true, totalSamples);
                    }

                    if(!aa.addSample(color)) {
                        break;
                    }
                }

                rgbs[loc] = aa.getColor();

                rendering_done++;
                task_calculated++;
            }

            if(rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(image_width, image_height, aa, location);
        } catch (StopSuccessiveRefinementException ex) {}

    }

    private void calculate3D(int image_width, int image_height, boolean update_progress, int tile_size) {

        long time = System.currentTimeMillis();

        int x, y;

        int n1 = detail - 1;

        int image_size = Math.min(image_width, image_height);
        double w2 = image_size * 0.5;
        int w2x = (int)(image_width * 0.5);
        int w2y = (int)(image_height * 0.5);
        double d = image_size / (detail / (double)tile_size);


        double ct = Math.cos(fiX), cf = Math.cos(fiY), st = Math.sin(fiX), sf = Math.sin(fiY);
        double m00 = scale * cf, m02 = scale * sf, m10 = scale * st * sf, m11 = scale * ct, m12 = -scale * st * cf;
        m20 = -ct * sf;
        m21 = st;
        m22 = ct * cf;

        double mod;
        double norm_0_0, norm_0_1, norm_0_2, norm_1_0, norm_1_1, norm_1_2;

        int pixel_percent = detail * detail / 100;

        for (int x1 = FROMx; x1 < TOx; x1++) {
            x = x1 * tile_size;
            int xp1 = (x1 + 1) * tile_size;
            double c1 = d * x1 - w2;
            for (int y1 = FROMy; y1 < TOy; y1++) {
                y = y1 * tile_size;
                if (y < n1 && x < n1) {
                    int yp1 = (y1 + 1) * tile_size;
                    if(xp1 < detail && yp1 < detail) {
                        norm_0_0 = vert[x][y] - vert[xp1][y];
                        norm_0_1 = d;
                        norm_0_2 = vert[xp1][y] - vert[xp1][yp1];
                        mod = Math.sqrt(norm_0_0 * norm_0_0 + norm_0_1 * norm_0_1 + norm_0_2 * norm_0_2);
                        norm_0_0 /= mod;
                        norm_0_1 /= mod;
                        norm_0_2 /= mod;

                        norm_1_0 = vert[x][yp1] - vert[xp1][yp1];
                        norm_1_1 = d;
                        norm_1_2 = vert[x][y] - vert[x][yp1];
                        mod = Math.sqrt(norm_1_0 * norm_1_0 + norm_1_1 * norm_1_1 + norm_1_2 * norm_1_2);
                        norm_1_0 /= mod;
                        norm_1_1 /= mod;
                        norm_1_2 /= mod;

                        Norm1z[x][y][0] = (float) (m20 * norm_0_0 + m21 * norm_0_1 + m22 * norm_0_2);
                        Norm1z[x][y][1] = (float) (m20 * norm_1_0 + m21 * norm_1_1 + m22 * norm_1_2);
                    }
                }

                double c2 = d * y1 - w2;
                vert1[x][y][0] = (float) (m00 * c1 + m02 * c2);
                vert1[x][y][1] = (float) (m10 * c1 + m11 * vert[x][y] + m12 * c2);

                if (update_progress) {
                    rendering_done++;
                }
            }

            if (update_progress && (rendering_done / pixel_percent >= 1)) {
                update(rendering_done);
                rendering_done = 0;
            }
        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        if (painting_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            paint3D(w2x, w2y, update_progress, tile_size);

        }

    }

    private void render3D(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, detail, detail, circle_period, rotation_center, rotation_vals, fractal, js, polar, (PERTURBATION_THEORY || HIGH_PRECISION_CALCULATION) && fractal.supportsPerturbationTheory());

        initialize(location);

        int pixel_percent = detail * detail / 100;

        double[] temp;

        int image_size = Math.min(image_width, image_height);
        int w2x = (int)(image_width * 0.5);
        int w2y = (int)(image_height * 0.5);
        double w2 = image_size * 0.5;

        double d = image_size / (double) detail;

        int x, y, loc;

        int thread_chunk_size = getThreadChunkSize(detail, CHUNK_SIZE_PER_ROW);

        int condition = detail * detail;

        boolean escaped_val;
        double f_val;

        long time = System.currentTimeMillis();

        do {

            loc = thread_chunk_size * normal_rendering_algorithm_pixel.getAndIncrement();

            if (loc >= condition) {
                break;
            }

            for (int count = 0; count < thread_chunk_size && loc < condition; count++, loc++) {
                x = loc % detail;
                y = loc / detail;

                temp = iteration_algorithm.calculate3D(location.getComplex(x, y));
                image_iterations[loc] = f_val = temp[1];
                vert[x][y] = fractional_transfer_3d(temp[0]);
                escaped[loc] = escaped_val = iteration_algorithm.escaped();
                vert_color[x][y] = getFinalColor(f_val, escaped_val);

                rendering_done++;
                task_calculated++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        } while (true);

        heightProcessing();

        calculate3DVectors(d, w2);

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(detail, detail, null, location);
        }
        catch (StopSuccessiveRefinementException ex) {}

        if (painting_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            paint3D(w2x, w2y, true, 1);

        }

    }

    private void renderDomain3D(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, detail, detail, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);

        int pixel_percent = detail * detail / 100;

        int image_size = Math.min(image_width, image_height);
        int w2x = (int)(image_width * 0.5);
        int w2y = (int)(image_height * 0.5);
        double w2 = image_size * 0.5;

        double d = image_size / (double) detail;

        int x, y, loc;

        int condition = detail * detail;

        int thread_chunk_size = getThreadChunkSize(detail, CHUNK_SIZE_PER_ROW);

        long time = System.currentTimeMillis();

        do {

            loc = thread_chunk_size * normal_rendering_algorithm_pixel.getAndIncrement();

            if (loc >= condition) {
                break;
            }

            for (int count = 0; count < thread_chunk_size && loc < condition; count++, loc++) {
                x = loc % detail;
                y = loc / detail;

                Complex a = iteration_algorithm.calculateDomain(location.getComplex(x, y));
                double height = getDomainHeight(a);

                vert[x][y] = fractional_transfer_3d(calaculateDomainColoringHeight(height));
                vert_color[x][y] = domain_color.getDomainColor(a);
                image_iterations[loc] = scaleDomainHeight(height);

                rendering_done++;
                task_calculated++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        } while (true);

        heightProcessing();

        calculate3DVectors(d, w2);

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(detail, detail, null, location);
        }catch (StopSuccessiveRefinementException ex) {}

        if (painting_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            paint3D((int)w2x, (int)w2y, true, 1);

        }

    }

    private void render3DAntialiased(int image_width, int image_height, boolean polar) {

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        boolean useJitter = aaMethod != 6 && ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x4) == 4;
        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, detail, detail, circle_period, rotation_center, rotation_vals, fractal, js, polar, (PERTURBATION_THEORY || HIGH_PRECISION_CALCULATION) && fractal.supportsPerturbationTheory());
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        location.createAntialiasingSteps(aaMethod == 5, useJitter, supersampling_num);

        initialize(location);

        int pixel_percent = detail * detail / 100;

        double[] temp;

        int image_size = Math.min(image_width, image_height);
        int w2x = (int)(image_width * 0.5);
        int w2y = (int)(image_height * 0.5);
        double w2 = image_size * 0.5;

        double d = image_size / (double) detail;

        int x, y, loc;

        int condition = detail * detail;
        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int temp_samples = supersampling_num + 1;

        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(temp_samples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        aa.setNeedsPostProcessing(needsPostProcessing());

        int color;

        double height;

        boolean escaped_val;
        double f_val;
        boolean storeExtraData = pixelData != null;

        int thread_chunk_size = getThreadChunkSize(detail, CHUNK_SIZE_PER_ROW);

        long time = System.currentTimeMillis();

        do {

            loc = thread_chunk_size * normal_rendering_algorithm_pixel.getAndIncrement();

            if (loc >= condition) {
                break;
            }

            for (int count = 0; count < thread_chunk_size && loc < condition; count++, loc++) {
                x = loc % detail;
                y = loc / detail;

                temp = iteration_algorithm.calculate3D(location.getComplex(x, y));
                image_iterations[loc] = f_val = temp[1];
                height = temp[0];
                escaped[loc] = escaped_val = iteration_algorithm.escaped();
                color = getFinalColor(f_val, escaped_val);

                if(storeExtraData) {
                    pixelData[loc].set(0, color, f_val, escaped_val, temp_samples);
                }

                aa.initialize(color);

                //Supersampling
                for (int k = 0; k < supersampling_num; k++) {
                    temp = iteration_algorithm.calculate3D(location.getAntialiasingComplex(k, loc));
                    escaped_val = iteration_algorithm.escaped();
                    color = getFinalColor(temp[1], escaped_val);

                    if(storeExtraData) {
                        pixelData[loc].set(k + 1, color, temp[1], escaped_val, temp_samples);
                    }

                    height += temp[0];

                    if(!aa.addSample(color)) {
                        break;
                    }
                }

                vert[x][y] = fractional_transfer_3d((height / temp_samples));
                vert_color[x][y] = aa.getColor();

                rendering_done++;
                task_calculated++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        } while (true);

        heightProcessing();

        calculate3DVectors(d, w2);

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(detail, detail, aa, location);
        }catch (StopSuccessiveRefinementException ex) {}

        if (painting_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            paint3D(w2x, w2y, true, 1);

        }

    }

    private void renderDomain3DAntialiased(int image_width, int image_height, boolean polar) {

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        boolean useJitter = aaMethod != 6 && ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x4) == 4;
        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, detail, detail, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        location.createAntialiasingSteps(aaMethod == 5, useJitter, supersampling_num);

        int pixel_percent = detail * detail / 100;

        int image_size = Math.min(image_width, image_height);
        int w2x = (int)(image_width * 0.5);
        int w2y = (int)(image_height * 0.5);
        double w2 = image_size * 0.5;

        double d = image_size / (double) detail;

        int x, y, loc;

        int condition = detail * detail;


        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int temp_samples = supersampling_num + 1;

        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(temp_samples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        aa.setNeedsPostProcessing(needsPostProcessing());

        int color;

        double height;

        double f_val;

        boolean storeExtraData = pixelData != null;

        int thread_chunk_size = getThreadChunkSize(detail, CHUNK_SIZE_PER_ROW);

        long time = System.currentTimeMillis();

        do {

            loc = thread_chunk_size * normal_rendering_algorithm_pixel.getAndIncrement();

            if (loc >= condition) {
                break;
            }

            for (int count = 0; count < thread_chunk_size && loc < condition; count++, loc++) {
                x = loc % detail;
                y = loc / detail;

                Complex a = iteration_algorithm.calculateDomain(location.getComplex(x, y));
                double heightVal = getDomainHeight(a);
                image_iterations[loc] = f_val = scaleDomainHeight(heightVal);

                height = calaculateDomainColoringHeight(heightVal);
                color = domain_color.getDomainColor(a);

                if(storeExtraData) {
                    pixelData[loc].set(0, color, f_val, true, temp_samples);
                }

                aa.initialize(color);

                //Supersampling
                for (int k = 0; k < supersampling_num; k++) {
                    a = iteration_algorithm.calculateDomain(location.getAntialiasingComplex(k, loc));

                    color = domain_color.getDomainColor(a);
                    heightVal = getDomainHeight(a);
                    height += calaculateDomainColoringHeight(heightVal);

                    if(storeExtraData) {
                        f_val = scaleDomainHeight(heightVal);
                        pixelData[loc].set(k + 1, color, f_val, true, temp_samples);
                    }

                    if(!aa.addSample(color)) {
                        break;
                    }
                }

                vert[x][y] = fractional_transfer_3d((height / temp_samples));
                vert_color[x][y] = aa.getColor();

                rendering_done++;
                task_calculated++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        } while (true);

        heightProcessing();

        calculate3DVectors(d, w2);

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(detail, detail, aa, location);
        }catch (StopSuccessiveRefinementException ex) {}

        if (painting_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            paint3D(w2x, w2y, true, 1);

        }

    }

    protected abstract void renderAntialiased(int image_width, int image_height, boolean polar) throws StopSuccessiveRefinementException;

    private void fastJuliaRendering() {

        int image_size = image.getWidth();

        if (fast_julia_filters && filters[MainWindow.ANTIALIASING]) {
            renderFastJuliaAntialiased(image_size, false);
        } else {
            renderFastJulia(image_size, false);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            if (fast_julia_filters) {
                applyFiltersNoProgress();
            }

            Graphics2D graphics = image.createGraphics();
            graphics.setColor(Color.BLACK);
            graphics.drawRect(0, 0, image_size - 1, image_size - 1);
            ptr.getMainPanel().getGraphics().drawImage(image, ptr.getScrollPane().getHorizontalScrollBar().getValue(), ptr.getScrollPane().getVerticalScrollBar().getValue(), null);

        }

    }

    private void fastJuliaRenderingPolar() {

        int image_size = image.getWidth();

        if (fast_julia_filters && filters[MainWindow.ANTIALIASING]) {
            renderFastJuliaAntialiased(image_size, true);
        } else {
            renderFastJulia(image_size, true);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            if (fast_julia_filters) {
                applyFilters();
            }

            Graphics2D graphics = image.createGraphics();
            graphics.setColor(Color.BLACK);
            graphics.drawRect(0, 0, image_size - 1, image_size - 1);
            ptr.getMainPanel().getGraphics().drawImage(image, ptr.getScrollPane().getHorizontalScrollBar().getValue(), ptr.getScrollPane().getVerticalScrollBar().getValue(), null);

        }

    }

    private int[] contourColoring(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, boolean[] escaped) {

        int loc = i * image_width + j;

        int[] output = new int[colors.length];

        for(int m = 0; m < output.length; m++) {

            double res;
            if(data != null && output.length > 1) {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(data[loc].values[m])) {
                    output[m] = getStandardColor(data[loc].values[m], data[loc].escaped[m]);
                    continue;
                }

                res = ColorAlgorithm.transformResultToHeight(data[loc].values[m], max_iterations);
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[loc])) {
                    output[m] = getStandardColor(image_iterations[loc], escaped[loc]);
                    continue;
                }

                res = ColorAlgorithm.transformResultToHeight(image_iterations[loc], max_iterations);
            }


            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            res = fractional_transfer(res, cns.fractionalTransfer, cns.fractionalSmoothing,  0 , 1);

            if (cns.contour_algorithm == 0) {
                res = MathUtils.fract(res);

                double min_contour = cns.min_contour;
                double max_contour = 1 - min_contour;

                if (res < min_contour || res > max_contour) {
                    double coef = 0;
                    if (res < min_contour) {
                        coef = (res / min_contour) / 2 + 0.5;
                    } else {
                        coef = ((res - max_contour) / min_contour) / 2;
                    }

                    int color1 = getModifiedColor(r, g, b, max_contour, cns.contourColorMethod, 1 - cns.cn_blending, false);
                    int color2 = getModifiedColor(r, g, b, min_contour, cns.contourColorMethod, 1 - cns.cn_blending, false);

                    int temp_red1 = (color1 >> 16) & 0xff;
                    int temp_green1 = (color1 >> 8) & 0xff;
                    int temp_blue1 = color1 & 0xff;

                    int temp_red2 = (color2 >> 16) & 0xff;
                    int temp_green2 = (color2 >> 8) & 0xff;
                    int temp_blue2 = color2 & 0xff;

                    output[m] = method.interpolate(temp_red1, temp_green1, temp_blue1, temp_red2, temp_green2, temp_blue2, coef);
                }
                else {

                    output[m] = getModifiedColor(r, g, b, res, cns.contourColorMethod, 1 - cns.cn_blending, false);
                }
            } else if (cns.contour_algorithm == 1) {

                res = 2.0 * MathUtils.fract(res);;

                res = res > 1 ? 2.0 - res : res;

                res = Math.abs(res);

                output[m] = getModifiedColor(r, g, b, res, cns.contourColorMethod, 1 - cns.cn_blending, false);
            } else {
                res = MathUtils.fract(res);

                double min_contour = cns.min_contour;
                double max_contour = 1 - min_contour;


                int color = colors[m];

                //Not Needed anymore
//                if (cns.contour_algorithm == 3) {
//                    if (data != null && output.length > 1) {
//                        color = getStandardColor((int) data[loc].values[m], data[loc].escaped[m]);
//                        r = (color >> 16) & 0xFF;
//                        g = (color >> 8) & 0xFF;
//                        b = color & 0xFF;
//                    } else {
//                        color = getStandardColor((int) image_iterations[loc], escaped[loc]);
//                        r = (color >> 16) & 0xFF;
//                        g = (color >> 8) & 0xFF;
//                        b = color & 0xFF;
//                    }
//                }

                if (res < min_contour || res > max_contour) {
                    double coef = 0;
                    if (res < min_contour) {
                        coef = (res / min_contour) / 2 + 0.5;
                    } else {
                        coef = ((res - max_contour) / min_contour) / 2;
                    }

                    coef = 2.0 * coef;

                    coef = 1 - (coef > 1 ? 2.0 - coef : coef);

                    int color1 = getModifiedColor(r, g, b, min_contour, cns.contourColorMethod, 1 - cns.cn_blending, false);

                    int temp_red1 = (color1 >> 16) & 0xff;
                    int temp_green1 = (color1 >> 8) & 0xff;
                    int temp_blue1 = color1 & 0xff;

                    output[m] = method.interpolate(temp_red1, temp_green1, temp_blue1, r, g, b, coef);
                }
                else {
                    output[m] = color;
                }
            }
        }
        return output;

    }

    private int[] offsetColoring(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, boolean[] escaped) {

        int loc = i * image_width + j;

        int[] output = new int[colors.length];

        for(int m = 0; m < output.length; m++) {

            int color2;
            if(data != null && output.length > 1) {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(data[loc].values[m])) {
                    output[m] = getStandardColor(data[loc].values[m], data[loc].escaped[m]);
                    continue;
                }

                double res = Math.abs(ColorAlgorithm.transformResultToHeight(data[loc].values[m], max_iterations));

                color2 = getStandardColor(res + ofs.post_process_offset, data[loc].escaped[m]);
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[loc])) {
                    output[m] = getStandardColor(image_iterations[loc], escaped[loc]);
                    continue;
                }

                double res = Math.abs(ColorAlgorithm.transformResultToHeight(image_iterations[loc], max_iterations));

                color2 = getStandardColor(res + ofs.post_process_offset, escaped[loc]);
            }


            double coef = 1 - ofs.of_blending;

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int fc_red = (color2 >> 16) & 0xFF;
            int fc_green = (color2 >> 8) & 0xFF;
            int fc_blue = color2 & 0xFF;

            output[m] = ofs_blending.blend(r, g, b, fc_red, fc_green, fc_blue, coef);
        }
        return output;
    }

    private int[] greyscaleColoring(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, boolean[] escaped) {

        int loc = i * image_width + j;

        int[] output = new int[colors.length];

        for(int m = 0; m < output.length; m++) {

            if(data != null && output.length > 1) {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(data[loc].values[m])) {
                    output[m] = getStandardColor(data[loc].values[m], data[loc].escaped[m]);
                    continue;
                }
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[loc])) {
                    output[m] = getStandardColor(image_iterations[loc], escaped[loc]);
                    continue;
                }
            }

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int greyscale = (int) ((r + g + b) / 3.0 + 0.5);

            output[m] = 0xff000000 | (greyscale << 16) | (greyscale << 8) | greyscale;
        }
        return output;

    }

    private double getCosAngleTimesSmoothGrad(double gradx, double grady, double dotp, double sizeCorr) {
        double gradAbs, cosAngle, smoothGrad;
        gradAbs = Math.sqrt(gradx * gradx + grady * grady);
        cosAngle = dotp / gradAbs;
        smoothGrad = -2.3562 / (gradAbs * sizeCorr + 1.5) + 1.57;
        //smoothGrad = Math.atan(gradAbs * sizeCorr);
        return smoothGrad * cosAngle;
    }

    private int[] bumpMapping(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, double lightx, double lighty, double sizeCorr, Location location, AntialiasingAlgorithm aa) {

        int index = i * image_width + j;

        double gradx, grady, dotp;

        int[] output = new int[colors.length];

        if(data != null && output.length > 1) {
            tempDataXp1 = null;
            tempDataYp1 = null;
            tempDataYm1 = null;
            tempDataXm1 = null;
        }

        for(int m = 0; m < output.length; m++) {

            if(data != null && output.length > 1) {
                double val = ColorAlgorithm.transformResultToHeight(data[index].values[m], max_iterations);
                val = fractional_transfer(val, bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
                gradx = getGradientX(val, data, i, j, index, m, image_width, image_height, location, aa);
                grady = getGradientY(val, data, i, j, index, m, image_width, image_height, location, aa);
            }
            else {
                double val = ColorAlgorithm.transformResultToHeight(image_iterations[index], max_iterations);
                val = fractional_transfer(val, bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
                gradx = getGradientX(val, image_iterations, i, j, index, image_width, image_height, location);
                grady = getGradientY(val, image_iterations, i, j, index, image_width, image_height, location);
            }

            dotp = gradx * lightx + grady * lighty;

            if (bms.bumpProcessing == 3 || bms.bumpProcessing == 4 || bms.bumpProcessing == 5 || bms.bumpProcessing == 6) {
                if (dotp != 0) {
                    output[m] = changeBrightnessOfColorLabHsbHsl(colors[m], getCosAngleTimesSmoothGrad(gradx, grady, dotp, sizeCorr));
                }
                else {
                    output[m] = colors[m];
                }
            } else if (bms.bumpProcessing == 0) {
                if (dotp != 0) {
                    output[m] = changeBrightnessOfColorScaling(colors[m], getCosAngleTimesSmoothGrad(gradx, grady, dotp, sizeCorr));
                }
                else {
                    output[m] = colors[m];
                }
            } else if (dotp != 0 || (dotp == 0 && !isInt(image_iterations[index]))) {
                output[m] = changeBrightnessOfColorBlending(colors[m], getCosAngleTimesSmoothGrad(gradx, grady, dotp, sizeCorr));
            }
            else {
                output[m] = colors[m];
            }
        }
        return output;


    }

    private int[] entropyColoring(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, boolean[] escaped, Location location, AntialiasingAlgorithm aa) {

        int loc = i * image_width + j;


        int[] output = new int[colors.length];

        for(int m = 0; m < output.length; m++) {

            if(data != null && output.length > 1) {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(data[loc].values[m])) {
                    output[m] = getStandardColor(data[loc].values[m], data[loc].escaped[m]);
                    continue;
                }
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[loc])) {
                    output[m] = getStandardColor(image_iterations[loc], escaped[loc]);
                    continue;
                }
            }

            int kernel_size = 3;
            int kernel_size2 = kernel_size / 2;

            double min_value = Double.MAX_VALUE;

            double[] values = new double[kernel_size * kernel_size];
            int length = 0;

            PixelExtraData[] tempData = null;

            if(data != null && output.length > 1) {
                tempData = new PixelExtraData[values.length];
            }

            int kernel_loc = 0;
            for (int k = i - kernel_size2, p = 0; p < kernel_size; k++, p++) {
                for (int l = j - kernel_size2, t = 0; t < kernel_size; l++, t++, kernel_loc++) {

                    if (location != null || (k >= 0 && k < image_height && l >= 0 && l < image_width)) {

                        double temp;

                        if(data != null && output.length > 1) {
                            if(tempData[kernel_loc] == null) {
                                tempData[kernel_loc] = getIterData(k, l, k * image_width + l, data, image_width, image_height, location, aa, false);
                            }
                            temp = Math.abs(ColorAlgorithm.transformResultToHeight(tempData[kernel_loc].values[m], max_iterations));
                        }
                        else {
                            temp = Math.abs(ColorAlgorithm.transformResultToHeight(getIterData(k, l, k * image_width + l, image_iterations, image_width, image_height, location, false), max_iterations));
                        }

                        values[p * kernel_size + t] = temp;

                        if (temp < min_value) {
                            min_value = temp;
                        }
                        length++;

                    }

                }
            }

            double sum = 0;
            for (int k = 0; k < length; k++) {
                values[k] -= min_value;
                sum += values[k];
            }

            double sum2 = 0;
            if (sum != 0) {
                for (int k = 0; k < length; k++) {
                    values[k] /= sum;

                    if (values[k] > 0) {
                        sum2 += values[k] * Math.log(values[k]);
                    }

                }
            }
            if (length != 0) {
                sum2 /= length;
            }
            sum2 *= 10;

            double coef = 1 - ens.en_blending;

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int temp_red = 0, temp_green = 0, temp_blue = 0;

            if (ens.entropy_algorithm == 0) {

                int color2;
                if(data != null && output.length > 1) {
                    double res = Math.abs(ColorAlgorithm.transformResultToHeight(data[loc].values[m], max_iterations));
                    color2 = getStandardColor(ens.entropy_offset + res + ens.entropy_palette_factor * Math.abs(sum2), data[loc].escaped[m]);
                }
                else {
                    double res = Math.abs(ColorAlgorithm.transformResultToHeight(image_iterations[loc], max_iterations));
                    color2 = getStandardColor(ens.entropy_offset + res + ens.entropy_palette_factor * Math.abs(sum2), escaped[loc]);
                }
                temp_red = (color2 >> 16) & 0xFF;
                temp_green = (color2 >> 8) & 0xFF;
                temp_blue = color2 & 0xFF;
            } else {
                double temp = Math.abs(sum2) * ens.entropy_palette_factor;

                if (temp > 1) {
                    temp = (int) temp % 2 == 1 ? 1 - MathUtils.fract(temp) : MathUtils.fract(temp);
                }

                int index = (int) (temp * (gradient.length - 1) + 0.5);
                index = gradient.length - 1 - index;

                int grad_color = getGradientColor(index + gradient_offset);

                temp_red = (grad_color >> 16) & 0xff;
                temp_green = (grad_color >> 8) & 0xff;
                temp_blue = grad_color & 0xff;
            }

            output[m] = ens_blending.blend(r, g, b, temp_red, temp_green, temp_blue, coef);
        }
        return output;
    }

    private int[] paletteRainbow(double[] image_iterations, PixelExtraData[] data, int i, int j, int image_width, int image_height, int[] colors, boolean[] escaped, Location location, AntialiasingAlgorithm aa) {

        int k0 = image_width * i + j;
        int kx = k0 + 1;
        int sx = 1;

        int kx2 = k0 - 1;
        int sx2 = -1;

        int ky = k0 + image_width;
        int sy = 1;

        int ky2 = k0 - image_width;
        int sy2 = -1;

        double zx = 0;
        double zy = 0;
        double zx2 = 0;
        double zy2 = 0;

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;
        PixelExtraData dataKx = null;
        PixelExtraData dataKy = null;
        PixelExtraData dataKx2 = null;
        PixelExtraData dataKy2 = null;

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            dataKx = getIterData(i, j + 1, kx, data, image_width, image_height, location, aa, false);
            dataKy = getIterData(i + 1, j, ky, data, image_width, image_height, location, aa, false);
            dataKx2 = getIterData(i, j - 1, kx2, data, image_width, image_height, location, aa, false);
            dataKy2 = getIterData(i - 1, j, ky2, data, image_width, image_height, location, aa, false);
        }

        for(int m = 0; m < output.length; m++) {

            double n0;

            if(data != null && output.length > 1) {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(dataK0.values[m])) {
                    output[m] = getStandardColor(dataK0.values[m], dataK0.escaped[m]);
                    continue;
                }

                n0 = ColorAlgorithm.transformResultToHeight(dataK0.values[m], max_iterations);

                if (location != null || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(dataKx.values[m], max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(dataKy.values[m], max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(dataKx2.values[m], max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(dataKy2.values[m], max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[k0])) {
                    output[m] = getStandardColor(image_iterations[k0], escaped[k0]);
                    continue;
                }

                n0 = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);

                if (location != null || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, kx, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, ky, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(getIterData(i, j - 1, kx2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j, ky2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }

            double zz = 1.0;

            double z = Math.sqrt(zx2 * zx2 + zy2 * zy2 + zx * zx + zy * zy + zz * zz);
            //zz /= z;
            zx /= z;
            zy /= z;

            double hue = Math.atan2(zy, zx) / Math.PI * 0.5;

            hue = hue < 0 ? hue + 1 : hue;

            double coef = 1 - rps.rp_blending;

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int temp_red = 0, temp_green = 0, temp_blue = 0;

            if (rps.rainbow_algorithm == 0) {

                int color2;

                if(data != null && output.length > 1) {
                    color2 = getStandardColor(rps.rainbow_offset + hue * getPaletteLength(data[k0].escaped[m]) * rps.rainbow_palette_factor, data[k0].escaped[m]);
                }
                else {
                    color2 = getStandardColor(rps.rainbow_offset + hue * getPaletteLength(escaped[k0]) * rps.rainbow_palette_factor, escaped[k0]);
                }

                temp_red = (color2 >> 16) & 0xFF;
                temp_green = (color2 >> 8) & 0xFF;
                temp_blue = color2 & 0xFF;
            } else {
                hue *= 2 * rps.rainbow_palette_factor;

                hue = hue % 2.0;

                int index = hue < 1 ? (int) (hue * (gradient.length - 1) + 0.5) : (int) ((1 - (hue - 1)) * (gradient.length - 1) + 0.5);
                index = gradient.length - 1 - index;

                int grad_color = getGradientColor(index + gradient_offset);

                temp_red = (grad_color >> 16) & 0xff;
                temp_green = (grad_color >> 8) & 0xff;
                temp_blue = grad_color & 0xff;
            }

            output[m] = rps_blending.blend(r, g, b, temp_red, temp_green, temp_blue, coef);
        }
        return output;

    }

    private int[] postProcessingSmoothing(int[] new_colors, double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, double factor, Location location, AntialiasingAlgorithm aa) {

        int k0 = image_width * i + j;
        int kx = k0 + 1;
        int sx = 1;

        int kx2 = k0 - 1;
        int sx2 = -1;

        int ky = k0 + image_width;
        int sy = 1;

        int ky2 = k0 - image_width;
        int sy2 = -1;

        double zx = 0;
        double zy = 0;
        double zx2 = 0;
        double zy2 = 0;

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;
        PixelExtraData dataKx = null;
        PixelExtraData dataKy = null;
        PixelExtraData dataKx2 = null;
        PixelExtraData dataKy2 = null;

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            dataKx = getIterData(i, j + 1, kx, data, image_width, image_height, location, aa, false);
            dataKy = getIterData(i + 1, j, ky, data, image_width, image_height, location, aa, false);
            dataKx2 = getIterData(i, j - 1, kx2, data, image_width, image_height, location, aa, false);
            dataKy2 = getIterData(i - 1, j, ky2, data, image_width, image_height, location, aa, false);
        }

        for(int m = 0; m < output.length; m++) {

            double n0;

            if(data != null && output.length > 1) {
                n0 = ColorAlgorithm.transformResultToHeight(dataK0.values[m], max_iterations);

                if (location != null || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(dataKx.values[m], max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(dataKy.values[m], max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(dataKx2.values[m], max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(dataKy2.values[m], max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }
            else {
                n0 = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);

                if (location != null || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, kx, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, ky, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(getIterData(i, j - 1, kx2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j, ky2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }

            double zz = 1 / factor;

            double z = Math.sqrt(zx2 * zx2 + zy2 * zy2 + zx * zx + zy * zy + zz * zz);

            zz /= z;

            double coef = zz;
            coef = 1 - coef;

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int fc_red = (new_colors[m] >> 16) & 0xFF;
            int fc_green = (new_colors[m] >> 8) & 0xFF;
            int fc_blue = new_colors[m] & 0xFF;

            output[m] = method.interpolate(fc_red, fc_green, fc_blue, r, g, b, coef);
        }
        return output;

    }

    public static double fade(int fadeAlgorith, double t) {
        switch (fadeAlgorith) {
            case 1:
                return SqrtInterpolation.getCoefficient(t);
            case 2:
                return CbrtInterpolation.getCoefficient(t);
            case 3:
                return FrthrootInterpolation.getCoefficient(t);
            case 4:
                return CosineInterpolation.getCoefficient(t);
            case 5:
                return AccelerationInterpolation.getCoefficient(t);
            case 6:
                return SineInterpolation.getCoefficient(t);
            case 7:
                return DecelerationInterpolation.getCoefficient(t);
            case 8:
                return ThirdPolynomialInterpolation.getCoefficient(t);
            case 9:
                return FifthPolynomialInterpolation.getCoefficient(t);
            case 10:
                return Exponential2Interpolation.getCoefficient(t);
            case 11:
                return SmoothTransitionFunctionInterpolation.getCoefficient(t);
            case 12:
                return QuarterSinInterpolation.getCoefficient(t);
            default:
                return t;
        }
    }

    private int[] pseudoDistanceEstimation(double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, Location location, AntialiasingAlgorithm aa) {

        int k0 = image_width * i + j;
        int kx = k0 + 1;
        int sx = 1;

        int kx2 = k0 - 1;
        int sx2 = -1;

        int ky = k0 + image_width;
        int sy = 1;

        int ky2 = k0 - image_width;
        int sy2 = -1;

        double zx = 0;
        double zy = 0;
        double zx2 = 0;
        double zy2 = 0;

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;
        PixelExtraData dataKx = null;
        PixelExtraData dataKy = null;
        PixelExtraData dataKx2 = null;
        PixelExtraData dataKy2 = null;

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            dataKx = getIterData(i, j + 1, kx, data, image_width, image_height, location, aa, false);
            dataKy = getIterData(i + 1, j, ky, data, image_width, image_height, location, aa, false);
            dataKx2 = getIterData(i, j - 1, kx2, data, image_width, image_height, location, aa, false);
            dataKy2 = getIterData(i - 1, j, ky2, data, image_width, image_height, location, aa, false);
        }

        for(int m = 0; m < output.length; m++) {

            double n0;

            if(data != null && output.length > 1) {
                n0 = ColorAlgorithm.transformResultToHeight(dataK0.values[m], max_iterations);

                if (location != null || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(dataKx.values[m], max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null  || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(dataKy.values[m], max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null  || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(dataKx2.values[m], max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null  || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(dataKy2.values[m], max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }
            else {
                n0 = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);

                if (location != null  || j < image_width - 1) {
                    double nx = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, kx, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx = sx * (nx - n0);
                }

                if (location != null  || i < image_height - 1) {
                    double ny = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, ky, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy = sy * (ny - n0);
                }

                if (location != null  || j > 0) {
                    double nx2 = ColorAlgorithm.transformResultToHeight(getIterData(i, j - 1, kx2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zx2 = sx2 * (nx2 - n0);
                }

                if (location != null  || i > 0) {
                    double ny2 = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j, ky2, image_iterations, image_width, image_height, location, false), max_iterations);
                    zy2 = sy2 * (ny2 - n0);
                }
            }

            double zz = 1 / fdes.fake_de_factor;

            double z = Math.sqrt(zx2 * zx2 + zy2 * zy2 + zx * zx + zy * zy + zz * zz);

            zz /= z;

            double coef = fade(fdes.fade_algorithm, zz);

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            int fc_red = (dem_color >> 16) & 0xFF;
            int fc_green = (dem_color >> 8) & 0xFF;
            int fc_blue = dem_color & 0xFF;

            if (fdes.inverse_fake_dem) {
                coef = 1 - coef;
            }

            output[m] = method.interpolate(fc_red, fc_green, fc_blue, r, g, b, coef);
        }
        return output;

    }

    protected void applyPostProcessingOnPixel(int index, int x, int y, int image_width, int image_height, double[] image_iterations, boolean[] escaped, PixelExtraData[] pixelData, AntialiasingAlgorithm aa, int[] modified, double sizeCorr, double lightx, double lighty, Location location) {

        if(aa != null && pixelData != null) {
            modified = pixelData[index].rgb_values;
        }
        else if (d3) {
            modified[0] = vert_color[x][y];
        } else {
            modified[0] = rgbs[index];
        }

        for (int i = 0; i < post_processing_order.length; i++) {
            switch (post_processing_order[i]) {

                case MainWindow.HISTOGRAM_COLORING:
                    if(hss.histogramColoring && !domain_coloring) {
                        int[] original_color = modified;
                        modified = finalizeHistogramColoring(image_iterations, pixelData, original_color, y, x, image_width, image_height, escaped);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, hss.hs_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.LIGHT:
                    if (ls.lighting) {
                        int[] original_color = modified;
                        modified = light(image_iterations, pixelData, original_color, y, x, image_width, image_height, location, aa);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, ls.l_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.NUMERICAL_DISTANCE_ESTIMATOR:
                    if (ndes.useNumericalDem && !domain_coloring) {
                        int[] original_color = modified;
                        modified = numerical_distance_estimator(image_iterations, pixelData, original_color, y, x, image_width, image_height, location, aa, escaped);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, ndes.n_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.SLOPES:
                    if (ss.slopes) {
                        int[] original_color = modified;
                        modified = slopes(image_iterations, pixelData, original_color, y, x, image_width, image_height, location, aa);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, ss.s_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.OFFSET_COLORING:
                    if (ofs.offset_coloring && !domain_coloring) {
                        int[] original_color = modified;
                        modified = offsetColoring(image_iterations, pixelData, y, x, image_width, image_height, original_color, escaped);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, ofs.of_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.ENTROPY_COLORING:
                    if (ens.entropy_coloring && !domain_coloring) {
                        int[] original_color = modified;
                        modified = entropyColoring(image_iterations, pixelData, y, x, image_width, image_height, original_color, escaped, location, aa);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, ens.en_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.RAINBOW_PALETTE:
                    if (rps.rainbow_palette && !domain_coloring) {
                        int[] original_color = modified;
                        modified = paletteRainbow(image_iterations, pixelData, y, x, image_width, image_height, original_color, escaped, location, aa);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, rps.rp_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.CONTOUR_COLORING:
                    if (cns.contour_coloring && !domain_coloring) {
                        int[] original_color = modified;
                        modified = contourColoring(image_iterations, pixelData, y, x, image_width, image_height, original_color, escaped);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, cns.cn_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.GREYSCALE_COLORING:
                    if (gss.greyscale_coloring && !domain_coloring) {
                        int[] original_color = modified;
                        modified = greyscaleColoring(image_iterations, pixelData, y, x, image_width, image_height, original_color, escaped);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, gss.gs_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.BUMP_MAPPING:
                    if (bms.bump_map) {
                        int[] original_color = modified;
                        modified = bumpMapping(image_iterations, pixelData, y, x, image_width, image_height, modified, lightx, lighty, sizeCorr, location, aa);
                        modified = postProcessingSmoothing(modified, image_iterations, pixelData, original_color, y, x, image_width, image_height, bms.bm_noise_reducing_factor, location, aa);
                    }
                    break;
                case MainWindow.FAKE_DISTANCE_ESTIMATION:
                    if (fdes.fake_de && !domain_coloring) {
                        modified = pseudoDistanceEstimation(image_iterations, pixelData, modified, y, x, image_width, image_height, location, aa);
                    }
                    break;
            }
        }


        if(aa != null && pixelData != null) {

            aa.initialize(modified[0]);

            for(int i = 1; i < modified.length; i++) {
                if(!aa.addSample(modified[i])) {
                    break;
                }
            }

            if (d3) {
                vert_color[x][y] = aa.getColor();
            } else {
                rgbs[index] = aa.getColor();
            }
        }
        else if (d3) {
            vert_color[x][y] = modified[0];
        } else {
            rgbs[index] = modified[0];
        }

        if(task_post_processed >= 0) {
            task_post_processed++;
        }
    }

    protected void applyPostProcessingPointFilter(int image_width, int image_height, double[] image_iterations, boolean[] escaped, PixelExtraData[] pixelData, AntialiasingAlgorithm aa, Location location) {
        double sizeCorr = 0, lightx = 0, lighty = 0;

        if (bms.bump_map) {
            double gradCorr = Math.pow(2, (bms.bumpMappingStrength - DEFAULT_BUMP_MAPPING_STRENGTH) * 0.05);
            sizeCorr = Math.min(image_width, image_height) / Math.pow(2, (MAX_BUMP_MAPPING_DEPTH - bms.bumpMappingDepth) * 0.16);
            double lightAngleRadians = Math.toRadians(bms.lightDirectionDegrees);
            lightx = Math.cos(lightAngleRadians) * gradCorr;
            lighty = Math.sin(lightAngleRadians) * gradCorr;
        }


        int[] modified = new int[1];

        if(aa != null) {
            modified = new int[aa.getTotalSamples()];
            aa.setNeedsPostProcessing(false);
        }

        for (int y = FROMy; y < TOy; y++) {
            for (int x = FROMx; x < TOx; x++) {
                int index = y * image_width + x;
                applyPostProcessingOnPixel(index, x, y, image_width, image_height, image_iterations, escaped, pixelData, aa, modified, sizeCorr, lightx, lighty, location);
            }
        }
    }

    protected void applyPostProcessing(int image_width, int image_height, double[] image_iterations, boolean[] escaped, PixelExtraData[] pixelData, AntialiasingAlgorithm aa, Location location) {

        if (hss.histogramColoring && !domain_coloring) {
            if(aa != null && pixelData != null) {
                initializeHistogramColoring(pixelData);
            }else {
                initializeHistogramColoring(image_iterations, escaped);
            }
        }

        applyPostProcessingPointFilter(image_width, image_height, image_iterations, escaped, pixelData, aa, location);

    }

    private boolean isInt(double val) {

        return MathUtils.fract(val) == 0;

    }

    protected abstract void renderFastJulia(int image_size, boolean polar);

    protected abstract void renderFastJuliaAntialiased(int image_size, boolean polar);

    private void colorCycling() {

        int outPaletteLength = CommonFunctions.getOutPaletteLength(domain_coloring, domain_color != null ? domain_color.getColoringMode() : -1);
        int inPaletteLength = CommonFunctions.getInPaletteLength(domain_coloring);

        do {
            try {
                color_cycling_toggle_lock.lockRead();
            } catch (InterruptedException e) {
            }


            try {
                color_cycling_restart_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            boolean cached_color_cycling = color_cycling;

            color_cycling_toggle_lock.unlockRead();

            if (!cached_color_cycling) {
                return;
            }

            ptr.setWholeImageDone(false);

            int image_width = image.getWidth();
            int image_height = image.getHeight();

            if (ccs.gradient_cycling_adjusting_value != 0) {
                gradient_offset = CommonFunctions.adjustPaletteOffset(gradient_offset, ccs.gradient_cycling_adjusting_value, Constants.GRADIENT_LENGTH);
            }

            if (ccs.color_cycling_adjusting_value != 0) {
                color_cycling_location_outcoloring = CommonFunctions.adjustPaletteOffset(color_cycling_location_outcoloring, ccs.color_cycling_adjusting_value, outPaletteLength);
                color_cycling_location_incoloring = CommonFunctions.adjustPaletteOffset(color_cycling_location_incoloring, ccs.color_cycling_adjusting_value, inPaletteLength);
            }

            if (ccs.bump_cycling_adjusting_value != 0 && bms.bump_map) {
                CommonFunctions.adjustBumpOffset(bms, ccs.bump_cycling_adjusting_value);
            }

            if (ccs.light_cycling_adjusting_value != 0 && ls.lighting) {
                CommonFunctions.adjustLightOffset(ls, ccs.light_cycling_adjusting_value);
            }

            if(ccs.slope_cycling_adjusting_value != 0 && ss.slopes) {
                CommonFunctions.adjustSlopeOffset(ss, ccs.slope_cycling_adjusting_value);
            }

            for (int y = FROMy; y < TOy; y++) {
                for (int x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {
                    if (domain_coloring) {
                        domain_color.setColorCyclingLocation(color_cycling_location_outcoloring);
                        domain_color.setGradientOffset(gradient_offset);
                        rgbs[loc] = domain_color.getDomainColor(new Complex(domain_image_data_re[loc], domain_image_data_im[loc]));
                    } else {
                        rgbs[loc] = getStandardColor(image_iterations[loc], escaped[loc]);
                    }
                }
            }

            postProcessColorCycling(image_width, image_height);

            try {
                if (color_cycling_filters_sync.await() == 0) {
                    applyFiltersNoProgress();

                    ptr.setWholeImageDone(true);

                    ptr.getMainPanel().repaint();

                    if (ccs.color_cycling_adjusting_value != 0) {
                        ptr.updatePalettePreview(color_cycling_location_outcoloring, color_cycling_location_incoloring);
                    }

                    if (ccs.gradient_cycling_adjusting_value != 0) {
                        ptr.updateGradientPreview(gradient_offset);
                    }
                    //progress.setForeground(new Color(palette.getPaletteColor(color_cycling_location)));
                }
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            try {
                Thread.sleep(ccs.color_cycling_speed + 35);
            } catch (InterruptedException ex) {
            }

        } while (true);

    }

    private void rotate3DModel() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        int tile_size = detail <= 60 ? 1 : TILE_SIZE;

        calculate3D(image_width, image_height, false, tile_size);

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFiltersNoProgress();

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(detail * detail, false, false);

            if(tile_size > 1) {
                ptr.createCompleteImage(QUICK_RENDER_DELAY, true, false, false);
            }
        }

    }

    private void applyPaletteAndFilter3DModel() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        calculate3D(image_width, image_height, true, 1);

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(detail * detail, false, false);
        }

    }

    private void applyPaletteAndFilter() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        try {
            changePalette(image_width, image_height);
        }
        catch (StopSuccessiveRefinementException ex) {
            return;
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(image_width * image_height, false, false);
        }

    }

    private void applyPaletteAndFilterWithAA() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        try {
            changePaletteWithAA(image_width, image_height);
        }
        catch (StopSuccessiveRefinementException ex) {
            return;
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(image_width * image_height, false, true);
        }

    }

    private void applyPostProcessingWithAAandFilter() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        int totalSamples = supersampling_num + 1;
        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(totalSamples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        forcePostProcessing = true;
        try {
            postProcess(image_width, image_height, aa, null);
        }
        catch (StopSuccessiveRefinementException ex) {
            return;
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        if (finalize_sync.incrementAndGet() == ptr.getNumberOfThreads()) {
            applyFilters();

            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(image_width * image_height, false, true);
        }

    }

    protected void changePalette(int image_width, int image_height) throws StopSuccessiveRefinementException {

        int pixel_percent = (image_width * image_height) / 100;

        task_completed = 0;

        long time = System.currentTimeMillis();

        for (int y = FROMy; y < TOy; y++) {
            for (int x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {
                if (domain_coloring) {
                    rgbs[loc] = domain_color.getDomainColor(new Complex(domain_image_data_re[loc], domain_image_data_im[loc]));
                } else {
                    rgbs[loc] = getStandardColor(image_iterations[loc], escaped[loc]);
                }

                rendering_done++;
                task_completed++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        postProcess(image_width, image_height, null, null);

    }

    protected void changePaletteWithAA(int image_width, int image_height) throws StopSuccessiveRefinementException {

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        int totalSamples = supersampling_num + 1;
        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(totalSamples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        aa.setNeedsPostProcessing(needsPostProcessing());

        int pixel_percent = (image_width * image_height) / 100;
        int color;
        PixelExtraData data;

        task_completed = 0;

        long time = System.currentTimeMillis();

        for (int y = FROMy; y < TOy; y++) {
            for (int x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {

                data = pixelData[loc];
                data.update_rgb(0, color = getStandardColor(data.values[0], data.escaped[0]));

                aa.initialize(color);

                //Supersampling
                for(int i = 0; i < supersampling_num; i++) {
                    data.update_rgb(i + 1, color = getFinalColor(data.values[i + 1], data.escaped[i + 1]));

                    if(!aa.addSample(color)) {
                        break;
                    }
                }

                rgbs[loc] = aa.getColor();

                rendering_done++;
                task_completed++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        postProcess(image_width, image_height, aa, null);

    }

    private void juliaMapRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            juliaMapAntialiased(image_width, image_height, false);
        } else {
            juliaMap(image_width, image_height, false);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getJuliaMapSlices()) {
            applyFilters();

            updateMode(ptr, false, false, true, false);
            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(image_width * image_height, true, false);
        }

    }

    private void juliaMapPolarRendering() {

        int image_width = image.getWidth();
        int image_height = image.getHeight();

        if (filters[MainWindow.ANTIALIASING]) {
            juliaMapAntialiased(image_width, image_height, true);
        } else {
            juliaMap(image_width, image_height, true);
        }

        if (rendering_done != 0) {
            update(rendering_done);
        }

        max_pixel_calculation_time.accumulate(pixel_calculation_time_per_task);

        if (finalize_sync.incrementAndGet() == ptr.getJuliaMapSlices()) {
            applyFilters();

            updateMode(ptr, false, false, true, false);
            ptr.setOptions(true);
            ptr.setWholeImageDone(true);
            ptr.reloadTitle();
            ptr.getMainPanel().repaint();
            progress.setValue(progress.getMaximum());
            ptr.setProgressBarVisibility(false);
            setSmallToolTipMessage(image_width * image_height, true, false);
        }

    }

    private void juliaMap(int image_width, int image_height, boolean polar) {

        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, TOx - FROMx, TOy - FROMy, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);

        int pixel_percent = (image_width * image_height) / 100;

        boolean escaped_val;
        double f_val;

        long time = System.currentTimeMillis();

        for (int y = FROMy, y2 = 0; y < TOy; y++, y2++) {
            for (int x = FROMx, x2 = 0, loc = y * image_width + x; x < TOx; x++, loc++, x2++) {

                image_iterations[loc] = f_val = iteration_algorithm.calculate(location.getComplex(x2, y2));
                escaped[loc] = escaped_val = iteration_algorithm.escaped();
                rgbs[loc] = getFinalColor(f_val, escaped_val);

                rendering_done++;
                task_calculated++;

            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(image_width, image_height, null, null);
        } catch (StopSuccessiveRefinementException ex) {}

    }

    private void juliaMapAntialiased(int image_width, int image_height, boolean polar) {

        int aaMethod = (filters_options_vals[MainWindow.ANTIALIASING] % 100) / 10;
        boolean useJitter = aaMethod != 6 && ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x4) == 4;
        Location location = Location.getInstanceForRendering(xCenter, yCenter, size, height_ratio, TOx - FROMx, TOy - FROMy, circle_period, rotation_center, rotation_vals, fractal, js, polar, false);
        int aaSamplesIndex = (filters_options_vals[MainWindow.ANTIALIASING] % 100) % 10;
        int supersampling_num = getExtraSamples(aaSamplesIndex, aaMethod);
        location.createAntialiasingSteps(aaMethod == 5, useJitter, supersampling_num);

        int pixel_percent = (image_width * image_height) / 100;


        double temp_result;

        int color;

        boolean aaAvgWithMean = ((filters_options_vals[MainWindow.ANTIALIASING] / 100) & 0x1) == 1;
        int colorSpace = filters_options_extra_vals[0][MainWindow.ANTIALIASING];
        int totalSamples = supersampling_num + 1;

        AntialiasingAlgorithm aa = AntialiasingAlgorithm.getAntialiasingAlgorithm(totalSamples, aaMethod, aaAvgWithMean, colorSpace, fs.aaSigmaR, fs.aaSigmaS);

        aa.setNeedsPostProcessing(needsPostProcessing());

        boolean storeExtraData = pixelData != null;

        boolean escaped_val;
        double f_val;

        long time = System.currentTimeMillis();

        for (int y = FROMy, y2 = 0; y < TOy; y++, y2++) {
            for (int x = FROMx, x2 = 0, loc = y * image_width + x; x < TOx; x++, loc++, x2++) {

                image_iterations[loc] = f_val = iteration_algorithm.calculate(location.getComplex(x2, y2));
                escaped[loc] = escaped_val = iteration_algorithm.escaped();
                color = getFinalColor(f_val, escaped_val);

                if(storeExtraData) {
                    pixelData[loc].set(0, color, f_val, escaped_val, totalSamples);
                }

                aa.initialize(color);

                //Supersampling
                for (int i = 0; i < supersampling_num; i++) {
                    temp_result = iteration_algorithm.calculate(location.getAntialiasingComplex(i, loc));
                    escaped_val = iteration_algorithm.escaped();
                    color = getFinalColor(temp_result, escaped_val);

                    if(storeExtraData) {
                        pixelData[loc].set(i + 1, color, temp_result, escaped_val, totalSamples);
                    }

                    if(!aa.addSample(color)) {
                        break;
                    }
                }

                rgbs[loc] = aa.getColor();

                rendering_done++;
                task_calculated++;
            }

            if (rendering_done / pixel_percent >= 1) {
                update(rendering_done);
                rendering_done = 0;
            }

        }

        pixel_calculation_time_per_task = System.currentTimeMillis() - time;

        try {
            postProcess(image_width, image_height, aa, null);
        } catch (StopSuccessiveRefinementException ex) {}

    }

    private static final int MIN_3D_SCALED_VALUE = -100;

    private void shadeColorBasedOnHeight() {

        double min = MIN_3D_SCALED_VALUE;
        double range = max_scaling * d3_height_scale;

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                int r = (vert_color[x][y] >> 16) & 0xff;
                int g = (vert_color[x][y] >> 8) & 0xff;
                int b = vert_color[x][y] & 0xff;

                double coef = 0;

                switch (shade_algorithm) {
                    case 0: //lerp
                        coef = ((vert[x][y] - min) / range - 0.5) * 2;
                        break;
                    case 1://cos lerp
                        coef = -Math.cos((vert[x][y] - min) / range * Math.PI);
                        break;
                    case 2:
                        double lim = 0.1;
                        if ((vert[x][y] - min) / range <= lim) {
                            coef = -(1 - (vert[x][y] - min) / range * (1 / lim));
                        } else if ((vert[x][y] - min) / range >= (1 - lim)) {
                            coef = 1 - (1 - (vert[x][y] - min) / range) * (1 / lim);
                        } else {
                            coef = 0;
                        }
                        break;
                    case 3:
                        lim = 0.2;
                        if ((vert[x][y] - min) / range <= lim) {
                            coef = -(1 - (vert[x][y] - min) / range * (1 / lim));
                        } else if ((vert[x][y] - min) / range >= (1 - lim)) {
                            coef = 1 - (1 - (vert[x][y] - min) / range) * (1 / lim);
                        } else {
                            coef = 0;
                        }
                        break;
                    case 4:
                        lim = 0.3;
                        if ((vert[x][y] - min) / range <= lim) {
                            coef = -(1 - (vert[x][y] - min) / range * (1 / lim));
                        } else if ((vert[x][y] - min) / range >= (1 - lim)) {
                            coef = 1 - (1 - (vert[x][y] - min) / range) * (1 / lim);
                        } else {
                            coef = 0;
                        }
                        break;
                    case 5:
                        lim = 0.4;
                        if ((vert[x][y] - min) / range <= lim) {
                            coef = -(1 - (vert[x][y] - min) / range * (1 / lim));
                        } else if ((vert[x][y] - min) / range >= (1 - lim)) {
                            coef = 1 - (1 - (vert[x][y] - min) / range) * (1 / lim);
                        } else {
                            coef = 0;
                        }
                        break;
                }

                if (shade_invert) {
                    coef *= -1;
                }

                if (shade_choice == 2) { //-1 to 0 only
                    if (coef > 0) {
                        coef = 0;
                    }
                } else if (shade_choice == 1) { //0 to 1 only
                    if (coef < 0) {
                        coef = 0;
                    }
                }

                int col = 0;
                int col2 = 255 - col;

                if (coef < 0) {
                    r = (int) (col * Math.abs(coef) + r * (1 - Math.abs(coef)) + 0.5);
                    g = (int) (col * Math.abs(coef) + g * (1 - Math.abs(coef)) + 0.5);
                    b = (int) (col * Math.abs(coef) + b * (1 - Math.abs(coef)) + 0.5);
                } else {
                    r = (int) (col2 * coef + r * (1 - coef) + 0.5);
                    g = (int) (col2 * coef + g * (1 - coef) + 0.5);
                    b = (int) (col2 * coef + b * (1 - coef) + 0.5);
                }

                vert_color[x][y] = 0xff000000 | (r << 16) | (g << 8) | b;
            }
        }
    }

    protected void update(int new_percent) {

        progress.setValue(progress.getValue() + new_percent);

    }

    private double getGradientX(double val, double[] image_iterations, int i, int j, int index, int image_width, int image_height, Location location) {

        if(location != null) {
            double diffL = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(getIterData(i, j - 1, index - 1, image_iterations, image_width, image_height, location, false), max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffR = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, index + 1, image_iterations, image_width, image_height, location, false), max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffL * diffR >= 0 ? 0 : diffL - diffR;
        }

        if (j == 0) {
            return (fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index + 1], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale) - val) * 2;
        } else if (j == image_width - 1) {
            return (val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index - 1], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale)) * 2;
        } else {
            double diffL = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index - 1], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffR = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index + 1], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffL * diffR >= 0 ? 0 : diffL - diffR;
        }

    }

    private double getGradientX(double val, PixelExtraData[] data, int i, int j, int index, int subindex, int image_width, int image_height, Location location, AntialiasingAlgorithm aa) {

        if(location != null) {

            if(tempDataXm1 == null) {
                tempDataXm1 = getIterData(i, j - 1, index - 1, data, image_width, image_height, location, aa, false);
            }

            if(tempDataXp1 == null) {
                tempDataXp1 = getIterData(i, j + 1, index + 1, data, image_width, image_height, location, aa, false);
            }


            double diffL = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(tempDataXm1.values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffR = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(tempDataXp1.values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffL * diffR >= 0 ? 0 : diffL - diffR;
        }

        if (j == 0) {
            return (fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index + 1].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale) - val) * 2;
        } else if (j == image_width - 1) {
            return (val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index - 1].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale)) * 2;
        } else {
            double diffL = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index - 1].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffR = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index + 1].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffL * diffR >= 0 ? 0 : diffL - diffR;
        }

    }

    private double getGradientY(double val, double[] image_iterations, int i, int j, int index, int image_width, int image_height, Location location) {

        if(location != null) {
            double diffU = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j, index - image_width, image_iterations, image_width, image_height, location, false), max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffD = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, index + image_width, image_iterations, image_width, image_height, location, false), max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffD * diffU >= 0 ? 0 : diffD - diffU;
        }

        if (i == 0) {
            return (val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index + image_width], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale)) * 2;
        } else if (i == image_height - 1) {
            return (fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index - image_width], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale) - val) * 2;
        } else {
            double diffU = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index - image_width], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffD = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(image_iterations[index + image_width], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffD * diffU >= 0 ? 0 : diffD - diffU;
        }

    }

    PixelExtraData tempDataYm1;
    PixelExtraData tempDataYp1;

    PixelExtraData tempDataXm1;
    PixelExtraData tempDataXp1;

    private double getGradientY(double val, PixelExtraData[] data, int i, int j, int index, int subindex, int image_width, int image_height, Location location, AntialiasingAlgorithm aa) {

        if(location != null) {

            if(tempDataYm1 == null) {
                tempDataYm1 = getIterData(i - 1, j, index - image_width, data, image_width, image_height, location, aa, false);
            }

            if(tempDataYp1 == null) {
                tempDataYp1 = getIterData(i + 1, j, index + image_width, data, image_width, image_height, location, aa, false);
            }


            double diffU = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(tempDataYm1.values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffD = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(tempDataYp1.values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffD * diffU >= 0 ? 0 : diffD - diffU;
        }

        if (i == 0) {
            return (val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index + image_width].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale)) * 2;
        } else if (i == image_height - 1) {
            return (fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index - image_width].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale) - val) * 2;
        } else {
            double diffU = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index - image_width].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            double diffD = val - fractional_transfer(ColorAlgorithm.transformResultToHeight(data[index + image_width].values[subindex], max_iterations), bms.fractionalTransfer, bms.fractionalSmoothing, bms.fractionalTransferMode, bms.fractionalTransferScale);
            return diffD * diffU >= 0 ? 0 : diffD - diffU;
        }

    }

    private double getBumpCoef(double delta) {
        double mul = 0;

        switch (bms.bump_transfer_function) {
            case 0:
                mul = (1.5 / (Math.abs(delta * bms.bump_transfer_factor) + 1.5));
                break;
            case 1:
                mul = 1 / Math.sqrt(Math.abs(delta * bms.bump_transfer_factor) + 1);
                break;
            case 2:
                mul = 1 / Math.cbrt(Math.abs(delta * bms.bump_transfer_factor) + 1);
                break;
            case 3:
                mul = Math.pow(2, -Math.abs(delta * bms.bump_transfer_factor));
                break;
            //case 4:
            //mul = (Math.atan(-Math.abs(delta * bump_transfer_factor))*0.63662+1);
            //break;
        }

        return mul;
    }

    private int changeBrightnessOfColorLabHsbHsl(int rgb, double delta) {

        double mul = getBumpCoef(delta);

        int r = (rgb >> 16) & 0xFF;
        int g = (rgb >> 8) & 0xFF;
        int b = rgb & 0xFF;

        if (delta > 0) {
            mul = (2 - mul) / 2;
        } else {
            mul = mul / 2;
        }

        if (bms.bumpProcessing == 3) {
            double[] res = ColorSpaceConverter.RGBtoLAB(r, g, b);
            double val = contourFactor * mul * res[0];
            val = val > 100 ? 100 : val;
            int[] rgb2 = ColorSpaceConverter.LABtoRGB(val, res[1], res[2]);
            return 0xff000000 | (rgb2[0] << 16) | (rgb2[1] << 8) | rgb2[2];
        } else if (bms.bumpProcessing == 4) {
            double[] res = ColorSpaceConverter.RGBtoHSB(r, g, b);
            double val = contourFactor * mul * res[2];
            val = val > 1 ? 1 : val;
            int[] rgb2 = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb2[0] << 16) | (rgb2[1] << 8) | rgb2[2];
        } else if (bms.bumpProcessing == 5) {
            double[] res = ColorSpaceConverter.RGBtoHSL(r, g, b);
            double val = contourFactor * mul * res[2];
            val = val > 1 ? 1 : val;
            int[] rgb2 = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb2[0] << 16) | (rgb2[1] << 8) | rgb2[2];
        }
        else {
            double[] res = ColorSpaceConverter.RGBtoOKLAB(r, g, b);
            double val = contourFactor * mul * res[0];
            val = val > 1 ? 1 : val;
            int[] rgb2 = ColorSpaceConverter.OKLABtoRGB(val, res[1], res[2]);
            return 0xff000000 | (rgb2[0] << 16) | (rgb2[1] << 8) | rgb2[2];
        }
    }

    private int changeBrightnessOfColorScaling(int rgb, double delta) {
        int new_color = 0;

        double mul = getBumpCoef(delta);

        if (delta > 0) {
            rgb ^= 0xFFFFFF;
            int r = rgb & 0xFF0000;
            int g = rgb & 0x00FF00;
            int b = rgb & 0x0000FF;
            int ret = (int) (r * mul + 0.5) & 0xFF0000 | (int) (g * mul + 0.5) & 0x00FF00 | (int) (b * mul + 0.5);
            new_color = 0xff000000 | (ret ^ 0xFFFFFF);
        } else {
            int r = rgb & 0xFF0000;
            int g = rgb & 0x00FF00;
            int b = rgb & 0x0000FF;
            new_color = 0xff000000 | (int) (r * mul + 0.5) & 0xFF0000 | (int) (g * mul + 0.5) & 0x00FF00 | (int) (b * mul + 0.5);
        }

        return new_color;
    }

    private int changeBrightnessOfColorBlending(int rgbIn, double delta) {

        double mul = getBumpCoef(delta);

        int temp_red = 0;
        int temp_green = 0;
        int temp_blue = 0;

        if (delta > 0) {
            int index = bms.bumpProcessing == 1 ? (int) ((mul / 2) * (gradient.length - 1) + 0.5) : (int) ((1 - mul) * (gradient.length - 1) + 0.5);
            index = gradient.length - 1 - index;

            int grad_color = getGradientColor(index + gradient_offset);

            temp_red = (grad_color >> 16) & 0xff;
            temp_green = (grad_color >> 8) & 0xff;
            temp_blue = grad_color & 0xff;
        } else {
            int index = bms.bumpProcessing == 1 ? (int) (((2 - mul) / 2) * (gradient.length - 1) + 0.5) : (int) ((1 - mul) * (gradient.length - 1) + 0.5);
            index = gradient.length - 1 - index;

            int grad_color = getGradientColor(index + gradient_offset);

            temp_red = (grad_color >> 16) & 0xff;
            temp_green = (grad_color >> 8) & 0xff;
            temp_blue = grad_color & 0xff;
        }

        int old_red = (rgbIn >> 16) & 0xFF;
        int old_green = (rgbIn >> 8) & 0xFF;
        int old_blue = rgbIn & 0xFF;

        return blending.blend(temp_red, temp_green, temp_blue, old_red, old_green, old_blue, 1 - bms.bump_blending);

    }

    public static void terminateColorCycling() {

        try {
            color_cycling_toggle_lock.lockWrite();
        }
        catch (InterruptedException ex) {}

        color_cycling = false;
        color_cycling_toggle_lock.unlockWrite();

    }

    public static void initializeColorCycling() {

        try {
            color_cycling_toggle_lock.lockWrite();
        }
        catch (InterruptedException ex) {}
        color_cycling = true;
        color_cycling_toggle_lock.unlockWrite();

    }

    public BumpMapSettings getBumpMapSettings() {
        return bms;
    }

    public LightSettings getLightSettings() {
        return ls;
    }

    public SlopeSettings getSlopeSettings() {
        return ss;
    }

    public int getColorCyclingLocationOutColoring() {

        return color_cycling_location_outcoloring;

    }

    public int getColorCyclingLocationInColoring() {

        return color_cycling_location_incoloring;

    }

    public int getGradientOffset() {

        return gradient_offset;

    }

    private void applyFilters() {

        long time = System.currentTimeMillis();

        int active_filters_count = 0;
        for (int i = 0; i < filters.length; i++) {
            if (filters[i]) {
                active_filters_count++;
            }
        }

        int old_max = progress.getMaximum();
        int cur_val = progress.getValue();

        if (active_filters_count > 0) {
            progress.setMaximum(active_filters_count);
            progress.setValue(0);
            progress.setForeground(MainWindow.progress_filters_color);
            progress.setString("Image Filters: " + 0 + "/" + active_filters_count);
        }

        ImageFilters.filter(image, filters, filters_options_vals, filters_options_extra_vals, filters_colors, filters_extra_colors, filters_order, fs, progress);

        if (active_filters_count > 0) {
            progress.setString(null);
            progress.setMaximum(old_max);
            progress.setValue(cur_val);
            progress.setForeground(MainWindow.progress_color);
        }
        if(active_filters_count > 0) {
            FilterCalculationTime = System.currentTimeMillis() - time;
        }

    }

    private void applyFiltersNoProgress() {
        ImageFilters.filter(image, filters, filters_options_vals, filters_options_extra_vals, filters_colors, filters_extra_colors, filters_order, fs, null);
    }

    private double calculateHeight(double x) {

        double sign = x >= 0 ? 1 : -1;
        x = Math.abs(x);
        switch (height_algorithm) {
            case 0:
                return sign * Math.log(x + 1);
            case 1:
                return sign * Math.log(Math.log(x + 1) + 1);
            case 2:
                return sign * (1 / (x + 1));
            case 3:
                return sign * (1 / (Math.log(x + 1) + 1));
            case 4:
                return sign * x;

        }

        return 0;
    }

    private void findMinMaxHeight() {

        min = Double.MAX_VALUE;
        max = -Double.MAX_VALUE;

        for (int x = 0; x < detail; x++) {
            for (int y = 0; y < detail; y++) {
                if (Double.isNaN(vert[x][y]) || Double.isInfinite(vert[x][y])) {
                    continue;
                }

                if (vert[x][y] < min) {
                    min = vert[x][y];
                }

                if (vert[x][y] > max) {
                    max = vert[x][y];
                }
            }
        }

    }

    private void calculateFences() {

        double mean = 0;
        double variance = 0;
        long samples = 0;

        upperFence = Double.MAX_VALUE;
        lowerFence = -Double.MAX_VALUE;

        ArrayList<Double> data = null;
        if(outliers_method == 0) {
            data = new ArrayList<>();
        }

        for (int x = 0; x < detail; x++) {
            for (int y = 0; y < detail; y++) {
                double val = vert[x][y];
                if (Double.isNaN(val) || Double.isInfinite(val)) {
                    continue;
                }

                samples++;
                if(outliers_method == 0) {
                    data.add(val);
                }
                else {
                    double delta = val - mean;
                    mean += delta / samples;
                    double delta2 = val - mean;
                    variance += delta * delta2;
                }

            }
        }


        if(outliers_method == 0) {
            double[] res = getFences(data);
            lowerFence = res[0];
            upperFence = res[1];

            data.clear();
        }
        else {
            double sigma = Math.sqrt(variance / samples);
            lowerFence = mean - 3 * sigma;
            upperFence = mean + 3 * sigma;
        }

    }

    private double calculateMedian(ArrayList<Double> values, int start, int end) {
        int length = end - start;
        int middle = start + length / 2;

        if (length % 2 == 0) {
            return (values.get(middle) + values.get(middle - 1)) * 0.5;
        }

        return values.get(middle);
    }

    private double calculateMedianDouble(ArrayList<Double> values, int start, int end) {
        int length = end - start;
        int middle = start + length / 2;

        if (length % 2 == 0) {
            return (values.get(middle) + values.get(middle - 1)) * 0.5;
        }

        return values.get(middle);
    }

    private void applyHeightFunction() {

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                vert[x][y] = calculateHeight(vert[x][y]);
            }
        }
    }

    private void applyPostHeightScaling() {

        double local_max = max - (max - min) * (1 - max_range / 100.0);

        double local_min = min + (max - min) * (min_range / 100.0);

        local_min = local_min > local_max ? local_max : local_min;

        double new_max = local_max - local_min;

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                double val = vert[x][y];
                if (val <= local_max && val >= local_min) {
                    val -= local_min;
                    vert[x][y] = (val * (max_scaling / new_max));
                } else if (val > local_max) {
                    vert[x][y] = max_scaling;
                } else if (!Double.isNaN(val) && !Double.isInfinite(val)) {
                    vert[x][y] = 0;
                }

                vert[x][y] = (d3_height_scale * vert[x][y] + MIN_3D_SCALED_VALUE);
            }
        }

    }

    private void applyPreHeightScaling() {

        double local_max = max - (max - min) * (1 - max_range / 100.0);

        double local_min = min + (max - min) * (min_range / 100.0);

        local_min = local_min > local_max ? local_max : local_min;

        double new_max = local_max - local_min;

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                double val = vert[x][y];
                if (val <= local_max && val >= local_min) {
                    val -= local_min;
                    vert[x][y] = (val * (max_scaling / new_max));
                } else if (val > local_max) {
                    vert[x][y] = max_scaling;
                } else if (!Double.isNaN(val) && !Double.isInfinite(val)) {
                    vert[x][y] = 0;
                }
            }
        }
    }

    private void gaussianHeightScalingInit() {
        temp_array = new double[detail][detail];

        for (int x = 0; x < detail; x++) {
            for (int y = 0; y < detail; y++) {
                if (Double.isNaN(vert[x][y]) || Double.isInfinite(vert[x][y])) {
                    temp_array[x][y] = 0;
                }
                else {
                    temp_array[x][y] = vert[x][y];
                }
            }
        }

        gaussian_kernel = ImageFilters.createGaussianKernel(gaussian_kernel_size * 2 + 3, sigma_r);
    }

    private void gaussianHeightScalingEnd() {
        temp_array = null;
    }


    private double similarity(double val, double centralVal) {
        double distance = Math.abs(val - centralVal);
        double exponent = distance * sigma_s_reciprocal;
        exponent = exponent * exponent;
        return Math.exp(-0.5 * exponent);
    }

    private void gaussianOrBilateralHeightScaling() {

        int kernel_size = (int) (Math.sqrt(gaussian_kernel.length));
        int kernel_size2 = kernel_size / 2;

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                double sum = 0;
                double centerVal = 0;
                double combined_coef_sum = 0;

                if(bilateral_scaling) {
                    centerVal = temp_array[x][y];
                }

                for (int k = x - kernel_size2, p = 0; p < kernel_size; k++, p++) {
                    for (int l = y - kernel_size2, t = 0; t < kernel_size; l++, t++) {

                        if(k < 0 || k >= detail || l < 0 || l >= detail) {
                            continue;
                        }

                        if(bilateral_scaling) {
                            double currentVal = temp_array[k][l];
                            double combined_coef = gaussian_kernel[p * kernel_size + t] * similarity(currentVal, centerVal);
                            sum += currentVal * combined_coef;
                            combined_coef_sum += combined_coef;
                        }
                        else {
                            combined_coef_sum += gaussian_kernel[p * kernel_size + t];
                            sum += temp_array[k][l] * gaussian_kernel[p * kernel_size + t];
                        }
                    }
                }

                vert[x][y] = sum / combined_coef_sum;
            }
        }
    }


    private void removeOutliers() {

        for (int x = FROMx; x < TOx; x++) {
            for (int y = FROMy; y < TOy; y++) {
                double val = vert[x][y];

                if (Double.isNaN(val) || Double.isInfinite(val)) {
                    if (val == Double.NEGATIVE_INFINITY) {
                        vert[x][y] = lowerFence;
                    }
                    else if (val == Double.POSITIVE_INFINITY) {
                        vert[x][y] = upperFence;
                    }
                    else {
                        vert[x][y] = lowerFence;
                    }
                }

                if(val > upperFence) {
                    vert[x][y] = upperFence;
                }

                if(val < lowerFence) {
                    vert[x][y] = lowerFence;
                }
            }
        }

    }

    private void heightProcessing() {

        if (remove_outliers_pre) {

            if (remove_outliers_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

                calculateFences();

            }

            try {
                remove_outliers_sync2.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            removeOutliers();

        }

        if (gaussian_scaling || bilateral_scaling) {

            if (gaussian_scaling_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

                gaussianHeightScalingInit();

            }

            try {
                gaussian_scaling_sync2.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            gaussianOrBilateralHeightScaling();
        }

        if (preHeightScaling) {

            if (height_scaling_sync3.incrementAndGet() == ptr.getNumberOfThreads()) {

                findMinMaxHeight();

            }

            try {
                height_scaling_sync4.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            applyPreHeightScaling();
        }

        try {
            height_function_sync.await();
        } catch (InterruptedException ex) {

        } catch (BrokenBarrierException ex) {

        }

        applyHeightFunction();

        if (remove_outliers_post) {

            if (remove_outliers_sync3.incrementAndGet() == ptr.getNumberOfThreads()) {

                calculateFences();

            }

            try {
                remove_outliers_sync4.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            removeOutliers();

        }

        if (height_scaling_sync.incrementAndGet() == ptr.getNumberOfThreads()) {

            findMinMaxHeight();

        }

        try {
            height_scaling_sync2.await();
        } catch (InterruptedException ex) {

        } catch (BrokenBarrierException ex) {

        }

        applyPostHeightScaling();

        if (shade_height) {

            try {
                shade_color_height_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            shadeColorBasedOnHeight();
        }

        try {
            calculate_vectors_sync.await();
        } catch (InterruptedException ex) {

        } catch (BrokenBarrierException ex) {

        }

        if (gaussian_scaling || bilateral_scaling) {
            gaussianHeightScalingEnd();
        }

    }

    private void calculate3DVectors(double d, double w2) {

        int n1 = detail - 1;

        double mod;
        double ct = Math.cos(fiX), cf = Math.cos(fiY), st = Math.sin(fiX), sf = Math.sin(fiY);
        double m00 = scale * cf, m02 = scale * sf, m10 = scale * st * sf, m11 = scale * ct, m12 = -scale * st * cf;
        m20 = -ct * sf;
        m21 = st;
        m22 = ct * cf;

        double norm_0_0, norm_0_1, norm_0_2, norm_1_0, norm_1_1, norm_1_2;

        for (int x = FROMx; x < TOx; x++) {

            double c1 = d * x - w2;

            for (int y = FROMy; y < TOy; y++) {
                if (x < n1 && y < n1) {

                    norm_0_0 = vert[x][y] - vert[x + 1][y];
                    norm_0_1 = d;
                    norm_0_2 = vert[x + 1][y] - vert[x + 1][y + 1];
                    mod = Math.sqrt(norm_0_0 * norm_0_0 + norm_0_1 * norm_0_1 + norm_0_2 * norm_0_2);
                    norm_0_0 /= mod;
                    norm_0_1 /= mod;
                    norm_0_2 /= mod;

                    norm_1_0 = vert[x][y + 1] - vert[x + 1][y + 1];
                    norm_1_1 = d;
                    norm_1_2 = vert[x][y] - vert[x][y + 1];
                    mod = Math.sqrt(norm_1_0 * norm_1_0 + norm_1_1 * norm_1_1 + norm_1_2 * norm_1_2);
                    norm_1_0 /= mod;
                    norm_1_1 /= mod;
                    norm_1_2 /= mod;

                    Norm1z[x][y][0] = (float) (m20 * norm_0_0 + m21 * norm_0_1 + m22 * norm_0_2);
                    Norm1z[x][y][1] = (float) (m20 * norm_1_0 + m21 * norm_1_1 + m22 * norm_1_2);
                }

                double c2 = d * y - w2;
                vert1[x][y][0] = (float) (m00 * c1 + m02 * c2);
                vert1[x][y][1] = (float) (m10 * c1 + m11 * vert[x][y] + m12 * c2);
            }
        }
    }

    int min3(int val0, int val1, int val2) {
        return Math.min(Math.min(val0, val1), val2);
    }

    int max3(int val0, int val1, int val2) {
        return Math.max(Math.max(val0, val1), val2);
    }

   private void paint3D(int w2x, int w2y, boolean updateProgress, int tile_size) {

       ptr.setP3Render(true);

        long time = System.currentTimeMillis();

        int[] xPol = new int[3];
        int[] yPol = new int[3];

        Graphics2D g = image.createGraphics();

        int offsetStart = 0;
        int offsetEnd = 0;

        if(tile_size != 1 && detail % tile_size != 0) {
            offsetStart = 1;//detail % tile_size == 1 ? 1 : (detail % tile_size) / 2 + (detail % tile_size) % 2;
            offsetEnd = 1;//detail % tile_size == 1 ? 1 : (detail % tile_size) / 2;
        }

        int ib = offsetStart, ie = detail / tile_size - offsetEnd, sti = 1, jb = offsetStart, je = detail / tile_size - offsetEnd, stj = 1;

        if (m20 < 0) {
            ib = detail / tile_size - 1 - offsetStart;
            ie = -1 + offsetEnd;
            sti = -1;
        }

        if (m22 < 0) {
            jb = detail / tile_size  - 1 - offsetStart;
            je = -1 + offsetEnd;
            stj = -1;
        }

        int old_max = progress.getMaximum();
        int cur_val = progress.getValue();

        if (updateProgress) {
            progress.setMaximum(detail * detail);
            progress.setValue(0);
            progress.setString("3D Render: " + String.format("%3d", 0) + "%");
            progress.setForeground(MainWindow.progress_d3_color);
        }

        int red1, green1, blue1;
        int red2, green2, blue2;
        int red3, green3, blue3;
        int red, green, blue;

        color_3d_blending = 1 - color_3d_blending;

        int count = 0;
        for (int i1 = ib; i1 != ie; i1 += sti) {
            for (int j1 = jb; j1 != je; j1 += stj) {

                int i = i1 * tile_size;
                int j = j1 * tile_size;

                int ip1 = (i1 + 1) * tile_size;
                int jp1 = (j1 + 1) * tile_size;

                count++;

               if(ip1 < detail && ip1 >= 0 && jp1 < detail && jp1 >= 0) {



                    if (Norm1z[i][j][0] > 0) {
                        xPol[0] = w2x + (int) vert1[i][j][0];
                        xPol[1] = w2x + (int) vert1[ip1][j][0];
                        xPol[2] = w2x + (int) vert1[ip1][jp1][0];
                        yPol[0] = w2y - (int) vert1[i][j][1];
                        yPol[1] = w2y - (int) vert1[ip1][j][1];
                        yPol[2] = w2y - (int) vert1[ip1][jp1][1];

                        red1 = (((vert_color[i][j]) >> 16) & 0xff);
                        green1 = (((vert_color[i][j]) >> 8) & 0xff);
                        blue1 = ((vert_color[i][j]) & 0xff);

                        if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1 || D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 2) {
                            red2 = (((vert_color[ip1][j]) >> 16) & 0xff);
                            green2 = (((vert_color[ip1][j]) >> 8) & 0xff);
                            blue2 = ((vert_color[ip1][j]) & 0xff);

                            red3 = (((vert_color[ip1][jp1]) >> 16) & 0xff);
                            green3 = (((vert_color[ip1][jp1]) >> 8) & 0xff);
                            blue3 = ((vert_color[ip1][jp1]) & 0xff);

                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                Color color1 = new Color(getModifiedColor(red1, green1, blue1, Norm1z[i][j][0], d3_color_type, color_3d_blending, false));
                                Color color2 = new Color(getModifiedColor(red2, green2, blue2, Norm1z[i][j][0], d3_color_type, color_3d_blending, false));
                                Color color3 = new Color(getModifiedColor(red3, green3, blue3, Norm1z[i][j][0], d3_color_type, color_3d_blending, false));

                                Point2D p1 = new Point2D.Float(xPol[0], yPol[0]);
                                Point2D p2 = new Point2D.Float(xPol[1], yPol[1]);
                                Point2D p3 = new Point2D.Float(xPol[2], yPol[2]);

                                BarycentricGradientPaint gradient = new BarycentricGradientPaint(p1, p2, p3, color1, color2, color3);
                                g.setPaint(gradient);
                            }
                            else {
                                red = (int)((red1 + red2 + red3) / 3.0 + 0.5);
                                green = (int)((green1 + green2 + green3) / 3.0 + 0.5);
                                blue = (int)((blue1 + blue2 + blue3) / 3.0 + 0.5);
                                g.setColor(new Color(getModifiedColor(red, green, blue, Norm1z[i][j][0], d3_color_type, color_3d_blending, false)));
                            }
                        }
                        else {
                            red = red1;
                            green = green1;
                            blue = blue1;

                            g.setColor(new Color(getModifiedColor(red, green, blue, Norm1z[i][j][0], d3_color_type, color_3d_blending, false)));

                        }

                        if (filters[MainWindow.ANTIALIASING] && tile_size == 1) {
                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                int minx = min3(xPol[0], xPol[1], xPol[2]);
                                int miny = min3(yPol[0], yPol[1], yPol[2]);
                                double maxx = max3(xPol[0], xPol[1], xPol[2]);
                                double maxy = max3(yPol[0], yPol[1], yPol[2]);
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                            }
                            else {
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
                                g.fillPolygon(xPol, yPol, 3);
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                                g.fillPolygon(xPol, yPol, 3);
                            }
                        } else {
                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                int minx = min3(xPol[0], xPol[1], xPol[2]);
                                int miny = min3(yPol[0], yPol[1], yPol[2]);
                                double maxx = max3(xPol[0], xPol[1], xPol[2]);
                                double maxy = max3(yPol[0], yPol[1], yPol[2]);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                            }
                            else {
                                g.fillPolygon(xPol, yPol, 3);
                            }
                        }

                    }

                    if (Norm1z[i][j][1] > 0) {
                        xPol[0] = w2x + (int) vert1[i][j][0];
                        xPol[1] = w2x + (int) vert1[i][jp1][0];
                        xPol[2] = w2x + (int) vert1[ip1][jp1][0];
                        yPol[0] = w2y - (int) vert1[i][j][1];
                        yPol[1] = w2y - (int) vert1[i][jp1][1];
                        yPol[2] = w2y - (int) vert1[ip1][jp1][1];

                        red1 = (((vert_color[i][j]) >> 16) & 0xff);
                        green1 = (((vert_color[i][j]) >> 8) & 0xff);
                        blue1 = ((vert_color[i][j]) & 0xff);

                        if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1 || D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 2) {
                            red2 = (((vert_color[i][jp1]) >> 16) & 0xff);
                            green2 = (((vert_color[i][jp1]) >> 8) & 0xff);
                            blue2 = ((vert_color[i][jp1]) & 0xff);

                            red3 = (((vert_color[ip1][jp1]) >> 16) & 0xff);
                            green3 = (((vert_color[ip1][jp1]) >> 8) & 0xff);
                            blue3 = ((vert_color[ip1][jp1]) & 0xff);


                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                Color color1 = new Color(getModifiedColor(red1, green1, blue1, Norm1z[i][j][1], d3_color_type, color_3d_blending, false));
                                Color color2 = new Color(getModifiedColor(red2, green2, blue2, Norm1z[i][j][1], d3_color_type, color_3d_blending, false));
                                Color color3 = new Color(getModifiedColor(red3, green3, blue3, Norm1z[i][j][1], d3_color_type, color_3d_blending, false));

                                Point2D p1 = new Point2D.Float(xPol[0], yPol[0]);
                                Point2D p2 = new Point2D.Float(xPol[1], yPol[1]);
                                Point2D p3 = new Point2D.Float(xPol[2], yPol[2]);

                                BarycentricGradientPaint gradient = new BarycentricGradientPaint(p1, p2, p3, color1, color2, color3);
                                g.setPaint(gradient);
                            }
                            else {
                                red = (int)((red1 + red2 + red3) / 3.0 + 0.5);
                                green = (int)((green1 + green2 + green3) / 3.0 + 0.5);
                                blue = (int)((blue1 + blue2 + blue3) / 3.0 + 0.5);
                                g.setColor(new Color(getModifiedColor(red, green, blue, Norm1z[i][j][1], d3_color_type, color_3d_blending, false)));

                            }
                        }
                        else {
                            red = red1;
                            green = green1;
                            blue = blue1;
                            g.setColor(new Color(getModifiedColor(red, green, blue, Norm1z[i][j][1], d3_color_type, color_3d_blending, false)));

                        }

                        if (filters[MainWindow.ANTIALIASING] && tile_size == 1) {
                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                int minx = min3(xPol[0], xPol[1], xPol[2]);
                                int miny = min3(yPol[0], yPol[1], yPol[2]);
                                double maxx = max3(xPol[0], xPol[1], xPol[2]);
                                double maxy = max3(yPol[0], yPol[1], yPol[2]);
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                            }
                            else {
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
                                g.fillPolygon(xPol, yPol, 3);
                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                                g.fillPolygon(xPol, yPol, 3);
                            }
                        } else {
                            if(D3_APPLY_AVERAGE_TO_TRIANGLE_COLORS == 1) {
                                int minx = min3(xPol[0], xPol[1], xPol[2]);
                                int miny = min3(yPol[0], yPol[1], yPol[2]);
                                double maxx = max3(xPol[0], xPol[1], xPol[2]);
                                double maxy = max3(yPol[0], yPol[1], yPol[2]);
                                g.fillRect((minx), (miny), (int)Math.ceil(maxx-minx), (int)Math.ceil(maxy-miny));
                            }
                            else {
                                g.fillPolygon(xPol, yPol, 3);
                            }
                        }
                    }
                }
            }

            if (updateProgress) {
                progress.setValue(count);
                progress.setString("3D Render: " + String.format("%3d", (int) ((double) count / progress.getMaximum() * 100)) + "%");
            }
        }

        g.dispose();

        if (updateProgress) {
            progress.setString(null);
            progress.setMaximum(old_max);
            progress.setValue(cur_val);
            progress.setForeground(MainWindow.progress_color);
        }
        D3RenderingCalculationTime = System.currentTimeMillis() - time;
    }
    protected void postProcessFastJulia(int image_size, AntialiasingAlgorithm aa, Location location) {
        if (needsPostProcessing()) {
            try {
                post_processing_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            edgeData = new HashMap<>();
            edgeAAData = new HashMap<>();


            applyPostProcessing(image_size, image_size, image_iterations_fast_julia, escaped_fast_julia, pixelData_fast_julia, aa, location);


            try {
                normalize_sync2.await();
                escapedCounts = null;
                notEscapedCounts = null;
                arrayEscaped = null;
                arraynotEscaped = null;
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }
        }
    }

    protected void postProcessColorCycling(int image_width, int image_height) {

        if (needsPostProcessing()) {
            try {
                post_processing_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }


            applyPostProcessing(image_width, image_height, image_iterations, escaped, null, null, null);


            try {
                normalize_sync2.await();
                escapedCounts = null;
                notEscapedCounts = null;
                arrayEscaped = null;
                arraynotEscaped = null;
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }
        }
    }

    protected boolean needsPostProcessing() {
        return (
                (!domain_coloring && (hss.histogramColoring || ndes.useNumericalDem || ss.slopes || ls.lighting || bms.bump_map || fdes.fake_de || rps.rainbow_palette || ens.entropy_coloring || ofs.offset_coloring || gss.greyscale_coloring || cns.contour_coloring))
                || (domain_coloring && (ss.slopes || bms.bump_map || ls.lighting))
        ) && !USE_DIRECT_COLOR;
    }

    protected boolean needsSmoothing(FunctionSettings fns, NumericalDistanceEstimatorSettings ndes, LightSettings ls, SlopeSettings ss, BumpMapSettings bms, ContourColoringSettings cns, EntropyColoringSettings ens, RainbowPaletteSettings rps, FakeDistanceEstimationSettings fdes, StatisticsSettings sts) {
        return fns.smoothing || ((ndes.useNumericalDem || ss.slopes || ls.lighting || bms.bump_map || cns.contour_coloring || ens.entropy_coloring || rps.rainbow_palette || fdes.fake_de || sts.statistic) && USE_SMOOTHING_FOR_PROCESSING_ALGS);
    }

    private boolean forcePostProcessing = false;
    protected void postProcess(int image_width, int image_height, AntialiasingAlgorithm aa, Location location) throws StopSuccessiveRefinementException {

        if (forcePostProcessing || needsPostProcessing()) {

            task_post_processed = 0;

            try {
                post_processing_sync.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            if(progress != null) {
                if(progress.getValue() < progress.getMaximum()) {
                    progress.setValue(progress.getMaximum() - 1);
                }

                try {
                    SwingUtilities.invokeAndWait(() -> {
                        progress.setString("Post Processing");
                        progress.setIndeterminate(true);
                        if (MainWindow.useCustomLaf) {
                            progress.setForeground(Constants.progress_pp_color);
                        }
                    });
                }
                catch (Exception ex) {}

            }

            edgeData = new HashMap<>();
            edgeAAData = new HashMap<>();

            long time = System.currentTimeMillis();

            applyPostProcessing(image_width, image_height, image_iterations, escaped, pixelData, aa, location);

            post_processing_calculation_time_per_task = System.currentTimeMillis() - time;

            PostProcessingCalculationTime.accumulate(post_processing_calculation_time_per_task);

            if(task_post_processed >= 0) {
                total_post_processed.add(task_post_processed);
            }

            if(USE_QUICKRENDER_ON_GREEDY_SUCCESSIVE_REFINEMENT && hasSuccessiveRefinement()) {
                try {
                    successive_refinement_lock.lockRead();
                } catch (InterruptedException ex) {

                }

                try {
                    successive_refinement_rendering_algorithm_barrier.await();
                } catch (InterruptedException ex) {

                } catch (BrokenBarrierException ex) {
                }

                if (STOP_SUCCESSIVE_REFINEMENT) {
                    successive_refinement_lock.unlockRead();

                    finalizePostProcessing();

                    throw new StopSuccessiveRefinementException();
                }
                successive_refinement_lock.unlockRead();
            }

            try {
                normalize_sync2.await();
            } catch (InterruptedException ex) {

            } catch (BrokenBarrierException ex) {

            }

            finalizePostProcessing();

        }
    }

    private void finalizePostProcessing() {
        escapedCounts = null;
        notEscapedCounts = null;
        arrayEscaped = null;
        arraynotEscaped = null;

        if(progress != null) {
            try {
                SwingUtilities.invokeAndWait(() -> {
                    progress.setString(null);
                    progress.setIndeterminate(false);

                    if (MainWindow.useCustomLaf) {
                        progress.setForeground(Constants.progress_color);
                    }
                });
            }
            catch (Exception ex) {}
        }
    }

    private Blending blendingFactory(int interpolation, int color_blending) {

        switch (color_blending) {
            case MainWindow.NORMAL_BLENDING:
                return new NormalBlending(interpolation);
            case MainWindow.MULTIPLY_BLENDING:
                return new MultiplyBlending(interpolation);
            case MainWindow.DIVIDE_BLENDING:
                return new DivideBlending(interpolation);
            case MainWindow.ADDITION_BLENDING:
                return new AdditionBlending(interpolation);
            case MainWindow.SUBTRACTION_BLENDING:
                return new SubtractionBlending(interpolation);
            case MainWindow.DIFFERENCE_BLENDING:
                return new DifferenceBlending(interpolation);
            case MainWindow.VALUE_BLENDING:
                return new ValueBlending(interpolation);
            case MainWindow.SOFT_LIGHT_BLENDING:
                return new SoftLightBlending(interpolation);
            case MainWindow.SCREEN_BLENDING:
                return new ScreenBlending(interpolation);
            case MainWindow.DODGE_BLENDING:
                return new DodgeBlending(interpolation);
            case MainWindow.BURN_BLENDING:
                return new BurnBlending(interpolation);
            case MainWindow.DARKEN_ONLY_BLENDING:
                return new DarkenOnlyBlending(interpolation);
            case MainWindow.LIGHTEN_ONLY_BLENDING:
                return new LightenOnlyBlending(interpolation);
            case MainWindow.HARD_LIGHT_BLENDING:
                return new HardLightBlending(interpolation);
            case MainWindow.GRAIN_EXTRACT_BLENDING:
                return new GrainExtractBlending(interpolation);
            case MainWindow.GRAIN_MERGE_BLENDING:
                return new GrainMergeBlending(interpolation);
            case MainWindow.SATURATION_BLENDING:
                return new SaturationBlending(interpolation);
            case MainWindow.COLOR_BLENDING:
                return new ColorBlending(interpolation);
            case MainWindow.HUE_BLENDING:
                return new HueBlending(interpolation);
            case MainWindow.EXCLUSION_BLENDING:
                return new ExclusionBlending(interpolation);
            case MainWindow.PIN_LIGHT_BLENDING:
                return new PinLightBlending(interpolation);
            case MainWindow.LINEAR_LIGHT_BLENDING:
                return new LinearLightBlending(interpolation);
            case MainWindow.VIVID_LIGHT_BLENDING:
                return new VividLightBlending(interpolation);
            case MainWindow.OVERLAY_BLENDING:
                return new OverlayBlending(interpolation);
            case MainWindow.LCH_CHROMA_BLENDING:
                return new LCHChromaBlending(interpolation);
            case MainWindow.LCH_COLOR_BLENDING:
                return new LCHColorBlending(interpolation);
            case MainWindow.LCH_HUE_BLENDING:
                return new LCHHueBlending(interpolation);
            case MainWindow.LCH_LIGHTNESS_BLENDING:
                return new LCHLightnessBlending(interpolation);
            case MainWindow.LUMINANCE_BLENDING:
                return new LuminanceBlending(interpolation);
            case MainWindow.LINEAR_BURN_BLENDING:
                return new LinearBurnBlending(interpolation);
        }

        return null;
    }

    private void domainColoringFactory(DomainColoringSettings ds, int interpolation) {

        this.ds = ds;

        if (ds.customDomainColoring) {
            domain_color = new CustomDomainColoring(ds, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, gradient, interpolation, gradient_offset, contourFactor);
            return;
        }

        switch (ds.domain_coloring_alg) {
            case 0:
                domain_color = new BlackGridWhiteCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 1:
                domain_color = new WhiteGridBlackCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 2:
                domain_color = new BlackGridDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 3:
                domain_color = new WhiteGridDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 4:
                domain_color = new BlackGridBrightContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 5:
                domain_color = new WhiteGridDarkContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 6:
                domain_color = new NormBlackGridWhiteCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 7:
                domain_color = new NormWhiteGridBlackCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 8:
                domain_color = new NormBlackGridDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 9:
                domain_color = new NormWhiteGridDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 10:
                domain_color = new NormBlackGridBrightContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 11:
                domain_color = new NormWhiteGridDarkContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 12:
                domain_color = new WhiteCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 13:
                domain_color = new BlackCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 14:
                domain_color = new BrightContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 15:
                domain_color = new DarkContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 16:
                domain_color = new NormWhiteCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 17:
                domain_color = new NormBlackCirclesLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 18:
                domain_color = new NormBrightContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 19:
                domain_color = new NormDarkContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 20:
                domain_color = new BlackGridContoursLog2IsoLinesDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 21:
                domain_color = new NormBlackGridContoursLog2IsoLinesDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 22:
                domain_color = new BlackGridIsoContoursDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 23:
                domain_color = new NormBlackGridIsoContoursDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 24:
                domain_color = new IsoContoursContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 25:
                domain_color = new NormIsoContoursContoursLog2DomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 26:
                domain_color = new GridContoursIsoLinesDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
            case 27:
                domain_color = new NormGridContoursIsoLinesDomainColoring(ds.domain_coloring_mode, palette_outcoloring, color_transfer_outcoloring, color_cycling_location_outcoloring, gps, blending, interpolation, contourFactor);
                break;
        }

        domain_color.setGradientOffset(gradient_offset);

    }

    protected int getColorForSkippedPixels(int color, int divide_iteration) {

        switch (SKIPPED_PIXELS_ALG) {
            case 0:
                return color;
            case 1:
                return algorithm_colors[(int)(getRandomThreadId() % algorithm_colors.length)];
            case 2:
                return SKIPPED_PIXELS_COLOR;
            case 3:
                return algorithm_colors[(divide_iteration + randomNumber) % algorithm_colors.length];
            case 4:
                return Constants.SKIPPED_PIXELS_SPECIAL_COLOR;
            default:
                return color;
        }

    }

    public static int getGroupPixelColor(int group) {
        return algorithm_colors[(group + randomNumber) % algorithm_colors.length];
    }

    private double fractional_transfer(double value, int fractional_transfer, int fractional_smoothing, int fractional_transfer_mode, double scale) {

        int sign = 1;
        if(value < 0) {
            sign = -1;
        }

        double fract_part = MathUtils.fract(value);
        fract_part = fade(fractional_smoothing, fract_part);
        double old_fract_part = fract_part;

        switch (fractional_transfer) {
            case 0:
                return (int)value + sign * fract_part;
            case 1:
                double temp = 2*fract_part-1;
                fract_part = 1 - temp * temp;
                break;
            case 2:
                temp = 2*fract_part-1;
                fract_part = temp * temp - 1;
                break;
            case 3:
                temp = 2*fract_part-1;
                temp *= temp;
                fract_part = 1 - temp * temp;
                break;
            case 4:
                temp = 2*fract_part-1;
                temp *= temp;
                fract_part = temp * temp - 1;
                break;
            case 5:
                fract_part = Math.sin(fract_part * Math.PI);
                break;
            case 6:
                fract_part = -Math.sin(fract_part * Math.PI);
                break;
            case 7:
                if(fract_part < 0.5) {
                    fract_part = 2 * fract_part;
                }
                else {
                    fract_part = 2 - 2 *fract_part;
                }
                break;
            case 8:
                if(fract_part < 0.5) {
                    fract_part = -2 * fract_part;
                }
                else {
                    fract_part = -(2 - 2 *fract_part);
                }
                break;
            case 9:
                fract_part = 0.5 - 0.5 * Math.cos(2 * fract_part * Math.PI);
                break;
            case 10:
                fract_part = -0.5 + 0.5 * Math.cos(2 * fract_part * Math.PI);
                break;
            case 11:
                if(fract_part < 0.5) {
                    fract_part = Math.sqrt(2 * fract_part);
                }
                else {
                    fract_part = Math.sqrt(2 - 2 *fract_part);
                }
                break;
            case 12:
                if(fract_part < 0.5) {
                    fract_part = -Math.sqrt(2 * fract_part);
                }
                else {
                    fract_part = -Math.sqrt(2 - 2 *fract_part);
                }
                break;
        }

        value = (int)value + sign * scale * (fract_part + (fractional_transfer_mode == 1 ? old_fract_part : 0));

        return value;
    }

    private double fractional_transfer_3d(double value) {
        value = d3s.height_invert ? -value : value;
        return fractional_transfer(value, d3s.fractionalTransfer, d3s.fractionalSmoothing, d3s.fractionalTransferMode, d3s.fractionalTransferScale);
    }

    private double height_transfer(double value) {

        value = fractional_transfer(value, ls.fractionalTransfer, ls.fractionalSmoothing, ls.fractionalTransferMode, ls.fractionalTransferScale);

        switch (ls.heightTransfer) {
            case 0:
                return value * ls.heightTransferFactor;
            case 1:
                return Math.sqrt(value * ls.heightTransferFactor);
            case 2:
                return value * ls.heightTransferFactor * value * ls.heightTransferFactor;
        }

        return 0;

    }

    private double height_transfer_slopes(double value) {

        value = fractional_transfer(value, ss.fractionalTransfer, ss.fractionalSmoothing, ss.fractionalTransferMode, ss.fractionalTransferScale);

        switch (ss.heightTransfer) {
            case 0:
                return value * ss.heightTransferFactor;
            case 1:
                return Math.sqrt(value * ss.heightTransferFactor);
            case 2:
                return value * ss.heightTransferFactor * value * ss.heightTransferFactor;
        }

        return 0;

    }

    private double _angleV = 20;
    private double _angleH = 20;
    private double _intensity = 2;
    private double _diffuse = 32;
    private double _specularIntensity = 1;
    private double _specularSize = 4;
    private double _specularDiffuse = 16;
    private double _heightMultiplier = 16;
    private double _angleMultiplier = 16;

    public int light2(double[] image_iterations, int color, int i, int j, int image_size)
    {
            int x = j;
            int y = i;

            int k0 = image_size * y + x;

            double c = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations) * _heightMultiplier;
            double tp = 0;
            double bp = 0;
            double lp = 0;
            double rp = 0;

            //int count1 = 0;
            //int count2 = 0;
            //int count3 = 0;
            //int count4 = 0;

            for (int yy = -1; yy <= 1; yy++)
            {
                for (int xx = -1; xx <= 1; xx++)
                {
                    if (y + yy >= 0 && y + yy < image_size && x + xx >= 0 && x + xx < image_size)
                    {
                        if (yy != 0 || xx != 0)
                        {
                            int kn = k0 + image_size * yy + xx;//image_size * (y + yy) + x + xx;
                            double pc = ColorAlgorithm.transformResultToHeight(image_iterations[kn], max_iterations) * _heightMultiplier;

                            if (yy < 0) {
                                tp += pc;
                                //count1++;
                            }
                            if (yy > 0) {
                                bp += pc;
                                //count2++;
                            }
                            if (xx < 0) {
                                lp += pc;
                                //count3++;
                            }
                            if (xx > 0) {
                                rp += pc;
                                //count4++;
                            }
                        }
                    }
                }
            }

            //3
            tp /= 3;
            bp /= 3;
            lp /= 3;
            rp /= 3;

        //va = Math.toDegrees(va) * _angleMultiplier;

        //ha = Math.toDegrees(ha) * _angleMultiplier;

        double va = Math.atan2(((c - tp) + (bp - c)) / 2, 1) * _angleMultiplier;
        va = Math.min(90, Math.max(-90, va));
        double ha = Math.atan2(((c - lp) + (rp - c)) / 2, 1) * _angleMultiplier;
        ha = Math.min(90, Math.max(-90, ha));
        double vd = Math.abs(_angleV - va);
        double hd = Math.abs(_angleH - ha);

        double distance = Math.sqrt(vd * vd + hd * hd);
        double light = _intensity - Math.max(0, distance / _diffuse);

        double specDistance = Math.max(0, distance - _specularSize);
        double spec = 255 * Math.max(0, _specularIntensity  - Math.max(0, specDistance / _specularDiffuse));

        int r = (color >> 16) & 0xFF;
        int g = (color >> 8) & 0xFF;
        int b = color & 0xFF;

        return 0xff000000 | ((int)Math.max(0, Math.min(255, r * light + spec)) << 16) | ((int)Math.max(0, Math.min(255, g * light +  spec)) << 8) | (int)Math.max(0, Math.min(255, b * light + spec));

        /*double coef = light;
        double coef2 = spec;

        if (ls.colorMode == 0) { //Lab
            double[] res = ColorSpaceConverter.RGBtoLAB(r, g, b);
            int[] rgb = ColorSpaceConverter.LABtoRGB(res[0] * coef + coef2 * 100, res[1], res[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (ls.colorMode == 1) { //HSB
            double[] res = ColorSpaceConverter.RGBtoHSB(r, g, b);

            double val = res[2] * coef + coef2;

            if (val > 1) {
                val = 1;
            }
            if (val < 0) {
                val = 0;
            }

            int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (ls.colorMode == 2) { //HSL
            double[] res = ColorSpaceConverter.RGBtoHSL(r, g, b);

            double val = res[2] * coef + coef2;

            if (val > 1) {
                val = 1;
            }
            if (val < 0) {
                val = 0;
            }

            int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (ls.colorMode == 3) { //Blending

            if (coef > 1) {
                coef = 1;
            }
            if (coef < 0) {
                coef = 0;
            }

            int index = (int) ((1 - coef) * (gradient.length - 1) + 0.5);
            index = gradient.length - 1 - index;

            int grad_color = getGradientColor(index + gradient_offset);

            int temp_red = (grad_color >> 16) & 0xff;
            int temp_green = (grad_color >> 8) & 0xff;
            int temp_blue = grad_color & 0xff;

            int new_color =  blending.blend(temp_red, temp_green, temp_blue, r, g, b, 1 - ls.light_blending);

            r = (new_color >> 16) & 0xFF;
            g = (new_color >> 8) & 0xFF;
            b = new_color & 0xFF;

            double temp = coef2 * 255;
            r = (int) (r + temp + 0.5);
            g = (int) (g + temp + 0.5);
            b = (int) (b + temp +  0.5);

            if (r > 255) {
                r = 255;
            }
            if (g > 255) {
                g = 255;
            }
            if (b > 255) {
                b = 255;
            }

            if (r < 0) {
                r = 0;
            }
            if (g < 0) {
                g = 0;
            }
            if (b < 0) {
                b = 0;
            }

            return 0xff000000 | (r << 16) | (g << 8) | b;
        } else { //scaling

            double temp = coef2 * 255;
            r = (int) (r * coef + temp + 0.5);
            g = (int) (g * coef + temp + 0.5);
            b = (int) (b * coef + temp + 0.5);

            if (r > 255) {
                r = 255;
            }
            if (g > 255) {
                g = 255;
            }
            if (b > 255) {
                b = 255;
            }

            if (r < 0) {
                r = 0;
            }
            if (g < 0) {
                g = 0;
            }
            if (b < 0) {
                b = 0;
            }

            return 0xff000000 | (r << 16) | (g << 8) | b;
        }*/
    }

    private double calculateData(int y, int x, Location location) {

        Coordinate c = new Coordinate(x, y);
        Double val = edgeData.get(c);
        if(val != null){
            return val;
        }

        task_calculated_extra++;

        double newVal;

        if(domain_coloring) {
            Complex cval = iteration_algorithm.calculateDomain(location.getComplex(x, y));
            newVal = scaleDomainHeight(getDomainHeight(cval));
        }
        else {
            if (d3) {
                newVal = iteration_algorithm.calculate3D(location.getComplex(x, y))[1];
            }
            else {
                newVal = iteration_algorithm.calculate(location.getComplex(x, y));
            }
        }

        edgeData.put(c, newVal);

        return newVal;
    }


    private PixelExtraData calculateData(int y, int x, Location location, AntialiasingAlgorithm aa) {

        Coordinate c = new Coordinate(x, y);
        PixelExtraData val = edgeAAData.get(c);
        if(val != null){
            return val;
        }

        task_calculated_extra++;

        int totalSamples = aa.getTotalSamples();
        int supersampling_num = totalSamples - 1;
        PixelExtraData data = new PixelExtraData();

        if(domain_coloring) {
            Complex cval = iteration_algorithm.calculateDomain(location.getComplex(x, y));
            data.set(0, 0, scaleDomainHeight(getDomainHeight(cval)), true, totalSamples);
        }
        else {
            if(d3) {
                data.set(0, 0, iteration_algorithm.calculate3D(location.getComplex(x, y))[1], iteration_algorithm.escaped(), totalSamples);
            }
            else {
                //We dont care about the color
                data.set(0, 0, iteration_algorithm.calculate(location.getComplex(x, y)), iteration_algorithm.escaped(), totalSamples);
            }
        }

        int hash = c.hashCode();

        for(int i = 0; i < supersampling_num; i++) {
            if(domain_coloring) {
                Complex cval = iteration_algorithm.calculateDomain(location.getAntialiasingComplex(i, hash));
                data.set(i + 1, 0, scaleDomainHeight(getDomainHeight(cval)), true, totalSamples);
            }
            else {
                if(d3) {
                    data.set(i + 1, 0, iteration_algorithm.calculate3D(location.getAntialiasingComplex(i, hash))[1], iteration_algorithm.escaped(), totalSamples);
                }
                else {
                    data.set(i + 1, 0, iteration_algorithm.calculate(location.getAntialiasingComplex(i, hash)), iteration_algorithm.escaped(), totalSamples);
                }
            }

        }

        edgeAAData.put(c, data);

        return data;
    }

    private double getIterData(int i, int j, int index, double[] image_iterations, int image_width, int image_height, Location location, boolean useIndex) {

        boolean InRange = i >= 0 && j >= 0 && i < image_height && j < image_width;
        if(location == null) {
            if(InRange) {
                return image_iterations[index];
            }
            else if(useIndex) {
                return image_iterations[index];
            }

            return 0;
        }

        if(InRange) {
            return image_iterations[index];
        }

        return calculateData(i, j, location);
    }

    private double getIterData(int i, int j, int index, double[] image_iterations, int image_width, int image_height, Location location, boolean useIndex, double defaultValue) {

        boolean InRange = i >= 0 && j >= 0 && i < image_height && j < image_width;
        if(location == null) {
            if(InRange) {
                return image_iterations[index];
            }
            else if(useIndex) {
                return image_iterations[index];
            }

            return defaultValue;
        }

        if(InRange) {
            return image_iterations[index];
        }

        return calculateData(i, j, location);
    }

    private PixelExtraData getIterData(int i, int j, int index, PixelExtraData[] data, int image_width, int image_height, Location location, AntialiasingAlgorithm aa, boolean useIndex) {

        boolean InRange = i >= 0 && j >= 0 && i < image_height && j < image_width;

        if(location == null) {
            if(InRange) {
                return data[index];
            }
            else if(useIndex) {
                return data[index];
            }

            return null;
        }

        if(InRange) {
            return data[index];
        }

        return calculateData(i, j, location, aa);
    }

    private double lz = Double.MAX_VALUE;

    private int[] light(double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, Location location, AntialiasingAlgorithm aa) {

        int k0 = image_width * i + j;

        int kx = k0 + 1;
        int sx = 1;

        if (location == null && j == image_width - 1) {
            kx -= 2;
            sx = -1;
        }

        int ky = k0 + image_width;
        int sy = 1;

        if (location == null && i == image_height - 1) {
            ky -= 2 * image_width;
            sy = -1;
        }

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;
        PixelExtraData dataKx = null;
        PixelExtraData dataKy = null;

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            dataKx = getIterData(i, j + 1, kx, data, image_width, image_height, location, aa, true);
            dataKy = getIterData(i + 1, j, ky, data, image_width, image_height, location, aa, true);
        }

        for(int m = 0; m < output.length; m++) {

            double h00, h10, h01;

            if(data != null && output.length > 1) {
                h00 = ColorAlgorithm.transformResultToHeight(dataK0.values[m], max_iterations);
                h10 = ColorAlgorithm.transformResultToHeight(dataKx.values[m], max_iterations);
                h01 = ColorAlgorithm.transformResultToHeight(dataKy.values[m], max_iterations);
            }
            else {
                h00 = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);
                h10 = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, kx, image_iterations, image_width, image_height, location, true), max_iterations);
                h01 = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, ky, image_iterations, image_width, image_height, location, true), max_iterations);
            }


            h00 = height_transfer(h00);
            h10 = height_transfer(h10);
            h01 = height_transfer(h01);

            double xz = h10 - h00;
            double yz = h01 - h00;

            double nx = -xz * sy;
            double ny = -sx * yz;
            double nz = sx * (double) sy;

            // normalize nx, ny and nz
            double nlen = Math.sqrt(nx * nx + ny * ny + nz * nz);

            nx = nx / nlen;
            ny = ny / nlen;
            nz = nz / nlen;

            double lx = ls.lightVector[0];
            double ly = -ls.lightVector[1];

            if(lz == Double.MAX_VALUE) {
                lz = Math.sqrt(1 - lx * lx - ly * ly);
            }

            // Lambert's law.
            double NdotL = lx * nx + ly * ny + lz * nz;

            double lreflz = nz * NdotL * 2 - lz;

            int wr = 0, wg = 0, wb = 0;

            if(ls.specularReflectionMethod > 0) {
                double lreflx = nx * NdotL * 2 - lx;
                double lrefly = ny * NdotL * 2 - ly;

                double refx = 0.5 * (1 - Math.atan2(lreflx, lreflz) / Math.PI);

                if (refx > 1) {
                    refx--;
                } else if (refx < 0) {
                    refx++;
                }

                double refy;

                if (lrefly >= 1) {
                    refy = 1;
                } else if (lrefly <= -1) {
                    refy = 0;
                } else {
                    refy = 0.5 + Math.asin(lrefly) / Math.PI;
                }

                int indexx = (int)(refx * (window_image.getWidth() - 1) + 0.5);
                int indexy = (int)(refy * (window_image.getHeight() - 1) + 0.5);

                int window_color =  window_image.getRGB(indexx, indexy);

                wr = (window_color >> 16) & 0xFF;
                wg = (window_color >> 8) & 0xFF;
                wb = window_color & 0xFF;
            }


            double coef = 0;

            // if lumen is negative it is behind,
            // but I tweak it a bit for the sake of the looks:
            // NdotL = -1 (which is super-behind) ==> 0
            // NdotL = 0 ==> ambientlight
            // NdotL = 1 ==> lightintensity
            // for a mathematically correct look use the following:
            // if NdotL < 0 then NdotL = 0;
            // color.a = color.a * (ambientlight + lightintensity lumen);
            if (ls.lightMode == 0) {
                double d = ls.lightintensity / 2;
                coef = (((d - ls.ambientlight) * NdotL + d) * NdotL + ls.ambientlight);
            } else if (ls.lightMode == 1) {
                coef = Math.max(0, (ls.ambientlight + ls.lightintensity * NdotL));
            } else if (ls.lightMode == 2) {
                coef = (ls.ambientlight + ls.lightintensity * NdotL);
            }

            // Next, specular reflection. Viewer is always assumed to be in direction (0,0,1)
            // r = 2 n l - l; v = 0:0:1
            double spec_refl = Math.max(0, lreflz);

            double coef2;
            if(ls.specularReflectionMethod > 0) {
                if(wr < 40 && wg < 40 && wb < 40) {
                   coef2 = ls.specularintensity / 3.6 * Math.pow(spec_refl, ls.shininess);

                }
                else {
                    coef2 = ls.specularintensity * Math.pow(spec_refl, ls.shininess);
                }
            }
            else {
                coef2 = ls.specularintensity * Math.pow(spec_refl, ls.shininess);
            }

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            if (ls.colorMode == 0) { //Lab
                double[] res = ColorSpaceConverter.RGBtoLAB(r, g, b);
                int[] rgb = ColorSpaceConverter.LABtoRGB(res[0] * coef + coef2 * 100, res[1], res[2]);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ls.colorMode == 1) { //HSB
                double[] res = ColorSpaceConverter.RGBtoHSB(r, g, b);

                double val = res[2] * coef + coef2;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ls.colorMode == 2) { //HSL
                double[] res = ColorSpaceConverter.RGBtoHSL(r, g, b);

                double val = res[2] * coef + coef2;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ls.colorMode == 3) { //Blending
                if (coef > 1) {
                    coef = 1;
                }
                if (coef < 0) {
                    coef = 0;
                }

                int index = (int) ((1 - coef) * (gradient.length - 1) + 0.5);
                index = gradient.length - 1 - index;

                int grad_color = getGradientColor(index + gradient_offset);

                int temp_red = (grad_color >> 16) & 0xff;
                int temp_green = (grad_color >> 8) & 0xff;
                int temp_blue = grad_color & 0xff;

                int new_color = blending.blend(temp_red, temp_green, temp_blue, r, g, b, 1 - ls.light_blending);

                r = (new_color >> 16) & 0xFF;
                g = (new_color >> 8) & 0xFF;
                b = new_color & 0xFF;

                double temp = coef2 * 255;
                r = (int) (r + temp + 0.5);
                g = (int) (g + temp + 0.5);
                b = (int) (b + temp + 0.5);

                if (r > 255) {
                    r = 255;
                }
                if (g > 255) {
                    g = 255;
                }
                if (b > 255) {
                    b = 255;
                }

                if (r < 0) {
                    r = 0;
                }
                if (g < 0) {
                    g = 0;
                }
                if (b < 0) {
                    b = 0;
                }

                output[m] = 0xff000000 | (r << 16) | (g << 8) | b;
            } else if (ls.colorMode == 4) { //scaling

                double temp = coef2 * 255;
                r = (int) (r * coef + temp + 0.5);
                g = (int) (g * coef + temp + 0.5);
                b = (int) (b * coef + temp + 0.5);

                if (r > 255) {
                    r = 255;
                }
                if (g > 255) {
                    g = 255;
                }
                if (b > 255) {
                    b = 255;
                }

                if (r < 0) {
                    r = 0;
                }
                if (g < 0) {
                    g = 0;
                }
                if (b < 0) {
                    b = 0;
                }

                output[m] = 0xff000000 | (r << 16) | (g << 8) | b;
            }
            else {
                double[] res = ColorSpaceConverter.RGBtoOKLAB(r, g, b);
                int[] rgb = ColorSpaceConverter.OKLABtoRGB(res[0] * coef + coef2, res[1], res[2]);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            }
        }

        return output;

    }

    double hypot2(double x, double y) { return x * x + y * y; }
    double hypot1(double x, double y) { return Math.sqrt(x * x + y * y); }
    double sqr(double x) {return x * x;}

    private double[][][] create_stencil(int i, int j, int k0, int image_width, int image_height, double[] image_iterations, Location location, PixelExtraData[] data, PixelExtraData[] stencilData, boolean useData, AntialiasingAlgorithm aa, int dataIndex) {

        int k_m1_0 = k0 - image_width;
        int k_m1_m1 = k_m1_0 - 1;
        int k_m1_p1 = k_m1_0 + 1;

        int k_0_m1 = k0 - 1;
        int k_0_p1 = k0 + 1;

        int k_p1_0 = k0 + image_width;
        int k_p1_m1 = k_p1_0 - 1;
        int k_p1_p1 = k_p1_0 + 1;

        double ninf = 1.0 / 0.0;
        double p[][] = new double[][] { { ninf, ninf, ninf }, { ninf, ninf, ninf }, { ninf, ninf, ninf } };
        double px[][] = new double[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } };
        double py[][] = new double[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } };

        if(useData) {

            if(stencilData[0] == null) {

                stencilData[0] = getIterData(i - 1, j - 1, k_m1_m1, data, image_width, image_height, location, aa, false);
                stencilData[1] = getIterData(i - 1, j, k_m1_0, data, image_width, image_height, location, aa, false);
                stencilData[2] = getIterData(i - 1, j + 1, k_m1_p1, data, image_width, image_height, location, aa, false);

                stencilData[3] = getIterData(i, j - 1, k_0_m1, data, image_width, image_height, location, aa, false);
                //index 4 was preloaded
                stencilData[5] = getIterData(i, j + 1, k_0_p1, data, image_width, image_height, location, aa, false);

                stencilData[6] = getIterData(i + 1, j - 1, k_p1_m1, data, image_width, image_height, location, aa, false);
                stencilData[7] = getIterData(i + 1, j, k_p1_0, data, image_width, image_height, location, aa, false);
                stencilData[8] = getIterData(i + 1, j + 1, k_p1_p1, data, image_width, image_height, location, aa, false);
            }

            if(stencilData[0] != null) {
                p[0][0] = ColorAlgorithm.transformResultToHeight(stencilData[0].values[dataIndex], max_iterations);
            }
            if(stencilData[1] != null) {
                p[0][1] = ColorAlgorithm.transformResultToHeight(stencilData[1].values[dataIndex], max_iterations);
            }
            if(stencilData[2] != null) {
                p[0][2] = ColorAlgorithm.transformResultToHeight(stencilData[2].values[dataIndex], max_iterations);
            }
            if(stencilData[3] != null) {
                p[1][0] = ColorAlgorithm.transformResultToHeight(stencilData[3].values[dataIndex], max_iterations);
            }
            if(stencilData[4] != null) {
                p[1][1] = ColorAlgorithm.transformResultToHeight(stencilData[4].values[dataIndex], max_iterations);
            }
            if(stencilData[5] != null) {
                p[1][2] = ColorAlgorithm.transformResultToHeight(stencilData[5].values[dataIndex], max_iterations);
            }
            if(stencilData[6] != null) {
                p[2][0] = ColorAlgorithm.transformResultToHeight(stencilData[6].values[dataIndex], max_iterations);
            }
            if(stencilData[7] != null) {
                p[2][1] = ColorAlgorithm.transformResultToHeight(stencilData[7].values[dataIndex], max_iterations);
            }
            if(stencilData[8] != null) {
                p[2][2] = ColorAlgorithm.transformResultToHeight(stencilData[8].values[dataIndex], max_iterations);
            }

        }
        else {
            p[0][0] = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j - 1, k_m1_m1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
            p[0][1] = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j, k_m1_0, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
            p[0][2] = ColorAlgorithm.transformResultToHeight(getIterData(i - 1, j + 1, k_m1_p1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);

            p[1][0] = ColorAlgorithm.transformResultToHeight(getIterData(i, j - 1, k_0_m1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
            p[1][1] = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);
            p[1][2] = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, k_0_p1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);

            p[2][0] = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j - 1, k_p1_m1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
            p[2][1] = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, k_p1_0, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
            p[2][2] = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j + 1, k_p1_p1, image_iterations, image_width, image_height, location, false, ninf), max_iterations);
        }

        // reflect at boundaries if necessary
        // this will break (result is infinite or NaN) for image size of 1 pixel
        if(p[0][0] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i - 1, j - 1, 13, 0, 1);
//                px[0][0] = res[0];
//                py[0][0] = res[1];
//            }

            px[0][0] -= 1;py[0][0] -= 1;
        }

        if(p[0][1] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i - 1, j, 13, 0, 1);
//                px[0][1] = res[0];
//                py[0][1] = res[1];
//            }
            px[0][1] -= 1;
        }
        if(p[0][2] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i - 1, j + 1, 13, 0, 1);
//                px[0][2] = res[0];
//                py[0][2] = res[1];
//            }
            px[0][2] -= 1;py[0][2] += 1;
        }
        if(p[1][0] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i, j - 1, 13, 0, 1);
//                px[1][0] = res[0];
//                py[1][0] = res[1];
//            }
            py[1][0] -= 1;
        }

//        if(p[1][1] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i, j, 13, 0, 1);
//                px[1][1] = res[0];
//                py[1][1] = res[1];
//            }
//        }

        if(p[1][2] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i, j + 1, 13, 0, 1);
//                px[1][2] = res[0];
//                py[1][2] = res[1];
//            }
            py[1][2] += 1;
        }
        if(p[2][0] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i + 1, j - 1, 13, 0, 1);
//                px[2][0] = res[0];
//                py[2][0] = res[1];
//            }
            px[2][0] += 1;py[2][0] -= 1;
        }
        if(p[2][1] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i + 1, j, 13, 0, 1);
//                px[2][1] = res[0];
//                py[2][1] = res[1];
//            }
            px[2][1] += 1;
        }
        if(p[2][2] != ninf) {
//            if(ndes.useJitter) {
//                double[] res = Location.GetPixelOffset(i + 1, j + 1, 13, 0, 1);
//                px[2][2] = res[0];
//                py[2][2] = res[1];
//            }
            px[2][2] += 1;py[2][2] += 1;
        }

        p[1][1] *= 2.0;
        px[1][1] *= 2.0;
        py[1][1] *= 2.0;

        if (ninf == p[0][0]) {p[0][0] = p[1][1] - p[2][2];px[0][0] = px[1][1] - px[2][2];py[0][0] = py[1][1] - py[2][2];}
        if (ninf == p[0][1]) {p[0][1] = p[1][1] - p[2][1];px[0][1] = px[1][1] - px[2][1];py[0][1] = py[1][1] - py[2][1];}
        if (ninf == p[0][2]) {p[0][2] = p[1][1] - p[2][0];px[0][2] = px[1][1] - px[2][0];py[0][2] = py[1][1] - py[2][0];}
        if (ninf == p[1][0]) {p[1][0] = p[1][1] - p[1][2];px[1][0] = px[1][1] - px[1][2];py[1][0] = py[1][1] - py[1][2];}
        if (ninf == p[1][2]) {p[1][2] = p[1][1] - p[1][0];px[1][2] = px[1][1] - px[1][0];py[1][2] = py[1][1] - py[1][0];}
        if (ninf == p[2][0]) {p[2][0] = p[1][1] - p[0][2];px[2][0] = px[1][1] - px[0][2];py[2][0] = py[1][1] - py[0][2];}
        if (ninf == p[2][1]) {p[2][1] = p[1][1] - p[0][1];px[2][1] = px[1][1] - px[0][1];py[2][1] = py[1][1] - py[0][1];}
        if (ninf == p[2][2]) {p[2][2] = p[1][1] - p[0][0];px[2][2] = px[1][1] - px[0][0];py[2][2] = py[1][1] - py[0][0];}
        p[1][1] *= 0.5;
        px[1][1] *= 0.5;
        py[1][1] *= 0.5;

        return new double[][][] {p, px, py};

    }

    private double[] compute_gradient_2x2(double[][] p, double[][] px, double[][] py)
    {
        // find weighted average of function values
        double num = 0, den = 0;
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j)
            {
                double qx = px[i][j] + 0.5;
                double qy = py[i][j] + 0.5;
                double w = 1 / (qx * qx + qy * qy + 1e-100);
                num += w * p[i][j];
                den += w;
            }
        double p0 = num / den;
        // initialize system A x = b for solving x = [ dF/dx ; dF/dy ]
        double[][] A = new double[4][2];
        double[] b = new double[4];
        int k = 0;
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j)
            {
                A[k][0] = px[i][j] + 0.5;
                A[k][1] = py[i][j] + 0.5;
                b[k] = p[i][j] - p0;
                ++k;
            }
        // least-squares solve overdetermined A x = b via QR decomposition

        QRDecomposition decomposition = new QRDecomposition(new Array2DRowRealMatrix(A));
        RealVector result = decomposition.getSolver().solve(new ArrayRealVector(b));
        return new double[] {result.getEntry(0), result.getEntry(1)};
    }
    private double[] compute_gradient_3x3(double[][] p, double[][] px, double[][] py)
    {
        double p0 = p[1][1];
        // initialize system A x = b for solving x = [ dF/dx ; dF/dy ]
        double[][] A = new double[8][2];
        double[] b = new double[8];
        int k = 0;
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
            {
                if (i == 1 && j == 1) continue;
                A[k][0] = px[i][j] - px[1][1];
                A[k][1] = py[i][j] - py[1][1];
                b[k] = p[i][j] - p0;
                ++k;
            }

        QRDecomposition decomposition = new QRDecomposition(new Array2DRowRealMatrix(A));
        RealVector result = decomposition.getSolver().solve(new ArrayRealVector(b));
        return new double[] {result.getEntry(0), result.getEntry(1)};
    }


    private int[] numerical_distance_estimator(double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, Location location, AntialiasingAlgorithm aa, boolean[] escaped) {

        int k0 = image_width * i + j;

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;

        PixelExtraData[] stencilData = new PixelExtraData[9];

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            stencilData[4] = dataK0;
        }

        for(int m = 0; m < output.length; m++) {


            if(data != null && output.length > 1) {

                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(dataK0.values[m])) {
                    output[m] = getStandardColor(dataK0.values[m], dataK0.escaped[m]);
                    continue;
                }
            }
            else {
                if ((!ots.useTraps || !ots.trapIncludeNotEscaped) && !usesTrueColorIn && isMaximumIterations(image_iterations[k0])) {
                    output[m] = getStandardColor(image_iterations[k0], escaped[k0]);
                    continue;
                }
            }

            double[][][] stencils = create_stencil(i, j, k0, image_width, image_height, image_iterations, location, data, stencilData, data != null && output.length > 1, aa, m);
            double[][] p = stencils[0];
            double[][] px = stencils[1];
            double[][] py = stencils[2];

            double G = 0;

            switch (ndes.differencesMethod) {
                case 6:
                    // gerrit: Laplacian is proportional to g^2: https://fractalforums.org/kalles-fraktaler/15/gaussian-jitter-for-moire-reduction/891/msg5563#msg5563
                    double L = 0;
                    L +=  1 * p[0][0];
                    L +=  4 * p[0][1];
                    L +=  1 * p[0][2];
                    L +=  4 * p[1][0];
                    L -= 20 * p[1][1];
                    L +=  4 * p[1][2];
                    L +=  1 * p[2][0];
                    L +=  4 * p[2][1];
                    L +=  1 * p[2][2];
                    L /=  6;
                    G = Math.sqrt(Math.abs(L * 1.4426950408889634));
                    G *= 2.8284271247461903;
                    break;
                case 5:
                    double[] result = compute_gradient_3x3(p, px, py);
                    G = hypot1(result[0], result[1]);
                    G *= 2.8284271247461903;
                    break;
                case 4:
                    result = compute_gradient_2x2(p, px, py);
                    G = hypot1(result[0], result[1]);
                    G *= 2.8284271247461903;
                    break;
                case 2:
                    // gerrit's central difference formula
                    double gx = sqr(p[2][1] - p[0][1]) / hypot2(px[2][1] - px[0][1], py[2][1] - py[0][1]);
                    double gy = sqr(p[1][2] - p[1][0]) / hypot2(px[1][2] - px[1][0], py[1][2] - py[1][0]);
                    double g1 = sqr(p[2][2] - p[0][0]) / hypot2(px[2][2] - px[0][0], py[2][2] - py[0][0]);
                    double g2 = sqr(p[0][2] - p[2][0]) / hypot2(px[0][2] - px[2][0], py[0][2] - py[2][0]);
                    G = Math.sqrt(0.5 * (gx + gy + g1 + g2));
                    G *= 2.8284271247461903;
                    break;
                case 1:
                    // forward differencing in 8 directions from the target point
                    double gx0 = sqr(p[0][1] - p[1][1]) / hypot2(px[0][1] - px[1][1], py[0][1] - py[1][1]);
                    double gx2 = sqr(p[2][1] - p[1][1]) / hypot2(px[2][1] - px[1][1], py[2][1] - py[1][1]);
                    double gy0 = sqr(p[1][0] - p[1][1]) / hypot2(px[1][0] - px[1][1], py[1][0] - py[1][1]);
                    double gy2 = sqr(p[1][2] - p[1][1]) / hypot2(px[1][2] - px[1][1], py[1][2] - py[1][1]);
                    double gu0 = sqr(p[0][0] - p[1][1]) / hypot2(px[0][0] - px[1][1], py[0][0] - py[1][1]);
                    double gu2 = sqr(p[2][2] - p[1][1]) / hypot2(px[2][2] - px[1][1], py[2][2] - py[1][1]);
                    double gv0 = sqr(p[2][0] - p[1][1]) / hypot2(px[2][0] - px[1][1], py[2][0] - py[1][1]);
                    double gv2 = sqr(p[0][2] - p[1][1]) / hypot2(px[0][2] - px[1][1], py[0][2] - py[1][1]);
                    G = Math.sqrt(0.25 * (gx0 + gx2 + gy0 + gy2 + gu0 + gu2 + gv0 + gv2));
                    G *= 2.8284271247461903;
                    break;
                case 3:
                    // forward differencing in 2 diagonals of a 2x2 substencil
//                    if(ndes.useJitter) {
//                        // with displacement correction by gerrit
//                        double nux = px[0][0] - px[1][1];
//                        double nuy = py[0][0] - py[1][1];
//                        double nvx = px[1][0] - px[0][1];
//                        double nvy = py[1][0] - py[0][1];
//                        double nu = hypot1(nux, nuy);
//                        double nv = hypot1(nvx, nvy);
//                        nux /= nu;
//                        nuy /= nu;
//                        nvx /= nv;
//                        nvy /= nv;
//                        double u = (p[0][0] - p[1][1]) / nu;
//                        double v = (p[1][0] - p[0][1]) / nv;
//                        double dotnunv = nux * nvx + nuy * nvy;
//                        double crossnunv = nux * nvy - nuy * nvx;
//                        G = Math.sqrt((u * u + v * v - 2 * u * v * dotnunv) / sqr(crossnunv));
//                        G *= 2.8284271247461903;
//                    }
//                    else {
                        double gu = sqr(p[0][0] - p[1][1]) / hypot2(px[0][0] - px[1][1], py[0][0] - py[1][1]);
                        double gv = sqr(p[0][1] - p[1][0]) / hypot2(px[0][1] - px[1][0], py[0][1] - py[1][0]);
                        G = Math.sqrt(gu + gv);
                        G *= 2.8284271247461903;
                    //}
                    break;
                case 0:
                    // traditional method reverse engineered from original code
                    gx = (p[0][1] - p[1][1]) * 1.41421356237 / Math.hypot(px[0][1] - px[1][1], py[0][1] - py[1][1]);
                    gy = (p[1][0] - p[1][1]) * 1.41421356237 / Math.hypot(px[1][0] - px[1][1], py[1][0] - py[1][1]);
                    gu = (p[0][0] - p[1][1]) * 1.41421356237 / Math.hypot(px[0][0] - px[1][1], py[0][0] - py[1][1]);
                    gv = (p[0][2] - p[1][1]) * 1.41421356237 / Math.hypot(px[0][2] - px[1][1], py[0][2] - py[1][1]);
                    G = Math.abs(gx) + Math.abs(gy) + Math.abs(gu) + Math.abs(gv);
                    break;
//                case 7:
//					/* idea from this paper, hackily extended to arbitrary (jittered) mesh
//							Isotropic finite-differences
//							AnandKumar
//							https://doi.org/10.1016/j.jcp.2004.05.005
//					*/
//                    gx0 =     (p[2][0] - p[0][0]) / hypot1(px[2][0] - px[0][0], py[2][0] - py[0][0]);
//                    double gx1 = 4 * (p[2][1] - p[0][1]) / hypot1(px[2][1] - px[0][1], py[2][1] - py[0][1]);
//                    gx2 =     (p[2][2] - p[0][2]) / hypot1(px[2][2] - px[0][2], py[2][2] - py[0][2]);
//                    gy0 =     (p[0][2] - p[0][0]) / hypot1(px[0][2] - px[0][0], py[0][2] - py[0][0]);
//                    double gy1 = 4 * (p[1][2] - p[1][0]) / hypot1(px[1][2] - px[1][0], py[1][2] - py[1][0]);
//                    gy2 =     (p[2][2] - p[2][0]) / hypot1(px[2][2] - px[2][0], py[2][2] - py[2][0]);
//                    gx = (gx0 + gx1 + gx2) / 6;
//                    gy = (gy0 + gy1 + gy2) / 6;
//                    G = hypot1(gx, gy);
//                    break;
            }

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            double finalG = G * ndes.distanceFactor;

            int temp_color;
            if(data != null && output.length > 1) {

                if(ndes.cap_to_palette_length) {
                    finalG = Math.min(finalG, getPaletteLength(dataK0.escaped[m]) - 1);
                }

                temp_color = getStandardColor(finalG + ndes.distanceOffset, dataK0.escaped[m]);
            }
            else {

                if(ndes.cap_to_palette_length) {
                    finalG = Math.min(finalG, getPaletteLength(escaped[k0]) - 1);
                }

                temp_color = getStandardColor(finalG + ndes.distanceOffset, escaped[k0]);
            }

            int temp_red = (temp_color >> 16) & 0xFF;
            int temp_green = (temp_color >> 8) & 0xFF;
            int temp_blue = temp_color & 0xFF;

            output[m] = ndes_blending.blend(r, g, b, temp_red, temp_green, temp_blue, 1 - ndes.numerical_blending);

        }

        return output;

    }

    private int[] slopes(double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, Location location, AntialiasingAlgorithm aa) {

        int k0 = image_width * i + j;

        int kx = k0 + 1;

        if (location == null && j == image_width - 1) {
            kx -= 2;
        }

        int ky = k0 + image_width;

        if (location == null && i == image_height - 1) {
            ky -= 2 * image_width;
        }

        int[] output = new int[colors.length];

        PixelExtraData dataK0 = null;
        PixelExtraData dataKx = null;
        PixelExtraData dataKy = null;

        if(data != null && output.length > 1) {
            dataK0 = data[k0];
            dataKx = getIterData(i, j + 1, kx, data, image_width, image_height, location, aa, true);
            dataKy = getIterData(i + 1, j, ky, data, image_width, image_height, location, aa, true);
        }

        for(int m = 0; m < output.length; m++) {

            double h00, h10, h01;

            if(data != null && output.length > 1) {
                h00 = ColorAlgorithm.transformResultToHeight(dataK0.values[m], max_iterations);
                h10 = ColorAlgorithm.transformResultToHeight(dataKx.values[m], max_iterations);
                h01 = ColorAlgorithm.transformResultToHeight(dataKy.values[m], max_iterations);
            }
            else {
                h00 = ColorAlgorithm.transformResultToHeight(image_iterations[k0], max_iterations);
                h10 = ColorAlgorithm.transformResultToHeight(getIterData(i, j + 1, kx, image_iterations, image_width, image_height, location, true), max_iterations);
                h01 = ColorAlgorithm.transformResultToHeight(getIterData(i + 1, j, ky, image_iterations, image_width, image_height, location, true), max_iterations);
            }


            h00 = height_transfer_slopes(h00);
            h10 = height_transfer_slopes(h10);
            h01 = height_transfer_slopes(h01);

            double diffx = h10 - h00;
            double diffy = h01 - h00;

            double lx = ss.lightVector[0];
            double ly = -ss.lightVector[1];


            double diff = diffx * lx + diffy * ly;
            diff *= ss.SlopePower;

            boolean diffWasPositive = true;
            if (diff >= 0){
                diff = Math.atan(diff) * pi2;
                diff = diff * ss.SlopeRatio;
                diffWasPositive = true;

                diff = ColorSpaceConverter.clamp(diff);
            }
            else{
                diffWasPositive = false;
                diff = -diff;
                diff = Math.atan(diff) * pi2;
                diff = diff * ss.SlopeRatio;

                diff = ColorSpaceConverter.clamp(diff);

            }

            int r = (colors[m] >> 16) & 0xFF;
            int g = (colors[m] >> 8) & 0xFF;
            int b = colors[m] & 0xFF;

            if (ss.colorMode == 0) { //Lab
                double[] res = ColorSpaceConverter.RGBtoLAB(r, g, b);
                double val = diffWasPositive ? (1 - diff) * res[0] : (1 - diff) * res[0] + diff * 100;
                int[] rgb = ColorSpaceConverter.LABtoRGB(val, res[1], res[2]);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ss.colorMode == 1) { //HSB
                double[] res = ColorSpaceConverter.RGBtoHSB(r, g, b);

                double val = diffWasPositive ? (1 - diff) * res[2] : (1 - diff) * res[2] + diff;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ss.colorMode == 2) { //HSL
                double[] res = ColorSpaceConverter.RGBtoHSL(r, g, b);

                double val = diffWasPositive ? (1 - diff) * res[2] : (1 - diff) * res[2] + diff;

                if (val > 1) {
                    val = 1;
                }
                if (val < 0) {
                    val = 0;
                }

                int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            } else if (ss.colorMode == 3) { //Blending

                double val = diffWasPositive ? (1 - diff) : (1 - diff) + diff;

                int index = (int) ((1 - val) * (gradient.length - 1) + 0.5);
                index = gradient.length - 1 - index;

                int grad_color = getGradientColor(index + gradient_offset);

                int temp_red = (grad_color >> 16) & 0xff;
                int temp_green = (grad_color >> 8) & 0xff;
                int temp_blue = grad_color & 0xff;

                int new_color = blending.blend(temp_red, temp_green, temp_blue, r, g, b, 1 - ss.slope_blending);

                r = (new_color >> 16) & 0xFF;
                g = (new_color >> 8) & 0xFF;
                b = new_color & 0xFF;

                output[m] = 0xff000000 | (r << 16) | (g << 8) | b;
            } else if (ss.colorMode == 4) { //scaling
                if(diffWasPositive) {
                    r = (int)((1 - diff)*r + 0.5);
                    g = (int)((1 - diff)*g + 0.5);
                    b = (int)((1 - diff)*b + 0.5);
                }
                else {
                    r = (int)((1 - diff)*r + diff * 255 + 0.5);
                    g = (int)((1 - diff)*g + diff * 255 + 0.5);
                    b = (int)((1 - diff)*b + diff * 255 + 0.5);
                }

                if (r > 255) {
                    r = 255;
                }
                if (g > 255) {
                    g = 255;
                }
                if (b > 255) {
                    b = 255;
                }

                if (r < 0) {
                    r = 0;
                }
                if (g < 0) {
                    g = 0;
                }
                if (b < 0) {
                    b = 0;
                }

                output[m] = 0xff000000 | (r << 16) | (g << 8) | b;
            }
            else {
                double[] res = ColorSpaceConverter.RGBtoOKLAB(r, g, b);
                double val = diffWasPositive ? (1 - diff) * res[0] : (1 - diff) * res[0] + diff;
                int[] rgb = ColorSpaceConverter.OKLABtoRGB(val, res[1], res[2]);
                output[m] = 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
            }

        }

        return output;

    }

    protected void renderSquares(int image_width, int image_height) {

        int white = 0xffffffff;
        int grey = 0xffAAAAAA;

        int colA = white;
        int colB = grey;

        int length = 14;
        for (int y = FROMy; y < TOy; y++) {

            if (y % length < length / 2) {
                colA = white;
                colB = grey;
            } else {
                colB = white;
                colA = grey;
            }

            for (int x = FROMx, loc = y * image_width + x; x < TOx; x++, loc++) {
                if (rgbs[loc] == 0x00ffffff) {
                    if (x % length < length / 2) {
                        rgbs[loc] = colA;
                    } else {
                        rgbs[loc] = colB;
                    }

                }
            }
        }
    }

    double Sigmoid(double x) {
        return (1.0/ (1.0+Math.exp(-x/10.0)))-0.5;
    }
    public double T(double x) {
        return 2.0* Sigmoid(Math.abs(x+1./x));
    }

    private double calaculateDomainColoringHeight(double res) {

        //res = Math.abs(res + 1 / res);
        //res = 1 / (1 + Math.exp(-res));
        //res = (res / (res + 1));

        if (Double.isInfinite(res)) {
            res = 10000000;
        }
        return (res > 10000000 ? 10000000 : res);

    }

    protected double getDomainHeight(Complex a) {

        double val = 0;
        switch (ds.domain_height_method) {
            case 0:
                val = a.norm();
                break;
            case 1:
                val = a.getRe();
                break;
            case 2:
                val = a.getIm();
                break;
            case 3:
                val = a.getRe() + a.getIm();
                break;
        }

        if(ds.domain_height_normalization_method == 1) {
            double dr = Math.abs(T(val));
            return dr * 4.0 * (Sigmoid(Math.log(Math.abs(val)))); //Taken from fragmentarium for domain lifting
        }
        return val;
    }

    private double capValue(double val, double upperFence, double lowerFence) {
        val = val > upperFence ? upperFence : val;
        val = val < lowerFence ? lowerFence : val;
        return val;
    }

    protected int[] applyScalingToPixel(int index, int[] colors, PixelExtraData[] data, int mapping, double[] image_iterations, boolean[] escaped) {

        int[] output = new int[colors.length];
        for(int j = 0; j < output.length; j++) {
            double val;
            boolean esc;
            if(data != null && output.length > 1) {
                val = data[index].values[j];
                esc = data[index].escaped[j];
            }
            else {
                val = image_iterations[index];
                esc = escaped[index];
            }

            if (Double.isNaN(val) || Double.isInfinite(val) || isMaximumIterations(val)) {
                continue;
            }

            double sign = val >= 0 ? 1 : -1;

            double tempVal = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

            if (esc) {
                tempVal = capValue(tempVal, upperFenceEscaped, lowerFenceEscaped);
                switch (mapping) {
                    case 1:
                        val = (tempVal - minIterationsEscaped) / (maxIterationEscaped - minIterationsEscaped);
                        break;
                    case 2:
                        val = (Math.sqrt(tempVal) - Math.sqrt(minIterationsEscaped)) / (Math.sqrt(maxIterationEscaped) - Math.sqrt(minIterationsEscaped));
                        break;
                    case 3:
                        val = (Math.cbrt(tempVal) - Math.cbrt(minIterationsEscaped)) / (Math.cbrt(maxIterationEscaped) - Math.cbrt(minIterationsEscaped));
                        break;
                    case 4:
                        val = (Math.sqrt(Math.sqrt(tempVal)) - Math.sqrt(Math.sqrt(minIterationsEscaped))) / (Math.sqrt(Math.sqrt(maxIterationEscaped)) - Math.sqrt(Math.sqrt(minIterationsEscaped)));
                        break;
                    case 5:
                        val = (Math.log(tempVal) - Math.log(minIterationsEscaped)) / (Math.log(maxIterationEscaped) - Math.log(minIterationsEscaped));
                        break;
                }

            } else {
                tempVal = capValue(tempVal, upperFenceNotEscaped, lowerFenceNotEscaped);
                switch (mapping) {
                    case 1:
                        val = (tempVal - minIterationsNotEscaped) / (maxIterationNotEscaped - minIterationsNotEscaped);
                        break;
                    case 2:
                        val = (Math.sqrt(tempVal) - Math.sqrt(minIterationsNotEscaped)) / (Math.sqrt(maxIterationNotEscaped) - Math.sqrt(minIterationsNotEscaped));
                        break;
                    case 3:
                        val = (Math.cbrt(tempVal) - Math.cbrt(minIterationsNotEscaped)) / (Math.cbrt(maxIterationNotEscaped) - Math.cbrt(minIterationsNotEscaped));
                        break;
                    case 4:
                        val = (Math.sqrt(Math.sqrt(tempVal)) - Math.sqrt(Math.sqrt(minIterationsNotEscaped))) / (Math.sqrt(Math.sqrt(maxIterationNotEscaped)) - Math.sqrt(Math.sqrt(minIterationsNotEscaped)));
                        break;
                    case 5:
                        val = (Math.log(tempVal) - Math.log(minIterationsNotEscaped)) / (Math.log(maxIterationNotEscaped) - Math.log(minIterationsNotEscaped));
                        break;
                }
            }

            val = (hss.histogramScaleMax - hss.histogramScaleMin) * val + hss.histogramScaleMin;
            val *= sign;

            val *= (getPaletteLength(esc) - 1);

            int original_color = colors[j];

            int r = (original_color >> 16) & 0xFF;
            int g = (original_color >> 8) & 0xFF;
            int b = original_color & 0xFF;

            int modified = getStandardColor(val, esc);

            int fc_red = (modified >> 16) & 0xFF;
            int fc_green = (modified >> 8) & 0xFF;
            int fc_blue = modified & 0xFF;

            double coef = 1 - hss.hs_blending;

            output[j] = hss_blending.blend(r, g, b, fc_red, fc_green, fc_blue, coef);
        }

        return output;
    }

    private int closestPoint(double[] array, double target) {
        int left = 0;
        int right = array.length - 1;

        while (left <= right) {
            int mid = (int)(((long)left + right) >>> 1);

            if (array[mid] == target) {
                return mid;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return right;
    }

    protected int[] applyHistogramToPixel(int index, int[] colors, PixelExtraData[] data, int histogramGranularity, double histogramDensity, double[] image_iterations, boolean[] escaped) {

        int[] output = new int[colors.length];

        for(int j = 0; j < output.length; j++) {

            double val;
            boolean esc;
            if(data != null && output.length > 1) {
                val = data[index].values[j];
                esc = data[index].escaped[j];
            }
            else {
               val = image_iterations[index];
               esc = escaped[index];
            }


            if (Double.isNaN(val) || Double.isInfinite(val) || isMaximumIterations(val)) {
                continue;
            }

            double sign = val >= 0 ? 1 : -1;

            double tempVal = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));
            double diff = 0;

            long valIndex = 0;
            if (esc) {
                tempVal = capValue(tempVal, upperFenceEscaped, lowerFenceEscaped);
                diff = tempVal - minIterationsEscaped;
                valIndex = (long) ((diff) / denominatorEscaped * histogramGranularity);
            } else {
                tempVal = capValue(tempVal, upperFenceNotEscaped, lowerFenceNotEscaped);
                diff = tempVal - minIterationsNotEscaped;
                valIndex = (long) ((diff) / denominatorNotEscaped * histogramGranularity);
            }
            int[] array = esc ? escapedCounts : notEscapedCounts;


            int valIndexInt = valIndex >= array.length ? array.length - 1 : (int)valIndex;
            double sum = array[valIndexInt];

            double sumNext = sum;

            //Find the next cdf val that is greater from the old
            for (int i = valIndexInt + 1; i < array.length; i++) {
                if (array[i] > sum) {
                    sumNext = array[i];
                    break;
                }
            }

            double g1, g2;

            if (esc) {
                double cdfMinEscaped = escapedCounts[0];
                g1 = 1.0 - Math.pow(1.0 - ((sum - cdfMinEscaped) / (totalEscaped - cdfMinEscaped)), 1.0 / histogramDensity);
                g2 = 1.0 - Math.pow(1.0 - ((sumNext - cdfMinEscaped) / (totalEscaped - cdfMinEscaped)), 1.0 / histogramDensity);
            } else {
                double cdfMinNotEscaped = notEscapedCounts[0];
                g1 = 1.0 - Math.pow(1.0 - ((sum - cdfMinNotEscaped) / (totalNotEscaped - cdfMinNotEscaped)), 1.0 / histogramDensity);
                g2 = 1.0 - Math.pow(1.0 - ((sumNext - cdfMinNotEscaped) / (totalNotEscaped - cdfMinNotEscaped)), 1.0 / histogramDensity);
            }

            double fractionalPart;

            if (esc) {
                fractionalPart = MathUtils.fract((diff) / denominatorEscaped * histogramGranularity);
            } else {
                fractionalPart = MathUtils.fract((diff) / denominatorNotEscaped * histogramGranularity);
            }

            g1 = method.interpolate(g1, g2, fractionalPart);

            g1 = (hss.histogramScaleMax - hss.histogramScaleMin) * g1 + hss.histogramScaleMin;

            val = sign * g1;

            if (Double.isNaN(val) || Double.isInfinite(val)) {
                continue;
            }

            val *= (getPaletteLength(esc) - 1);

            int original_color = colors[j];
            int r = (original_color >> 16) & 0xFF;
            int g = (original_color >> 8) & 0xFF;
            int b = original_color & 0xFF;

            int modified = getStandardColor(val, esc);

            int fc_red = (modified >> 16) & 0xFF;
            int fc_green = (modified >> 8) & 0xFF;
            int fc_blue = modified & 0xFF;

            double coef = 1 - hss.hs_blending;

            output[j] = hss_blending.blend(r, g, b, fc_red, fc_green, fc_blue, coef);
        }

        return output;
    }

    protected int[] applyRankOrderMappingToPixel(int index, int[] colors, PixelExtraData[] data, double[] image_iterations, boolean[] escaped) {

        int[] output = new int[colors.length];

        for(int j = 0; j < output.length; j++) {

            double val;
            boolean esc;
            if(data != null && output.length > 1) {
                val = data[index].values[j];
                esc = data[index].escaped[j];
            }
            else {
                val = image_iterations[index];
                esc = escaped[index];
            }

            if (Double.isNaN(val) || Double.isInfinite(val) || isMaximumIterations(val)) {
                continue;
            }

            double sign = val >= 0 ? 1 : -1;

            double tempVal = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

            if (esc) {
                tempVal = capValue(tempVal, upperFenceEscaped, lowerFenceEscaped);
            } else {
                tempVal = capValue(tempVal, upperFenceNotEscaped, lowerFenceNotEscaped);
            }

            double originalVal = tempVal;
            tempVal = roundForRankOrder(tempVal);

            double g1;

            if (esc) {
                int i = closestPoint(arrayEscaped, tempVal);

                if(i != -1) {
                    if(arrayEscaped[i] == tempVal) {
                        g1 = (double) i / (arrayEscaped.length - 1);
                    }
                    else if(i + 1 >= arrayEscaped.length) {
                        g1 = 1.0;
                    }
                    else {
                        double in = i + ((originalVal - arrayEscaped[i])/(arrayEscaped[i + 1] - arrayEscaped[i]));
                        g1 = in / (arrayEscaped.length - 1);
                    }
                }
                else {
                    g1 = 0;
                }

            } else {
                int i = closestPoint(arraynotEscaped, tempVal);

                if(i != -1) {
                    if(arraynotEscaped[i] == tempVal) {
                        g1 = (double)i / (arraynotEscaped.length - 1);
                    }
                    else if(i + 1 >= arraynotEscaped.length) {
                        g1 = 1.0;
                    }
                    else {
                        double in = i + ((originalVal - arraynotEscaped[i])/(arraynotEscaped[i + 1] - arraynotEscaped[i]));
                        g1 = in / (arraynotEscaped.length - 1);
                    }
                }
                else {
                    g1 = 0;
                }
            }

            g1 = (hss.histogramScaleMax - hss.histogramScaleMin) * g1 + hss.histogramScaleMin;

            val = sign * g1;

            if (Double.isNaN(val) || Double.isInfinite(val)) {
                continue;
            }

            val *= (getPaletteLength(esc) - 1);

            int original_color = colors[j];

            int r = (original_color >> 16) & 0xFF;
            int g = (original_color >> 8) & 0xFF;
            int b = original_color & 0xFF;

            int modified = getStandardColor(val, esc);

            int fc_red = (modified >> 16) & 0xFF;
            int fc_green = (modified >> 8) & 0xFF;
            int fc_blue = modified & 0xFF;

            double coef = 1 - hss.hs_blending;

            output[j] = hss_blending.blend(r, g, b, fc_red, fc_green, fc_blue, coef);

        }

        return output;
    }

    private double[] getFencesDouble(ArrayList<Double> data) {

        if(data.isEmpty()) {
            return new double[] {-Double.MAX_VALUE, Double.MAX_VALUE};
        }

        Collections.sort(data);

        //double median = calculateMedianDouble(data, 0, data.size());
        double lower_quartile = calculateMedianDouble(data, 0, data.size() / 2);
        double upper_quartile = calculateMedianDouble(data, (data.size() + 1) / 2, data.size());
        double iqr = upper_quartile - lower_quartile;

        if(iqr == 0) {
            double mean = 0;
            double variance = 0;
            int samples = 0;
            for (int i = 0; i < data.size(); i++) {
                samples++;
                double val = data.get(i);
                double delta =  val - mean;
                mean += delta / samples;
                double delta2 = val - mean;
                variance += delta * delta2;
            }
            double sigma = Math.sqrt(variance / samples);
            double temp = 3 * sigma;
            return  new double[] {mean - temp, mean + temp};
        }
        else {
            double temp = 1.5 * iqr;
            return  new double[] {lower_quartile - temp, upper_quartile + temp};
        }
    }

    private double[] getFences(ArrayList<Double> data) {

        if(data.isEmpty()) {
            return new double[] {-Double.MAX_VALUE, Double.MAX_VALUE};
        }
        
        Collections.sort(data);

        //double median = calculateMedian(data, 0, data.size());
        double lower_quartile = calculateMedian(data, 0, data.size() / 2);
        double upper_quartile = calculateMedian(data, (data.size() + 1) / 2, data.size());
        double iqr = upper_quartile - lower_quartile;

        if(iqr == 0) {
            double mean = 0;
            double variance = 0;
            int samples = 0;
            for (int i = 0; i < data.size(); i++) {
                samples++;
                double val = data.get(i);
                double delta =  val - mean;
                mean += delta / samples;
                double delta2 = val - mean;
                variance += delta * delta2;
            }
            double sigma = Math.sqrt(variance / samples);
            double temp = 3 * sigma;
            return  new double[] {mean - temp, mean + temp};
        }
        else {
            double temp = 1.5 * iqr;
            return  new double[] {lower_quartile - temp, upper_quartile + temp};
        }
    }

    public static boolean INCLUDE_AA_DATA_ON_RANK_ORDER = false;

    private double roundForRankOrder(double val) {
        if(hss.rank_order_digits_grouping == 0) {
            return Math.floor(val + 0.5);
        }
        else if(hss.rank_order_digits_grouping == 1) {
            return Math.floor(10 * val + 0.5) / 10;
        }
        else if(hss.rank_order_digits_grouping == 2) {
            return Math.floor(100 * val + 0.5) / 100;
        }
        else if(hss.rank_order_digits_grouping == 3) {
            return Math.floor(1000 * val + 0.5) / 1000;
        }
        else if(hss.rank_order_digits_grouping == 4) {
            return Math.floor(10000 * val + 0.5) / 10000;
        }
        else if(hss.rank_order_digits_grouping == 5) {
            return Math.floor(100000 * val + 0.5) / 100000;
        }
        else if(hss.rank_order_digits_grouping == 6) {
            return Math.floor(1000000 * val + 0.5) / 1000000;
        }

        return Math.floor(10000000 * val + 0.5) / 10000000;
    }

    private void initializeHistogramColoring(double[] image_iterations, boolean[] escaped) {

        int mapping = hss.hmapping;
        int histogramGranularity = hss.histogramBinGranularity;

        try {
            if (normalize_find_ranges_sync.await() == 0) {

                lowerFenceEscaped = -Double.MAX_VALUE;
                upperFenceEscaped = Double.MAX_VALUE;


                lowerFenceNotEscaped = -Double.MAX_VALUE;
                upperFenceNotEscaped = Double.MAX_VALUE;

                if(hss.hs_remove_outliers) {
                    //Remove outliers first
                    double meanEscaped = 0;
                    double meanNotEscaped = 0;
                    double varianceEscaped = 0;
                    double varianceNotEscaped = 0;
                    int samples = 0;
                    ArrayList<Double> dataEscaped = null;
                    ArrayList<Double> dataNotEscaped = null;

                    if(hss.hs_outliers_method == 0) {
                        dataEscaped = new ArrayList<>();
                        dataNotEscaped = new ArrayList<>();
                    }

                    for (int i = 0; i < image_iterations.length; i++) {

                        double val = image_iterations[i];

                        if (isMaximumIterations(val)) {
                            continue;
                        }

                        if (Double.isNaN(val) || Double.isInfinite(val)) {
                            continue;
                        }

                        val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                        samples++;
                        if (escaped[i]) {

                            if(hss.hs_outliers_method == 0) {
                                dataEscaped.add(val);
                            }
                            else {
                                double delta = val - meanEscaped;
                                meanEscaped += delta / samples;
                                double delta2 = val - meanEscaped;
                                varianceEscaped += delta * delta2;
                            }

                        } else {

                            if(hss.hs_outliers_method == 0) {
                                dataNotEscaped.add(val);
                            }
                            else {
                                double delta = val - meanNotEscaped;
                                meanNotEscaped += delta / samples;
                                double delta2 = val - meanNotEscaped;
                                varianceNotEscaped += delta * delta2;
                            }
                        }
                    }

                    if(hss.hs_outliers_method == 0) {
                        double[] res = getFencesDouble(dataEscaped);
                        lowerFenceEscaped = res[0];
                        upperFenceEscaped = res[1];


                        double[] res2 = getFencesDouble(dataNotEscaped);
                        lowerFenceNotEscaped = res2[0];
                        upperFenceNotEscaped = res2[1];
                    }
                    else {
                        double sigmaEscaped = Math.sqrt(varianceEscaped / samples);
                        double sigmaNotEscaped = Math.sqrt(varianceNotEscaped / samples);

                        upperFenceEscaped = meanEscaped + 3 * sigmaEscaped;
                        lowerFenceEscaped = meanEscaped - 3 * sigmaEscaped;

                        upperFenceNotEscaped = meanNotEscaped + 3 * sigmaNotEscaped;
                        lowerFenceNotEscaped = meanNotEscaped - 3 * sigmaNotEscaped;
                    }

                    if(hss.hs_outliers_method == 0) {
                        dataEscaped.clear();
                        dataNotEscaped.clear();
                    }
                }

                maxIterationEscaped = -Double.MAX_VALUE;
                maxIterationNotEscaped = -Double.MAX_VALUE;
                totalEscaped = 0;
                totalNotEscaped = 0;
                minIterationsEscaped = Double.MAX_VALUE;
                minIterationsNotEscaped = Double.MAX_VALUE;
                denominatorEscaped = 1;
                denominatorNotEscaped = 1;

                if(mapping != 6) {
                    for (int i = 0; i < image_iterations.length; i++) {

                        double val = image_iterations[i];

                        if (isMaximumIterations(val)) {
                            continue;
                        }

                        if (Double.isNaN(val) || Double.isInfinite(val)) {
                            continue;
                        }

                        val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                        if (escaped[i]) {

                            val = capValue(val, upperFenceEscaped, lowerFenceEscaped);

                            maxIterationEscaped = val > maxIterationEscaped ? val : maxIterationEscaped;
                            minIterationsEscaped = val < minIterationsEscaped ? val : minIterationsEscaped;
                        } else {

                            val = capValue(val, upperFenceNotEscaped, lowerFenceNotEscaped);

                            maxIterationNotEscaped = val > maxIterationNotEscaped ? val : maxIterationNotEscaped;
                            minIterationsNotEscaped = val < minIterationsNotEscaped ? val : minIterationsNotEscaped;
                        }
                    }
                }

                if (mapping == 0 || mapping == 6) {

                    if(mapping == 0) {
                        if (maxIterationEscaped != -Double.MAX_VALUE && minIterationsEscaped != Double.MAX_VALUE) {
                            double diff = maxIterationEscaped - minIterationsEscaped;
                            long total = ((long)((diff + 1) * histogramGranularity));
                            total = total > Integer.MAX_VALUE ? Integer.MAX_VALUE : total;
                            escapedCounts = new int[(int)total];
                        }

                        if (maxIterationNotEscaped != -Double.MAX_VALUE && minIterationsNotEscaped != Double.MAX_VALUE) {
                            double diff = maxIterationNotEscaped - minIterationsNotEscaped;
                            long total = ((long)((diff + 1) * histogramGranularity));
                            total = total > Integer.MAX_VALUE ? Integer.MAX_VALUE : total;
                            notEscapedCounts = new int[(int)total];
                        }

                        if (maxIterationEscaped < 1 && minIterationsEscaped < 1) {
                            denominatorEscaped = maxIterationEscaped - minIterationsEscaped + 1e-12;
                        }

                        if (maxIterationNotEscaped < 1 && minIterationsNotEscaped < 1) {
                            denominatorNotEscaped = maxIterationNotEscaped - minIterationsNotEscaped + 1e-12;
                        }
                    }

                    Set<Double> setEscaped = new HashSet<>();
                    Set<Double> setnotEscaped = new HashSet<>();
                    ArrayList<Double> listEscaped;
                    ArrayList<Double> listnotEscaped;


                    for (int i = 0; i < image_iterations.length; i++) {
                        double val = image_iterations[i];

                        if (isMaximumIterations(val)) {
                            continue;
                        }

                        if (Double.isNaN(val) || Double.isInfinite(val)) {
                            continue;
                        }

                        val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                        if (escaped[i]) {
                            val = capValue(val, upperFenceEscaped, lowerFenceEscaped);

                            if(mapping == 6) {
                                setEscaped.add(roundForRankOrder(val));
                            }
                            else {
                                double diff = val - minIterationsEscaped;
                                long id = (long) ((diff) / denominatorEscaped * histogramGranularity);
                                id = id >= escapedCounts.length ? escapedCounts.length - 1 : id;
                                escapedCounts[(int)id]++;
                            }
                            totalEscaped++;
                        } else {

                            val = capValue(val, upperFenceNotEscaped, lowerFenceNotEscaped);
                            if(mapping == 6) {
                                setnotEscaped.add(roundForRankOrder(val));
                            }
                            else {
                                double diff = val - minIterationsNotEscaped;
                                long id = (long) ((diff) / denominatorNotEscaped * histogramGranularity);
                                id = id >= notEscapedCounts.length ? notEscapedCounts.length - 1 : id;
                                notEscapedCounts[(int)id]++;
                            }
                            totalNotEscaped++;
                        }
                    }

                    if(mapping == 0) {
                        if (escapedCounts != null) {
                            double sum = 0;
                            for (int i = 0; i < escapedCounts.length; i++) {
                                escapedCounts[i] += sum;
                                sum = escapedCounts[i];
                            }
                        }

                        if (notEscapedCounts != null) {
                            double sum = 0;
                            for (int i = 0; i < notEscapedCounts.length; i++) {
                                notEscapedCounts[i] += sum;
                                sum = notEscapedCounts[i];
                            }
                        }
                    }
                    else if(mapping == 6) {
                        listEscaped = new ArrayList<>(setEscaped);
                        setEscaped.clear();
                        listnotEscaped = new ArrayList<>(setnotEscaped);
                        setnotEscaped.clear();

                        arrayEscaped = listEscaped.stream().mapToDouble(Double::doubleValue).toArray();
                        arraynotEscaped = listnotEscaped.stream().mapToDouble(Double::doubleValue).toArray();

                        Arrays.parallelSort(arrayEscaped);
                        Arrays.parallelSort(arraynotEscaped);

                        listEscaped.clear();
                        listnotEscaped.clear();
                    }
                }
            }
        } catch (InterruptedException e) {

        } catch (BrokenBarrierException e) {

        }

        try {
            normalize_sync.await();
        } catch (InterruptedException ex) {

        } catch (BrokenBarrierException ex) {

        }

    }

    private void initializeHistogramColoring(PixelExtraData[] data) {

        int mapping = hss.hmapping;
        int histogramGranularity = hss.histogramBinGranularity;

        try {
            if (normalize_find_ranges_sync.await() == 0) {

                lowerFenceEscaped = -Double.MAX_VALUE;
                upperFenceEscaped = Double.MAX_VALUE;


                lowerFenceNotEscaped = -Double.MAX_VALUE;
                upperFenceNotEscaped = Double.MAX_VALUE;

                if(hss.hs_remove_outliers) {
                    //Remove outliers first
                    double meanEscaped = 0;
                    double meanNotEscaped = 0;
                    double varianceEscaped = 0;
                    double varianceNotEscaped = 0;
                    int samples = 0;
                    ArrayList<Double> dataEscaped = null;
                    ArrayList<Double> dataNotEscaped = null;

                    if(hss.hs_outliers_method == 0) {
                        dataEscaped = new ArrayList<>();
                        dataNotEscaped = new ArrayList<>();
                    }

                    for(int j = 0; j < data.length; j++) {
                        for (int i = 0; i < data[j].values.length; i++) {

                            double val = data[j].values[i];

                            if (isMaximumIterations(val)) {
                                continue;
                            }

                            if (Double.isNaN(val) || Double.isInfinite(val)) {
                                continue;
                            }

                            val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                            samples++;
                            if (data[j].escaped[i]) {

                                if (hss.hs_outliers_method == 0) {
                                    dataEscaped.add(val);
                                } else {
                                    double delta = val - meanEscaped;
                                    meanEscaped += delta / samples;
                                    double delta2 = val - meanEscaped;
                                    varianceEscaped += delta * delta2;
                                }

                            } else {

                                if (hss.hs_outliers_method == 0) {
                                    dataNotEscaped.add(val);
                                } else {
                                    double delta = val - meanNotEscaped;
                                    meanNotEscaped += delta / samples;
                                    double delta2 = val - meanNotEscaped;
                                    varianceNotEscaped += delta * delta2;
                                }
                            }
                        }
                    }

                    if(hss.hs_outliers_method == 0) {
                        double[] res = getFencesDouble(dataEscaped);
                        lowerFenceEscaped = res[0];
                        upperFenceEscaped = res[1];


                        double[] res2 = getFencesDouble(dataNotEscaped);
                        lowerFenceNotEscaped = res2[0];
                        upperFenceNotEscaped = res2[1];
                    }
                    else {
                        double sigmaEscaped = Math.sqrt(varianceEscaped / samples);
                        double sigmaNotEscaped = Math.sqrt(varianceNotEscaped / samples);

                        upperFenceEscaped = meanEscaped + 3 * sigmaEscaped;
                        lowerFenceEscaped = meanEscaped - 3 * sigmaEscaped;

                        upperFenceNotEscaped = meanNotEscaped + 3 * sigmaNotEscaped;
                        lowerFenceNotEscaped = meanNotEscaped - 3 * sigmaNotEscaped;
                    }

                    if(hss.hs_outliers_method == 0) {
                        dataEscaped.clear();
                        dataNotEscaped.clear();
                    }
                }

                maxIterationEscaped = -Double.MAX_VALUE;
                maxIterationNotEscaped = -Double.MAX_VALUE;
                totalEscaped = 0;
                totalNotEscaped = 0;
                minIterationsEscaped = Double.MAX_VALUE;
                minIterationsNotEscaped = Double.MAX_VALUE;
                denominatorEscaped = 1;
                denominatorNotEscaped = 1;

                if(mapping != 6) {

                    for (int j = 0; j < data.length; j++) {
                        for (int i = 0; i < data[j].values.length; i++) {

                            double val = data[j].values[i];

                            if (isMaximumIterations(val)) {
                                continue;
                            }

                            if (Double.isNaN(val) || Double.isInfinite(val)) {
                                continue;
                            }

                            val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                            if (data[j].escaped[i]) {

                                val = capValue(val, upperFenceEscaped, lowerFenceEscaped);

                                maxIterationEscaped = val > maxIterationEscaped ? val : maxIterationEscaped;
                                minIterationsEscaped = val < minIterationsEscaped ? val : minIterationsEscaped;
                            } else {

                                val = capValue(val, upperFenceNotEscaped, lowerFenceNotEscaped);

                                maxIterationNotEscaped = val > maxIterationNotEscaped ? val : maxIterationNotEscaped;
                                minIterationsNotEscaped = val < minIterationsNotEscaped ? val : minIterationsNotEscaped;
                            }
                        }
                    }
                }

                if (mapping == 0 || mapping == 6) {

                    if(mapping == 0) {
                        if (maxIterationEscaped != -Double.MAX_VALUE && minIterationsEscaped != Double.MAX_VALUE) {
                            double diff = maxIterationEscaped - minIterationsEscaped;
                            long total = ((long)((diff + 1) * histogramGranularity));
                            total = total > Integer.MAX_VALUE ? Integer.MAX_VALUE : total;
                            escapedCounts = new int[(int)total];
                        }

                        if (maxIterationNotEscaped != -Double.MAX_VALUE && minIterationsNotEscaped != Double.MAX_VALUE) {
                            double diff = maxIterationNotEscaped - minIterationsNotEscaped;
                            long total = ((long)((diff + 1) * histogramGranularity));
                            total = total > Integer.MAX_VALUE ? Integer.MAX_VALUE : total;
                            notEscapedCounts = new int[(int)total];
                        }

                        if (maxIterationEscaped < 1 && minIterationsEscaped < 1) {
                            denominatorEscaped = maxIterationEscaped - minIterationsEscaped + 1e-12;
                        }

                        if (maxIterationNotEscaped < 1 && minIterationsNotEscaped < 1) {
                            denominatorNotEscaped = maxIterationNotEscaped - minIterationsNotEscaped + 1e-12;
                        }
                    }

                    Set<Double> setEscaped = new HashSet<>();
                    Set<Double> setnotEscaped = new HashSet<>();
                    ArrayList<Double> listEscaped;
                    ArrayList<Double> listnotEscaped;

                    for(int j = 0; j < data.length; j++) {
                        int length;
                        if(mapping == 6 && INCLUDE_AA_DATA_ON_RANK_ORDER) {
                            length = data[j].values.length;
                        }
                        else {
                            length = mapping == 6 ? Math.min(1, data[j].values.length) : data[j].values.length;
                        }
                        for (int i = 0; i < length; i++) {
                            double val = data[j].values[i];

                            if (isMaximumIterations(val)) {
                                continue;
                            }

                            if (Double.isNaN(val) || Double.isInfinite(val)) {
                                continue;
                            }

                            val = Math.abs(ColorAlgorithm.transformResultToHeight(val, max_iterations));

                            if (data[j].escaped[i]) {
                                val = capValue(val, upperFenceEscaped, lowerFenceEscaped);

                                if(mapping == 6) {
                                    setEscaped.add(roundForRankOrder(val));
                                }
                                else {
                                    double diff = val - minIterationsEscaped;
                                    long id = (long) ((diff) / denominatorEscaped * histogramGranularity);
                                    id = id >= escapedCounts.length ? escapedCounts.length - 1 : id;
                                    escapedCounts[(int)id]++;
                                }
                                totalEscaped++;
                            } else {
                                val = capValue(val, upperFenceNotEscaped, lowerFenceNotEscaped);
                                if(mapping == 6) {
                                    setnotEscaped.add(roundForRankOrder(val));
                                }
                                else {
                                    double diff = val - minIterationsNotEscaped;
                                    long id = (long) ((diff) / denominatorNotEscaped * histogramGranularity);
                                    id = id >= notEscapedCounts.length ? notEscapedCounts.length - 1 : id;
                                    notEscapedCounts[(int)id]++;
                                }

                                totalNotEscaped++;
                            }
                        }
                    }

                    if(mapping == 0) {
                        if (escapedCounts != null) {
                            double sum = 0;
                            for (int i = 0; i < escapedCounts.length; i++) {
                                escapedCounts[i] += sum;
                                sum = escapedCounts[i];
                            }
                        }

                        if (notEscapedCounts != null) {
                            double sum = 0;
                            for (int i = 0; i < notEscapedCounts.length; i++) {
                                notEscapedCounts[i] += sum;
                                sum = notEscapedCounts[i];
                            }
                        }
                    }
                    else if(mapping == 6) {
                        listEscaped = new ArrayList<>(setEscaped);
                        setEscaped.clear();
                        listnotEscaped = new ArrayList<>(setnotEscaped);
                        setnotEscaped.clear();

                        arrayEscaped = listEscaped.stream().mapToDouble(Double::doubleValue).toArray();
                        arraynotEscaped = listnotEscaped.stream().mapToDouble(Double::doubleValue).toArray();

                        Arrays.parallelSort(arrayEscaped);
                        Arrays.parallelSort(arraynotEscaped);

                        listEscaped.clear();
                        listnotEscaped.clear();
                    }
                }
            }
        } catch (InterruptedException e) {

        } catch (BrokenBarrierException e) {

        }

        try {
            normalize_sync.await();
        } catch (InterruptedException ex) {

        } catch (BrokenBarrierException ex) {

        }

    }

    private int[] finalizeHistogramColoring(double[] image_iterations, PixelExtraData[] data, int[] colors, int i, int j, int image_width, int image_height, boolean[] escaped) {

        double histogramDensity = hss.histogramDensity;
        int mapping = hss.hmapping;
        int histogramGranularity = hss.histogramBinGranularity;
        if(mapping == 0) {
            return applyHistogramToPixel(i * image_width + j, colors, data, histogramGranularity, histogramDensity, image_iterations, escaped);
        }
        else if(mapping == 6) {
            return applyRankOrderMappingToPixel(i * image_width + j, colors, data, image_iterations, escaped);
        }
        else {
            return applyScalingToPixel(i * image_width + j, colors, data, mapping, image_iterations, escaped);
        }

    }

    public static String getDefaultInitialValue() {

        return default_init_val;

    }

    public static double getConvergentBailout() {

        return convergent_bailout;

    }

    public static void setDomainImageData(int width, int height, boolean mode) {

        if (mode && ((domain_image_data_re == null && domain_image_data_im == null) || (domain_image_data_re.length != width * height && domain_image_data_im.length != width * height))) {
            domain_image_data_re = new double[width * height];
            domain_image_data_im = new double[width * height];
        } else if (!mode) {
            domain_image_data_re = null;
            domain_image_data_im = null;
        }

    }

    protected static PixelExtraData[] pixelData;
    protected static PixelExtraData[] pixelData_fast_julia;
    public static void setArrays(int width, int height, boolean usesDomainColoring, boolean needsExtraData) {

        WIDTH = width;
        HEIGHT = height;

        vert = null;
        vert_color = null;
        vert1 = null;
        Norm1z = null;

        if(image_iterations == null || image_iterations.length != width * height) {
            image_iterations = new double[width * height];
            escaped = new boolean[width * height];
        }

        if(image_iterations_fast_julia == null || image_iterations_fast_julia.length != FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE) {
            image_iterations_fast_julia = new double[FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE];
            escaped_fast_julia = new boolean[FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE];
        }

        if(needsExtraData) {
            if((pixelData == null || pixelData.length != width * height)) {
                pixelData = new PixelExtraData[width * height];
                for (int i = 0; i < pixelData.length; i++) {
                    pixelData[i] = new PixelExtraData();
                }
            }

            if((pixelData_fast_julia == null || pixelData_fast_julia.length != FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE)) {
                pixelData_fast_julia = new PixelExtraData[FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE];
                for (int i = 0; i < pixelData_fast_julia.length; i++) {
                    pixelData_fast_julia[i] = new PixelExtraData();
                }
            }
        }
        else {
            pixelData = null;
            pixelData_fast_julia = null;
        }

        if (usesDomainColoring) {
            if(domain_image_data_re == null || domain_image_data_re.length != width * height) {
                domain_image_data_re = new double[width * height];
                domain_image_data_im = new double[width * height];
            }
        }
        else {
            domain_image_data_re = null;
            domain_image_data_im = null;
        }
    }

    public static void setArraysExpander(int width, int height, boolean needsExtraData) {

        WIDTH = width;
        HEIGHT = height;


        if(image_iterations == null || image_iterations.length != width * height) {
            image_iterations = new double[width * height];
            escaped = new boolean[width * height];
        }

        domain_image_data_re = null;
        domain_image_data_im = null;

        if(needsExtraData) {
            if((pixelData == null || pixelData.length != width * height)) {
                pixelData = new PixelExtraData[width * height];
                for (int i = 0; i < pixelData.length; i++) {
                    pixelData[i] = new PixelExtraData();
                }
            }
        }
        else {
            pixelData = null;
        }

    }

    public static void set3DArrays(int detail, boolean needsExtraData) {

        WIDTH = detail;
        HEIGHT = detail;

        image_iterations_fast_julia = null;
        escaped_fast_julia = null;
        domain_image_data_re = null;
        domain_image_data_im = null;

        vert = new double[detail][detail];
        vert_color = new int[detail][detail];
        vert1 = new float[detail][detail][2];
        Norm1z = new float[detail][detail][2];


        if(image_iterations == null || image_iterations.length != detail * detail) {
            image_iterations = new double[detail * detail];
            escaped = new boolean[detail * detail];
        }

        if(needsExtraData) {
            if((pixelData == null || pixelData.length != detail * detail)) {
                pixelData = new PixelExtraData[detail * detail];
                for (int i = 0; i < pixelData.length; i++) {
                    pixelData[i] = new PixelExtraData();
                }
            }
        }
        else {
            pixelData = null;
        }

    }

    public static boolean hasExtraData(int width, int height) {
        return pixelData != null && pixelData.length == width * height && pixelData[0].rgb_values != null
                && pixelData[0].values != null && pixelData[0].escaped != null;
    }

    public static void setExtraDataArrays(boolean needsExtraData, int width, int height) {
        if(needsExtraData) {
            if((pixelData == null || pixelData.length != width * height)) {
                pixelData = new PixelExtraData[width * height];
                for (int i = 0; i < pixelData.length; i++) {
                    pixelData[i] = new PixelExtraData();
                }
            }

            if((pixelData_fast_julia == null || pixelData_fast_julia.length != FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE)) {
                pixelData_fast_julia = new PixelExtraData[FAST_JULIA_IMAGE_SIZE * FAST_JULIA_IMAGE_SIZE];
                for (int i = 0; i < pixelData_fast_julia.length; i++) {
                    pixelData_fast_julia[i] = new PixelExtraData();
                }
            }
        }
        else {
            pixelData = null;
            pixelData_fast_julia = null;
        }
    }

    public static void resetTaskData(int num_tasks, boolean createFullImageAfterPreview) {

        STOP_SUCCESSIVE_REFINEMENT = false;
        DONE = false;
        number_of_tasks = new AtomicInteger(num_tasks);
        finalize_sync = new AtomicInteger(0);
        total_calculated = new LongAdder();
        total_calculated_extra = new LongAdder();
        total_completed = new LongAdder();
        total_post_processed = new LongAdder();
        total_pixel_grouping = new LongAdder[MAX_GROUPING];
        for(int i = 0; i < total_pixel_grouping.length; i++) {
            total_pixel_grouping[i] = new LongAdder();
        }
        max_pixel_calculation_time = new LongAccumulator(Math::max, Long.MIN_VALUE);
        PostProcessingCalculationTime = new LongAccumulator(Math::max, Long.MIN_VALUE);
        post_processing_sync = new CyclicBarrier(num_tasks);
        calculate_vectors_sync = new CyclicBarrier(num_tasks);
        painting_sync = new AtomicInteger(0);
        height_scaling_sync = new AtomicInteger(0);
        height_scaling_sync2 = new CyclicBarrier(num_tasks);
        height_scaling_sync3 = new AtomicInteger(0);
        height_scaling_sync4 = new CyclicBarrier(num_tasks);
        height_function_sync = new CyclicBarrier(num_tasks);
        gaussian_scaling_sync = new AtomicInteger(0);
        remove_outliers_sync = new AtomicInteger(0);
        remove_outliers_sync3 = new AtomicInteger(0);
        gaussian_scaling_sync2 = new CyclicBarrier(num_tasks);
        remove_outliers_sync2 = new CyclicBarrier(num_tasks);
        remove_outliers_sync4 = new CyclicBarrier(num_tasks);
        normal_rendering_algorithm_pixel = new AtomicInteger(0);
        normal_rendering_algorithm_pixel2 = new AtomicInteger(0);
        apply_skipped_color_pixel = new AtomicInteger(0);
        render_squares_pixel = new AtomicInteger(0);
        quick_render_rendering_algorithm_pixel = new AtomicInteger[SUCCESSIVE_REFINEMENT_EXPONENT];
        for(int i = 0; i < quick_render_rendering_algorithm_pixel.length; i++) {
            quick_render_rendering_algorithm_pixel[i] = new AtomicInteger(0);
        }

        successive_refinement_rendering_algorithm_pixel = new AtomicInteger[2 * (SUCCESSIVE_REFINEMENT_EXPONENT + 1)];
        for(int i = 0; i < successive_refinement_rendering_algorithm_pixel.length; i++) {
            successive_refinement_rendering_algorithm_pixel[i] = new AtomicInteger(0);
        }

        successive_refinement_rendering_algorithm2_pixel = new AtomicInteger[2 * (2 * SUCCESSIVE_REFINEMENT_EXPONENT + 1)];
        for(int i = 0; i < successive_refinement_rendering_algorithm2_pixel.length; i++) {
            successive_refinement_rendering_algorithm2_pixel[i] = new AtomicInteger(0);
        }

        quick_render_rendering_algorithm_barrier = new CyclicBarrier(num_tasks);
        successive_refinement_rendering_algorithm_barrier = new CyclicBarrier(num_tasks);
        normal_rendering_algorithm_post_processing = new AtomicInteger(0);
        normal_rendering_algorithm_post_processing2 = new AtomicInteger(0);
        normal_rendering_algorithm_apply_palette = new AtomicInteger(0);
        normal_rendering_algorithm_apply_palette2 = new AtomicInteger(0);
        normal_rendering_algorithm_histogram = new AtomicInteger(0);
        color_cycling_filters_sync = new CyclicBarrier(num_tasks);
        color_cycling_restart_sync = new CyclicBarrier(num_tasks);
        shade_color_height_sync = new CyclicBarrier(num_tasks);
        initialize_jobs_sync = new CyclicBarrier(num_tasks);
        normalize_find_ranges_sync = new CyclicBarrier(num_tasks);
        normalize_sync = new CyclicBarrier(num_tasks);
        normalize_sync2 = new CyclicBarrier(num_tasks);
        normalize_find_ranges_sync_3d = new CyclicBarrier(num_tasks);
        color_cycling_toggle_lock = new ReadWriteLock();
        successive_refinement_lock = new ReadWriteLock();

        reference_calc_sync = new AtomicInteger(0);
        reference_sync = new CyclicBarrier(num_tasks);

        if(!createFullImageAfterPreview) {
            RootColoring.roots.clear();
        }

        Fractal.ReferenceCalculationTime = 0;
        Fractal.SecondReferenceCalculationTime = 0;
        Fractal.SACalculationTime = 0;
        Fractal.BLACalculationTime = 0;
        Fractal.Nanomb1CalculationTime = 0;
        D3RenderingCalculationTime = 0;
        FilterCalculationTime = 0;

    }

    public void setTaskId(int taskId) {

        this.taskId = taskId;

    }

    public void setCreatePreview(boolean val) {
        createPreview = val;
    }

    public void setZoomToCursor(boolean val) {
        zoomToCursor = val;
    }

    public void setCreateFullImageAfterPreview(boolean val) {
        createFullImageAfterPreview = val;
    }

    public void colorTransferFactory(int transfer_function_out, int transfer_function_in, double color_intensity_out, double color_intensity_in, double color_density_out, double color_density_in) {

        switch (transfer_function_out) {

            case MainWindow.DEFAULT:
                color_transfer_outcoloring = new DefaultTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out);
                break;
            case MainWindow.SQUARE_ROOT:
                color_transfer_outcoloring = new SqrtTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.CUBE_ROOT:
                color_transfer_outcoloring = new CbrtTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.FOURTH_ROOT:
                color_transfer_outcoloring = new ForthrtTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.LOGARITHM:
                color_transfer_outcoloring = new LogarithmTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.LOG_LOG:
                color_transfer_outcoloring = new LogLogTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.ATAN:
                color_transfer_outcoloring = new AtanTransferFunction(palette_outcoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
            case MainWindow.LINEAR:
                color_transfer_outcoloring = new LinearTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_out, color_density_out);
                break;
        }


        switch (transfer_function_in) {

            case MainWindow.DEFAULT:
                color_transfer_incoloring = new DefaultTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in);
                break;
            case MainWindow.SQUARE_ROOT:
                color_transfer_incoloring = new SqrtTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.CUBE_ROOT:
                color_transfer_incoloring = new CbrtTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.FOURTH_ROOT:
                color_transfer_incoloring = new ForthrtTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.LOGARITHM:
                color_transfer_incoloring = new LogarithmTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.LOG_LOG:
                color_transfer_incoloring = new LogLogTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.ATAN:
                color_transfer_incoloring = new AtanTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
            case MainWindow.LINEAR:
                color_transfer_incoloring = new LinearTransferFunction(palette_incoloring.getPaletteLength(), color_intensity_in, color_density_in);
                break;
        }

    }

    private int getModifiedColor(int red, int green, int blue, double coef, int colorMethod, double colorBlending, boolean reverseBlending) {

        if (colorMethod == 0) { //Lab
            double[] res = ColorSpaceConverter.RGBtoLAB(red, green, blue);
            double val = contourFactor * coef * res[0];
            val = val > 100 ? 100 : val;
            int[] rgb = ColorSpaceConverter.LABtoRGB(val, res[1], res[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (colorMethod == 1) { //HSB
            double[] res = ColorSpaceConverter.RGBtoHSB(red, green, blue);
            double val = contourFactor * coef * res[2];
            val = val > 1 ? 1 : val;
            int[] rgb = ColorSpaceConverter.HSBtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (colorMethod == 2) { //HSL
            double[] res = ColorSpaceConverter.RGBtoHSL(red, green, blue);
            double val = contourFactor * coef * res[2];
            val = val > 1 ? 1 : val;
            int[] rgb = ColorSpaceConverter.HSLtoRGB(res[0], res[1], val);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        } else if (colorMethod == 3) {// blend
            int index = (int) (coef * (gradient.length - 1) + 0.5);

            if (reverseBlending) {
                index = gradient.length - 1 - index;
            }

            int grad_color = getGradientColor(index + gradient_offset);

            int temp_red = (grad_color >> 16) & 0xff;
            int temp_green = (grad_color >> 8) & 0xff;
            int temp_blue = grad_color & 0xff;

            return blending.blend(temp_red, temp_green, temp_blue, red, green, blue, colorBlending);
        } else if (colorMethod == 4) { //scale
            red = (int) (contourFactor * coef * red + 0.5);
            green = (int) (contourFactor * coef * green + 0.5);
            blue = (int) (contourFactor * coef * blue + 0.5);
            red = red > 255 ? 255 : red;
            green = green > 255 ? 255 : green;
            blue = blue > 255 ? 255 : blue;
            return 0xff000000 | (red << 16) | (green << 8) | blue;
        }
        else {
            double[] res = ColorSpaceConverter.RGBtoOKLAB(red, green, blue);
            double val = contourFactor * coef * res[0];
            val = val > 1 ? 1 : val;
            int[] rgb = ColorSpaceConverter.OKLABtoRGB(val, res[1], res[2]);
            return 0xff000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        }
    }

    public double scaleDomainHeight(double norm) {

        if (ds.domainProcessingTransfer == 0) {
            return norm * ds.domainProcessingHeightFactor;
        } else {
            return 1 / (norm * ds.domainProcessingHeightFactor);
        }

    }

    private void interpolationFactory(int color_interpolation) {

        method = InterpolationMethod.create(color_interpolation);

    }

    private Fractal fractalFactory(int function, double xCenter, double yCenter, Apfloat dsize, double size, int max_iterations, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, String perturbation_user_formula, boolean init_val, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, String initial_value_user_formula, int plane_type, double[] rotation_vals, double[] rotation_center, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, double z_exponent, double[] z_exponent_complex, double[] coefficients, double[] coefficients_im, double[] z_exponent_nova, double[] relaxation, int nova_method, int bail_technique, String user_formula, String user_formula2, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, GenericCaZbdZeSettings gcs, String[] lyapunovExpression, OrbitTrapSettings ots, boolean exterior_de, double exterior_de_factor, boolean inverse_dem, int escaping_smooth_algorithm, int converging_smooth_algorithm, StatisticsSettings sts, boolean useLyapunovExponent, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, double[] kleinianLine, double kleinianK, double kleinianM, double[] laguerre_deg, double[] durand_kernel_init_val, MagneticPendulumSettings mps, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_relaxation_formula, String user_nova_addend_formula, GenericCpAZpBCSettings gcps, InertiaGravityFractalSettings igs, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs, String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, int root_initialization_method, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean defaultNovaInitialValue, ConvergentBailoutConditionSettings cbs, boolean useGlobalMethod, double[] globalMethodFactor, int period, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower) {

        Fractal fractal = null;

        switch (function) {
            case MainWindow.MANDELBROT:
                fractal = new Mandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, ots, sts, height_ratio);
                break;
            case MainWindow.MANDELBROTCUBED:
                fractal = new MandelbrotCubed(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTFOURTH:
                fractal = new MandelbrotFourth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTFIFTH:
                fractal = new MandelbrotFifth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTSIXTH:
                fractal = new MandelbrotSixth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTSEVENTH:
                fractal = new MandelbrotSeventh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTEIGHTH:
                fractal = new MandelbrotEighth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTNINTH:
                fractal = new MandelbrotNinth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTTENTH:
                fractal = new MandelbrotTenth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTNTH:
                fractal = new MandelbrotNth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, z_exponent, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBROTWTH:
                fractal = new MandelbrotWth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, z_exponent_complex, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELPOLY:
                fractal = new MandelbrotPoly(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, burning_ship, mandel_grass, mandel_grass_vals, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.LAMBDA:
                fractal = new Lambda(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAMBDA2:
                fractal = new Lambda2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAMBDA3:
                fractal = new Lambda3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAMBDA_FN_FN:
                fractal = new LambdaFnFn(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, lfns);
                break;
            case MainWindow.MAGNET1:
                fractal = new Magnet1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET13:
                fractal = new Magnet13(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET14:
                fractal = new Magnet14(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET2:
                fractal = new Magnet2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET23:
                fractal = new Magnet23(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET24:
                fractal = new Magnet24(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON3:
                fractal = new Newton3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON4:
                fractal = new Newton4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTONGENERALIZED3:
                fractal = new NewtonGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTONGENERALIZED8:
                fractal = new NewtonGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTONSIN:
                fractal = new NewtonSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTONCOS:
                fractal = new NewtonCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTONPOLY:
                fractal = new NewtonPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.NEWTONFORMULA:
                fractal = new NewtonFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.BARNSLEY1:
                fractal = new Barnsley1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BARNSLEY2:
                fractal = new Barnsley2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BARNSLEY3:
                fractal = new Barnsley3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANDELBAR:
                fractal = new Mandelbar(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SPIDER:
                fractal = new Spider(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MANOWAR:
                fractal = new Manowar(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PHOENIX:
                fractal = new Phoenix(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIERPINSKI_GASKET:
                fractal = new SierpinskiGasket(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KLEINIAN:
                fractal = new Kleinian(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, kleinianLine, kleinianK, kleinianM, sts);
                break;
            case MainWindow.HALLEY3:
                fractal = new Halley3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEY4:
                fractal = new Halley4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEYGENERALIZED3:
                fractal = new HalleyGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEYGENERALIZED8:
                fractal = new HalleyGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEYSIN:
                fractal = new HalleySin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEYCOS:
                fractal = new HalleyCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HALLEYPOLY:
                fractal = new HalleyPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HALLEYFORMULA:
                fractal = new HalleyFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.SCHRODER3:
                fractal = new Schroder3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODER4:
                fractal = new Schroder4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODERGENERALIZED3:
                fractal = new SchroderGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODERGENERALIZED8:
                fractal = new SchroderGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODERSIN:
                fractal = new SchroderSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODERCOS:
                fractal = new SchroderCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SCHRODERPOLY:
                fractal = new SchroderPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.SCHRODERFORMULA:
                fractal = new SchroderFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3:
                fractal = new Householder3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER4:
                fractal = new Householder4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDERGENERALIZED3:
                fractal = new HouseholderGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDERGENERALIZED8:
                fractal = new HouseholderGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDERSIN:
                fractal = new HouseholderSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDERCOS:
                fractal = new HouseholderCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDERPOLY:
                fractal = new HouseholderPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HOUSEHOLDERFORMULA:
                fractal = new HouseholderFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.SECANT3:
                fractal = new Secant3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SECANT4:
                fractal = new Secant4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SECANTGENERALIZED3:
                fractal = new SecantGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SECANTGENERALIZED8:
                fractal = new SecantGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SECANTCOS:
                fractal = new SecantCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SECANTPOLY:
                fractal = new SecantPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.SECANTFORMULA:
                fractal = new SecantFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, ots, sts);
                break;
            case MainWindow.STEFFENSEN3:
                fractal = new Steffensen3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STEFFENSEN4:
                fractal = new Steffensen4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STEFFENSENGENERALIZED3:
                fractal = new SteffensenGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STEFFENSENPOLY:
                fractal = new SteffensenPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.STEFFENSENFORMULA:
                fractal = new SteffensenFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, ots, sts);
                break;
            case MainWindow.NOVA:
                fractal = new Nova(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, z_exponent_nova, relaxation, nova_method, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, newton_hines_k, defaultNovaInitialValue);
                break;
            case MainWindow.EXP:
                fractal = new Exp(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LOG:
                fractal = new Log(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIN:
                fractal = new Sin(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COS:
                fractal = new Cos(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TAN:
                fractal = new Tan(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COT:
                fractal = new Cot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SINH:
                fractal = new Sinh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COSH:
                fractal = new Cosh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TANH:
                fractal = new Tanh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COTH:
                fractal = new Coth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA30:
                fractal = new Formula30(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA31:
                fractal = new Formula31(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA1:
                fractal = new Formula1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA2:
                fractal = new Formula2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA3:
                fractal = new Formula3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA4:
                fractal = new Formula4(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA5:
                fractal = new Formula5(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA6:
                fractal = new Formula6(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA7:
                fractal = new Formula7(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA8:
                fractal = new Formula8(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA9:
                fractal = new Formula9(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA10:
                fractal = new Formula10(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA11:
                fractal = new Formula11(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA12:
                fractal = new Formula12(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA13:
                fractal = new Formula13(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA14:
                fractal = new Formula14(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA15:
                fractal = new Formula15(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA16:
                fractal = new Formula16(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA17:
                fractal = new Formula17(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA18:
                fractal = new Formula18(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA19:
                fractal = new Formula19(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA20:
                fractal = new Formula20(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA21:
                fractal = new Formula21(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA22:
                fractal = new Formula22(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA23:
                fractal = new Formula23(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA24:
                fractal = new Formula24(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA25:
                fractal = new Formula25(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA26:
                fractal = new Formula26(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA27:
                fractal = new Formula27(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA28:
                fractal = new Formula28(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA29:
                fractal = new Formula29(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA32:
                fractal = new Formula32(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA33:
                fractal = new Formula33(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA34:
                fractal = new Formula34(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA35:
                fractal = new Formula35(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA36:
                fractal = new Formula36(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA37:
                fractal = new Formula37(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA38:
                fractal = new Formula38(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA39:
                fractal = new Formula39(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA40:
                fractal = new Formula40(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA41:
                fractal = new Formula41(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA42:
                fractal = new Formula42(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA43:
                fractal = new Formula43(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA44:
                fractal = new Formula44(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA45:
                fractal = new Formula45(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA46:
                fractal = new Formula46(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA47:
                fractal = new Formula47(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FORMULA48:
                fractal = new Formula48(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PERPENDICULAR_MANDELBROT:
                fractal = new PerpendicularMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BUFFALO_MANDELBROT:
                fractal = new BuffaloMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CELTIC_MANDELBROT:
                fractal = new CelticMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PERPENDICULAR_BURNING_SHIP:
                fractal = new PerpendicularBurningShip(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PERPENDICULAR_CELTIC_MANDELBROT:
                fractal = new PerpendicularCelticMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PERPENDICULAR_BUFFALO_MANDELBROT:
                fractal = new PerpendicularBuffaloMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.USER_FORMULA:
                if (bail_technique == 0) {
                    fractal = new UserFormulaEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                }
                else {
                    fractal = new UserFormulaEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                }
                break;
            case MainWindow.USER_FORMULA_ITERATION_BASED:
                if (bail_technique == 0) {
                    fractal = new UserFormulaIterationBasedEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaIterationBasedConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                }
                else {
                    fractal = new UserFormulaIterationBasedEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                }
                break;
            case MainWindow.USER_FORMULA_CONDITIONAL:
                if (bail_technique == 0) {
                    fractal = new UserFormulaConditionalEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaConditionalConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                }
                else {
                    fractal = new UserFormulaConditionalEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts);
                }
                break;
            case MainWindow.USER_FORMULA_COUPLED:
                if (bail_technique == 0) {
                    fractal = new UserFormulaCoupledEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaCoupledConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts);
                }
                else {
                    fractal = new UserFormulaCoupledEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts);
                }
                break;
            case MainWindow.FROTHY_BASIN:
                fractal = new FrothyBasin(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SZEGEDI_BUTTERFLY1:
                fractal = new SzegediButterfly1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SZEGEDI_BUTTERFLY2:
                fractal = new SzegediButterfly2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COUPLED_MANDELBROT:
                fractal = new CoupledMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.COUPLED_MANDELBROT_BURNING_SHIP:
                fractal = new CoupledMandelbrotBurningShip(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLER3:
                fractal = new Muller3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLER4:
                fractal = new Muller4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLERGENERALIZED3:
                fractal = new MullerGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLERGENERALIZED8:
                fractal = new MullerGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLERSIN:
                fractal = new MullerSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLERCOS:
                fractal = new MullerCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MULLERPOLY:
                fractal = new MullerPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.MULLERFORMULA:
                fractal = new MullerFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, ots, sts);
                break;
            case MainWindow.PARHALLEY3:
                fractal = new Parhalley3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEY4:
                fractal = new Parhalley4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEYGENERALIZED3:
                fractal = new ParhalleyGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEYGENERALIZED8:
                fractal = new ParhalleyGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEYSIN:
                fractal = new ParhalleySin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEYCOS:
                fractal = new ParhalleyCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.PARHALLEYPOLY:
                fractal = new ParhalleyPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.PARHALLEYFORMULA:
                fractal = new ParhalleyFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.LAGUERRE3:
                fractal = new Laguerre3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERRE4:
                fractal = new Laguerre4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERREGENERALIZED3:
                fractal = new LaguerreGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERREGENERALIZED8:
                fractal = new LaguerreGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERRESIN:
                fractal = new LaguerreSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERRECOS:
                fractal = new LaguerreCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAGUERREPOLY:
                fractal = new LaguerrePoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.LAGUERREFORMULA:
                fractal = new LaguerreFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, laguerre_deg, ots, sts);
                break;
            case MainWindow.GENERIC_CaZbdZe:
                fractal = new GenericCaZbdZe(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, gcs);
                break;
            case MainWindow.DURAND_KERNER3:
                fractal = new DurandKerner3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.DURAND_KERNER4:
                fractal = new DurandKerner4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.DURAND_KERNERGENERALIZED3:
                fractal = new DurandKernerGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.DURAND_KERNERGENERALIZED8:
                fractal = new DurandKernerGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.DURAND_KERNERPOLY:
                fractal = new DurandKernerPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, durand_kernel_init_val, coefficients_im, root_initialization_method);
                break;
            case MainWindow.MAGNETIC_PENDULUM:
                fractal = new MagneticPendulum(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, mps);
                break;
            case MainWindow.LYAPUNOV:
                fractal = new Lyapunov(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, lyapunovExpression, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck);
                break;
            case MainWindow.BAIRSTOW3:
                fractal = new Bairstow3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BAIRSTOW4:
                fractal = new Bairstow4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BAIRSTOWGENERALIZED3:
                fractal = new BairstowGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BAIRSTOWGENERALIZED8:
                fractal = new BairstowGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.BAIRSTOWPOLY:
                fractal = new BairstowPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.USER_FORMULA_NOVA:
                fractal = new UserFormulaNova(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, nova_method, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, newton_hines_k, defaultNovaInitialValue, useGlobalMethod, globalMethodFactor);
                break;
            case MainWindow.GENERIC_CpAZpBC:
                fractal = new GenericCpAZpBC(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, gcps);
                break;
            case MainWindow.INERTIA_GRAVITY:
                fractal = new InertiaGravityFractal(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, igs);
                break;
            case MainWindow.MANDEL_NEWTON:
                fractal = new MandelNewton(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.LAMBERT_W_VARIATION:
                fractal = new LambertWVariation(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_THIRD_DEGREE_PARAMETER_SPACE:
                fractal = new NewtonThirdDegreeParameterSpace(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINES3:
                fractal = new NewtonHines3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINES4:
                fractal = new NewtonHines4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINESGENERALIZED3:
                fractal = new NewtonHinesGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINESGENERALIZED8:
                fractal = new NewtonHinesGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINESSIN:
                fractal = new NewtonHinesSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINESCOS:
                fractal = new NewtonHinesCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEWTON_HINESPOLY:
                fractal = new NewtonHinesPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im, newton_hines_k);
                break;
            case MainWindow.NEWTON_HINESFORMULA:
                fractal = new NewtonHinesFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts, newton_hines_k);
                break;
            case MainWindow.WHITTAKER3:
                fractal = new Whittaker3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKER4:
                fractal = new Whittaker4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERGENERALIZED3:
                fractal = new WhittakerGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERGENERALIZED8:
                fractal = new WhittakerGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERSIN:
                fractal = new WhittakerSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERCOS:
                fractal = new WhittakerCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERPOLY:
                fractal = new WhittakerPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.WHITTAKERFORMULA:
                fractal = new WhittakerFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEX3:
                fractal = new WhittakerDoubleConvex3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEX4:
                fractal = new WhittakerDoubleConvex4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXGENERALIZED3:
                fractal = new WhittakerDoubleConvexGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXGENERALIZED8:
                fractal = new WhittakerDoubleConvexGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXSIN:
                fractal = new WhittakerDoubleConvexSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXCOS:
                fractal = new WhittakerDoubleConvexCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXPOLY:
                fractal = new WhittakerDoubleConvexPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.WHITTAKERDOUBLECONVEXFORMULA:
                fractal = new WhittakerDoubleConvexFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.SUPERHALLEY3:
                fractal = new SuperHalley3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEY4:
                fractal = new SuperHalley4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEYGENERALIZED3:
                fractal = new SuperHalleyGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEYGENERALIZED8:
                fractal = new SuperHalleyGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEYSIN:
                fractal = new SuperHalleySin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEYCOS:
                fractal = new SuperHalleyCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SUPERHALLEYPOLY:
                fractal = new SuperHalleyPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.SUPERHALLEYFORMULA:
                fractal = new SuperHalleyFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKI3:
                fractal = new TraubOstrowski3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKI4:
                fractal = new TraubOstrowski4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKIGENERALIZED3:
                fractal = new TraubOstrowskiGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKIGENERALIZED8:
                fractal = new TraubOstrowskiGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKISIN:
                fractal = new TraubOstrowskiSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKICOS:
                fractal = new TraubOstrowskiCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.TRAUB_OSTROWSKIPOLY:
                fractal = new TraubOstrowskiPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.TRAUB_OSTROWSKIFORMULA:
                fractal = new TraubOstrowskiFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.STIRLING3:
                fractal = new Stirling3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLING4:
                fractal = new Stirling4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLINGGENERALIZED3:
                fractal = new StirlingGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLINGGENERALIZED8:
                fractal = new StirlingGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLINGSIN:
                fractal = new StirlingSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLINGCOS:
                fractal = new StirlingCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.STIRLINGPOLY:
                fractal = new StirlingPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.STIRLINGFORMULA:
                fractal = new StirlingFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.MIDPOINT3:
                fractal = new Midpoint3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINT4:
                fractal = new Midpoint4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINTGENERALIZED3:
                fractal = new MidpointGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINTGENERALIZED8:
                fractal = new MidpointGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINTSIN:
                fractal = new MidpointSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINTCOS:
                fractal = new MidpointCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MIDPOINTPOLY:
                fractal = new MidpointPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.MIDPOINTFORMULA:
                fractal = new MidpointFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.ABERTH_EHRLICH3:
                fractal = new AberthEhrlich3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABERTH_EHRLICH4:
                fractal = new AberthEhrlich4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABERTH_EHRLICHGENERALIZED3:
                fractal = new AberthEhrlichGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABERTH_EHRLICHGENERALIZED8:
                fractal = new AberthEhrlichGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABERTH_EHRLICHPOLY:
                fractal = new AberthEhrlichPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, durand_kernel_init_val, coefficients_im, root_initialization_method);
                break;
            case MainWindow.JARATT3:
                fractal = new Jaratt3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT4:
                fractal = new Jaratt4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATTGENERALIZED3:
                fractal = new JarattGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATTGENERALIZED8:
                fractal = new JarattGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATTSIN:
                fractal = new JarattSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATTCOS:
                fractal = new JarattCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATTPOLY:
                fractal = new JarattPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.JARATTFORMULA:
                fractal = new JarattFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.JARATT23:
                fractal = new Jaratt23(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT24:
                fractal = new Jaratt24(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT2GENERALIZED3:
                fractal = new Jaratt2Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT2GENERALIZED8:
                fractal = new Jaratt2Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT2SIN:
                fractal = new Jaratt2Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT2COS:
                fractal = new Jaratt2Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.JARATT2POLY:
                fractal = new Jaratt2Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.JARATT2FORMULA:
                fractal = new Jaratt2Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTON3:
                fractal = new ThirdOrderNewton3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTON4:
                fractal = new ThirdOrderNewton4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTONGENERALIZED3:
                fractal = new ThirdOrderNewtonGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTONGENERALIZED8:
                fractal = new ThirdOrderNewtonGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTONSIN:
                fractal = new ThirdOrderNewtonSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTONCOS:
                fractal = new ThirdOrderNewtonCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.THIRDORDERNEWTONPOLY:
                fractal = new ThirdOrderNewtonPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.THIRDORDERNEWTONFORMULA:
                fractal = new ThirdOrderNewtonFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDO3:
                fractal = new WeerakoonFernando3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDO4:
                fractal = new WeerakoonFernando4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDOGENERALIZED3:
                fractal = new WeerakoonFernandoGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDOGENERALIZED8:
                fractal = new WeerakoonFernandoGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDOSIN:
                fractal = new WeerakoonFernandoSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDOCOS:
                fractal = new WeerakoonFernandoCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.WEERAKOON_FERNANDOPOLY:
                fractal = new WeerakoonFernandoPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.WEERAKOON_FERNANDOFORMULA:
                fractal = new WeerakoonFernandoFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER33:
                fractal = new Householder33(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER34:
                fractal = new Householder34(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3GENERALIZED3:
                fractal = new Householder3Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3GENERALIZED8:
                fractal = new Householder3Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3SIN:
                fractal = new Householder3Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3COS:
                fractal = new Householder3Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOUSEHOLDER3POLY:
                fractal = new Householder3Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HOUSEHOLDER3FORMULA:
                fractal = new Householder3Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, ots, sts);
                break;
            case MainWindow.ABBASBANDY3:
                fractal = new Abbasbandy3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY4:
                fractal = new Abbasbandy4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDYGENERALIZED3:
                fractal = new AbbasbandyGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDYGENERALIZED8:
                fractal = new AbbasbandyGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDYSIN:
                fractal = new AbbasbandySin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDYCOS:
                fractal = new AbbasbandyCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDYPOLY:
                fractal = new AbbasbandyPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.ABBASBANDYFORMULA:
                fractal = new AbbasbandyFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTON3:
                fractal = new ContraHarmonicNewton3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTON4:
                fractal = new ContraHarmonicNewton4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONGENERALIZED3:
                fractal = new ContraHarmonicNewtonGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONGENERALIZED8:
                fractal = new ContraHarmonicNewtonGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONSIN:
                fractal = new ContraHarmonicNewtonSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONCOS:
                fractal = new ContraHarmonicNewtonCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONPOLY:
                fractal = new ContraHarmonicNewtonPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CONTRA_HARMONIC_NEWTONFORMULA:
                fractal = new ContraHarmonicNewtonFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.CHUN_HAM3:
                fractal = new ChunHam3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAM4:
                fractal = new ChunHam4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAMGENERALIZED3:
                fractal = new ChunHamGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAMGENERALIZED8:
                fractal = new ChunHamGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAMSIN:
                fractal = new ChunHamSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAMCOS:
                fractal = new ChunHamCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_HAMPOLY:
                fractal = new ChunHamPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CHUN_HAMFORMULA:
                fractal = new ChunHamFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.CHUN_KIM3:
                fractal = new ChunKim3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIM4:
                fractal = new ChunKim4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIMGENERALIZED3:
                fractal = new ChunKimGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIMGENERALIZED8:
                fractal = new ChunKimGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIMSIN:
                fractal = new ChunKimSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIMCOS:
                fractal = new ChunKimCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHUN_KIMPOLY:
                fractal = new ChunKimPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CHUN_KIMFORMULA:
                fractal = new ChunKimFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEV3:
                fractal = new EulerChebyshev3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEV4:
                fractal = new EulerChebyshev4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEVGENERALIZED3:
                fractal = new EulerChebyshevGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEVGENERALIZED8:
                fractal = new EulerChebyshevGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEVSIN:
                fractal = new EulerChebyshevSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEVCOS:
                fractal = new EulerChebyshevCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EULER_CHEBYSHEVPOLY:
                fractal = new EulerChebyshevPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.EULER_CHEBYSHEVFORMULA:
                fractal = new EulerChebyshevFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI23:
                fractal = new EzzatiSaleki23(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI24:
                fractal = new EzzatiSaleki24(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI2GENERALIZED3:
                fractal = new EzzatiSaleki2Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI2GENERALIZED8:
                fractal = new EzzatiSaleki2Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI2SIN:
                fractal = new EzzatiSaleki2Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI2COS:
                fractal = new EzzatiSaleki2Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI2POLY:
                fractal = new EzzatiSaleki2Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.EZZATI_SALEKI2FORMULA:
                fractal = new EzzatiSaleki2Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.HOMEIER13:
                fractal = new Homeier13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER14:
                fractal = new Homeier14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER1GENERALIZED3:
                fractal = new Homeier1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER1GENERALIZED8:
                fractal = new Homeier1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER1SIN:
                fractal = new Homeier1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER1COS:
                fractal = new Homeier1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER1POLY:
                fractal = new Homeier1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HOMEIER1FORMULA:
                fractal = new Homeier1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.ABBASBANDY23:
                fractal = new Abbasbandy23(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY24:
                fractal = new Abbasbandy24(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY2GENERALIZED3:
                fractal = new Abbasbandy2Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY2GENERALIZED8:
                fractal = new Abbasbandy2Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY2SIN:
                fractal = new Abbasbandy2Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY2COS:
                fractal = new Abbasbandy2Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY2POLY:
                fractal = new Abbasbandy2Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.ABBASBANDY2FORMULA:
                fractal = new Abbasbandy2Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.ABBASBANDY33:
                fractal = new Abbasbandy33(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY34:
                fractal = new Abbasbandy34(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY3GENERALIZED3:
                fractal = new Abbasbandy3Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY3GENERALIZED8:
                fractal = new Abbasbandy3Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY3SIN:
                fractal = new Abbasbandy3Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY3COS:
                fractal = new Abbasbandy3Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.ABBASBANDY3POLY:
                fractal = new Abbasbandy3Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.ABBASBANDY3FORMULA:
                fractal = new Abbasbandy3Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, ots, sts);
                break;
            case MainWindow.POPOVSKI13:
                fractal = new Popovski13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI14:
                fractal = new Popovski14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI1GENERALIZED3:
                fractal = new Popovski1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI1GENERALIZED8:
                fractal = new Popovski1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI1SIN:
                fractal = new Popovski1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI1COS:
                fractal = new Popovski1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.POPOVSKI1POLY:
                fractal = new Popovski1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.POPOVSKI1FORMULA:
                fractal = new Popovski1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN13:
                fractal = new ChangBumChun13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN14:
                fractal = new ChangBumChun14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN1GENERALIZED3:
                fractal = new ChangBumChun1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN1GENERALIZED8:
                fractal = new ChangBumChun1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN1SIN:
                fractal = new ChangBumChun1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN1COS:
                fractal = new ChangBumChun1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN1POLY:
                fractal = new ChangBumChun1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CHANGBUM_CHUN1FORMULA:
                fractal = new ChangBumChun1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN23:
                fractal = new ChangBumChun23(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN24:
                fractal = new ChangBumChun24(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN2GENERALIZED3:
                fractal = new ChangBumChun2Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN2GENERALIZED8:
                fractal = new ChangBumChun2Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN2SIN:
                fractal = new ChangBumChun2Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN2COS:
                fractal = new ChangBumChun2Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN2POLY:
                fractal = new ChangBumChun2Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CHANGBUM_CHUN2FORMULA:
                fractal = new ChangBumChun2Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.KING33:
                fractal = new King33(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING34:
                fractal = new King34(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING3GENERALIZED3:
                fractal = new King3Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING3GENERALIZED8:
                fractal = new King3Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING3SIN:
                fractal = new King3Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING3COS:
                fractal = new King3Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING3POLY:
                fractal = new King3Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.KING3FORMULA:
                fractal = new King3Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.HOMEIER23:
                fractal = new Homeier23(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER24:
                fractal = new Homeier24(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER2GENERALIZED3:
                fractal = new Homeier2Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER2GENERALIZED8:
                fractal = new Homeier2Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER2SIN:
                fractal = new Homeier2Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER2COS:
                fractal = new Homeier2Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HOMEIER2POLY:
                fractal = new Homeier2Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HOMEIER2FORMULA:
                fractal = new Homeier2Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.KIM_CHUN3:
                fractal = new KimChun3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUN4:
                fractal = new KimChun4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUNGENERALIZED3:
                fractal = new KimChunGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUNGENERALIZED8:
                fractal = new KimChunGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUNSIN:
                fractal = new KimChunSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUNCOS:
                fractal = new KimChunCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KIM_CHUNPOLY:
                fractal = new KimChunPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.KIM_CHUNFORMULA:
                fractal = new KimChunFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG13:
                fractal = new KouLiWang13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG14:
                fractal = new KouLiWang14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG1GENERALIZED3:
                fractal = new KouLiWang1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG1GENERALIZED8:
                fractal = new KouLiWang1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG1SIN:
                fractal = new KouLiWang1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG1COS:
                fractal = new KouLiWang1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KOU_LI_WANG1POLY:
                fractal = new KouLiWang1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.KOU_LI_WANG1FORMULA:
                fractal = new KouLiWang1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.MAHESHWERI3:
                fractal = new Maheshweri3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERI4:
                fractal = new Maheshweri4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERIGENERALIZED3:
                fractal = new MaheshweriGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERIGENERALIZED8:
                fractal = new MaheshweriGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERISIN:
                fractal = new MaheshweriSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERICOS:
                fractal = new MaheshweriCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAHESHWERIPOLY:
                fractal = new MaheshweriPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.MAHESHWERIFORMULA:
                fractal = new MaheshweriFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.RAFIULLAH13:
                fractal = new Rafiullah13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH14:
                fractal = new Rafiullah14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH1GENERALIZED3:
                fractal = new Rafiullah1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH1GENERALIZED8:
                fractal = new Rafiullah1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH1SIN:
                fractal = new Rafiullah1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH1COS:
                fractal = new Rafiullah1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIULLAH1POLY:
                fractal = new Rafiullah1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.RAFIULLAH1FORMULA:
                fractal = new Rafiullah1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAH3:
                fractal = new RafisRafiullah3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAH4:
                fractal = new RafisRafiullah4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAHGENERALIZED3:
                fractal = new RafisRafiullahGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAHGENERALIZED8:
                fractal = new RafisRafiullahGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAHSIN:
                fractal = new RafisRafiullahSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAHCOS:
                fractal = new RafisRafiullahCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.RAFIS_RAFIULLAHPOLY:
                fractal = new RafisRafiullahPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.RAFIS_RAFIULLAHFORMULA:
                fractal = new RafisRafiullahFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, user_ddfz_formula, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN33:
                fractal = new ChangBumChun33(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN34:
                fractal = new ChangBumChun34(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN3GENERALIZED3:
                fractal = new ChangBumChun3Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN3GENERALIZED8:
                fractal = new ChangBumChun3Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN3SIN:
                fractal = new ChangBumChun3Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN3COS:
                fractal = new ChangBumChun3Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.CHANGBUM_CHUN3POLY:
                fractal = new ChangBumChun3Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.CHANGBUM_CHUN3FORMULA:
                fractal = new ChangBumChun3Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI13:
                fractal = new EzzatiSaleki13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI14:
                fractal = new EzzatiSaleki14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI1GENERALIZED3:
                fractal = new EzzatiSaleki1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI1GENERALIZED8:
                fractal = new EzzatiSaleki1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI1SIN:
                fractal = new EzzatiSaleki1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI1COS:
                fractal = new EzzatiSaleki1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.EZZATI_SALEKI1POLY:
                fractal = new EzzatiSaleki1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.EZZATI_SALEKI1FORMULA:
                fractal = new EzzatiSaleki1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.FENG3:
                fractal = new Feng3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENG4:
                fractal = new Feng4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENGGENERALIZED3:
                fractal = new FengGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENGGENERALIZED8:
                fractal = new FengGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENGSIN:
                fractal = new FengSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENGCOS:
                fractal = new FengCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.FENGPOLY:
                fractal = new FengPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.FENGFORMULA:
                fractal = new FengFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.KING13:
                fractal = new King13(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING14:
                fractal = new King14(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING1GENERALIZED3:
                fractal = new King1Generalized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING1GENERALIZED8:
                fractal = new King1Generalized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING1SIN:
                fractal = new King1Sin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING1COS:
                fractal = new King1Cos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.KING1POLY:
                fractal = new King1Poly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.KING1FORMULA:
                fractal = new King1Formula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.NOOR_GUPTA3:
                fractal = new NoorGupta3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTA4:
                fractal = new NoorGupta4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTAGENERALIZED3:
                fractal = new NoorGuptaGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTAGENERALIZED8:
                fractal = new NoorGuptaGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTASIN:
                fractal = new NoorGuptaSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTACOS:
                fractal = new NoorGuptaCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NOOR_GUPTAPOLY:
                fractal = new NoorGuptaPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.NOOR_GUPTAFORMULA:
                fractal = new NoorGuptaFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTON3:
                fractal = new HarmonicSimpsonNewton3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTON4:
                fractal = new HarmonicSimpsonNewton4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONGENERALIZED3:
                fractal = new HarmonicSimpsonNewtonGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONGENERALIZED8:
                fractal = new HarmonicSimpsonNewtonGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONSIN:
                fractal = new HarmonicSimpsonNewtonSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONCOS:
                fractal = new HarmonicSimpsonNewtonCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONPOLY:
                fractal = new HarmonicSimpsonNewtonPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.HARMONIC_SIMPSON_NEWTONFORMULA:
                fractal = new HarmonicSimpsonNewtonFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.NEDZHIBOV3:
                fractal = new Nedzhibov3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOV4:
                fractal = new Nedzhibov4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOVGENERALIZED3:
                fractal = new NedzhibovGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOVGENERALIZED8:
                fractal = new NedzhibovGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOVSIN:
                fractal = new NedzhibovSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOVCOS:
                fractal = new NedzhibovCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.NEDZHIBOVPOLY:
                fractal = new NedzhibovPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.NEDZHIBOVFORMULA:
                fractal = new NedzhibovFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTON3:
                fractal = new SimpsonNewton3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTON4:
                fractal = new SimpsonNewton4(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTONGENERALIZED3:
                fractal = new SimpsonNewtonGeneralized3(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTONGENERALIZED8:
                fractal = new SimpsonNewtonGeneralized8(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTONSIN:
                fractal = new SimpsonNewtonSin(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTONCOS:
                fractal = new SimpsonNewtonCos(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts);
                break;
            case MainWindow.SIMPSON_NEWTONPOLY:
                fractal = new SimpsonNewtonPoly(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, coefficients_im);
                break;
            case MainWindow.SIMPSON_NEWTONFORMULA:
                fractal = new SimpsonNewtonFormula(xCenter, yCenter, size, max_iterations, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, user_fz_formula, user_dfz_formula, ots, sts);
                break;
            case MainWindow.MAGNET_PATAKI2:
                fractal = new MagnetPataki2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET_PATAKI3:
                fractal = new MagnetPataki3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET_PATAKI4:
                fractal = new MagnetPataki4(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET_PATAKI5:
                fractal = new MagnetPataki5(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts);
                break;
            case MainWindow.MAGNET_PATAKIK:
                fractal = new MagnetPatakiK(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, rotation_vals, rotation_center, perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, user_perturbation_conditions, user_perturbation_condition_formula, perturbation_user_formula, init_val, initial_vals, variable_init_value, user_initial_value_algorithm, user_initial_value_conditions, user_initial_value_condition_formula, initial_value_user_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, z_exponent);
                break;
        }

        fractal.preFilterFactory(preffs);
        fractal.postFilterFactory(postffs);
        fractal.influencePlaneFactory(ips);
        fractal.setFunctionId(function);

        if(ptr != null) {
            if(ptr.getSettings().hasConvergentBailout()) {
                fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
            }
        }
        else if(ptrExpander != null) {
            if(ptrExpander.getSettings().hasConvergentBailout()) {
                fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
            }
        }
        else {
            fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
        }

        fractal.updateTrapsWithInitValData();
        fractal.setUserPeriod(period);
        fractal.setSize(dsize);
        fractal.setPolar(polar_projection);

        GenericStatistic statistic = fractal.getStatisticInstance();
        if(statistic != null) {
            statistic.setSize(dsize, height_ratio);
            statistic.setInterpolationMethod(method);
            statistic.setEscapingSmoothingAlgorithm(escaping_smooth_algorithm);
            statistic.setConvergingSmoothingAlgorithm(converging_smooth_algorithm);
        }

        fractal.setWorkSpaceData();

        Complex[] values = new Complex[Parser.EXTRA_VARS];
        for(int i = 0; i < values.length; i++) {
            values[i] = new Complex(variable_re[i], variable_im[i]);
        }
        fractal.setInitialVariablesValues(values);

        return fractal;

    }

    private Fractal juliaFactory(int function, double xCenter, double yCenter,  Apfloat dsize, double size, int max_iterations, int plane_type, boolean apply_plane_on_julia, boolean apply_plane_on_julia_seed, double[] rotation_vals, double[] rotation_center, boolean burning_ship, boolean mandel_grass, double[] mandel_grass_vals, String user_plane, int user_plane_algorithm, String[] user_plane_conditions, String[] user_plane_condition_formula, double[] plane_transform_center, double plane_transform_angle, double plane_transform_radius, double[] plane_transform_scales, double[] plane_transform_wavelength, int waveType, double plane_transform_angle2, int plane_transform_sides, double plane_transform_amount, double z_exponent, double[] z_exponent_complex, double[] coefficients, double[] coefficients_im, double[] z_exponent_nova, double[] relaxation, int nova_method, int bail_technique, String user_formula, String user_formula2, String[] user_formula_iteration_based, String[] user_formula_conditions, String[] user_formula_condition_formula, double coupling, String[] user_formula_coupled, int coupling_method, double coupling_amplitude, double coupling_frequency, int coupling_seed, int bailout_test_algorithm, double bailout, String bailout_test_user_formula, String bailout_test_user_formula2, int bailout_test_comparison, double n_norm, int out_coloring_algorithm, int user_out_coloring_algorithm, String outcoloring_formula, String[] user_outcoloring_conditions, String[] user_outcoloring_condition_formula, int in_coloring_algorithm, int user_in_coloring_algorithm, String incoloring_formula, String[] user_incoloring_conditions, String[] user_incoloring_condition_formula, boolean smoothing, boolean periodicity_checking, GenericCaZbdZeSettings gcs, String[] lyapunovExpression, OrbitTrapSettings ots, boolean exterior_de, double exterior_de_factor, boolean inverse_dem, int escaping_smooth_algorithm, int converging_smooth_algorithm, StatisticsSettings sts, boolean useLyapunovExponent, String lyapunovFunction, String lyapunovExponentFunction, int lyapunovVariableId, String user_fz_formula, String user_dfz_formula, String user_ddfz_formula, String user_dddfz_formula, String user_relaxation_formula, String user_nova_addend_formula, double[] laguerre_deg, GenericCpAZpBCSettings gcps, LambdaFnFnSettings lfns, double[] newton_hines_k, TrueColorSettings tcs, String lyapunovInitialValue, int lyapunovInitializationIteratons, boolean lyapunovskipBailoutCheck, FunctionFilterSettings preffs, FunctionFilterSettings postffs, PlaneInfluenceSettings ips, boolean juliter, int juliterIterations, boolean juliterIncludeInitialIterations, boolean defaultNovaInitialValue, boolean perturbation, double[] perturbation_vals, boolean variable_perturbation, int user_perturbation_algorithm, String perturbation_user_formula, String[] user_perturbation_conditions, String[] user_perturbation_condition_formula, boolean init_value, double[] initial_vals, boolean variable_init_value, int user_initial_value_algorithm, String initial_value_user_formula, String[] user_initial_value_conditions, String[] user_initial_value_condition_formula, ConvergentBailoutConditionSettings cbs,  boolean useGlobalMethod, double[] globalMethodFactor, double[] variable_re, double[] variable_im, ArrayList<Double> inflections_re, ArrayList<Double> inflections_im, double inflectionsPower, Apfloat xJuliaCenterAf, Apfloat yJuliaCenterAf) {

        Fractal fractal = null;

        double xJuliaCenter = xJuliaCenterAf.doubleValue();
        double yJuliaCenter = yJuliaCenterAf.doubleValue();

        switch (function) {
            case MainWindow.MANDELBROT:
                fractal = new Mandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, exterior_de, exterior_de_factor, inverse_dem, escaping_smooth_algorithm, ots, sts, height_ratio, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTCUBED:
                fractal = new MandelbrotCubed(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTFOURTH:
                fractal = new MandelbrotFourth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTFIFTH:
                fractal = new MandelbrotFifth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTSIXTH:
                fractal = new MandelbrotSixth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTSEVENTH:
                fractal = new MandelbrotSeventh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTEIGHTH:
                fractal = new MandelbrotEighth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTNINTH:
                fractal = new MandelbrotNinth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTTENTH:
                fractal = new MandelbrotTenth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTNTH:
                fractal = new MandelbrotNth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, z_exponent, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBROTWTH:
                fractal = new MandelbrotWth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, z_exponent_complex, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELPOLY:
                fractal = new MandelbrotPoly(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, burning_ship, mandel_grass, mandel_grass_vals, coefficients, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, coefficients_im, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LAMBDA:
                fractal = new Lambda(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LAMBDA2:
                fractal = new Lambda2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LAMBDA3:
                fractal = new Lambda3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LAMBDA_FN_FN:
                fractal = new LambdaFnFn(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, lfns, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET1:
                fractal = new Magnet1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET13:
                fractal = new Magnet13(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET14:
                fractal = new Magnet14(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET2:
                fractal = new Magnet2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET23:
                fractal = new Magnet23(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET24:
                fractal = new Magnet24(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.BARNSLEY1:
                fractal = new Barnsley1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.BARNSLEY2:
                fractal = new Barnsley2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.BARNSLEY3:
                fractal = new Barnsley3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDELBAR:
                fractal = new Mandelbar(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.SPIDER:
                fractal = new Spider(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANOWAR:
                fractal = new Manowar(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.PHOENIX:
                fractal = new Phoenix(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.NOVA:
                fractal = new Nova(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, z_exponent_nova, relaxation, nova_method, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, newton_hines_k, defaultNovaInitialValue, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.EXP:
                fractal = new Exp(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LOG:
                fractal = new Log(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.SIN:
                fractal = new Sin(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COS:
                fractal = new Cos(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.TAN:
                fractal = new Tan(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COT:
                fractal = new Cot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.SINH:
                fractal = new Sinh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COSH:
                fractal = new Cosh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.TANH:
                fractal = new Tanh(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COTH:
                fractal = new Coth(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA30:
                fractal = new Formula30(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA31:
                fractal = new Formula31(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA1:
                fractal = new Formula1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA2:
                fractal = new Formula2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA3:
                fractal = new Formula3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA4:
                fractal = new Formula4(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA5:
                fractal = new Formula5(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA6:
                fractal = new Formula6(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA7:
                fractal = new Formula7(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA8:
                fractal = new Formula8(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA9:
                fractal = new Formula9(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA10:
                fractal = new Formula10(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA11:
                fractal = new Formula11(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA12:
                fractal = new Formula12(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA13:
                fractal = new Formula13(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA14:
                fractal = new Formula14(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA15:
                fractal = new Formula15(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA16:
                fractal = new Formula16(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA17:
                fractal = new Formula17(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA18:
                fractal = new Formula18(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA19:
                fractal = new Formula19(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA20:
                fractal = new Formula20(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA21:
                fractal = new Formula21(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA22:
                fractal = new Formula22(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA23:
                fractal = new Formula23(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA24:
                fractal = new Formula24(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA25:
                fractal = new Formula25(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA26:
                fractal = new Formula26(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA27:
                fractal = new Formula27(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA28:
                fractal = new Formula28(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA29:
                fractal = new Formula29(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA32:
                fractal = new Formula32(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA33:
                fractal = new Formula33(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA34:
                fractal = new Formula34(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA35:
                fractal = new Formula35(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA36:
                fractal = new Formula36(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA37:
                fractal = new Formula37(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA38:
                fractal = new Formula38(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA39:
                fractal = new Formula39(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA40:
                fractal = new Formula40(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA41:
                fractal = new Formula41(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA42:
                fractal = new Formula42(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA43:
                fractal = new Formula43(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA44:
                fractal = new Formula44(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA45:
                fractal = new Formula45(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA46:
                fractal = new Formula46(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA47:
                fractal = new Formula47(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.FORMULA48:
                fractal = new Formula48(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.PERPENDICULAR_MANDELBROT:
                fractal = new PerpendicularMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.BUFFALO_MANDELBROT:
                fractal = new BuffaloMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.CELTIC_MANDELBROT:
                fractal = new CelticMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.PERPENDICULAR_BURNING_SHIP:
                fractal = new PerpendicularBurningShip(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.PERPENDICULAR_CELTIC_MANDELBROT:
                fractal = new PerpendicularCelticMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.PERPENDICULAR_BUFFALO_MANDELBROT:
                fractal = new PerpendicularBuffaloMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.USER_FORMULA:
                if (bail_technique == 0) {
                    fractal = new UserFormulaEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                else {
                    fractal = new UserFormulaEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula, user_formula2, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                break;
            case MainWindow.USER_FORMULA_ITERATION_BASED:
                if (bail_technique == 0) {
                    fractal = new UserFormulaIterationBasedEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaIterationBasedConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                else {
                    fractal = new UserFormulaIterationBasedEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_iteration_based, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                break;
            case MainWindow.USER_FORMULA_CONDITIONAL:
                if (bail_technique == 0) {
                    fractal = new UserFormulaConditionalEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaConditionalConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                else {
                    fractal = new UserFormulaConditionalEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_formula_conditions, user_formula_condition_formula, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                break;
            case MainWindow.USER_FORMULA_COUPLED:
                if (bail_technique == 0) {
                    fractal = new UserFormulaCoupledEscaping(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts, xJuliaCenter, yJuliaCenter);
                } else if (bail_technique == 1) {
                    fractal = new UserFormulaCoupledConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                else {
                    fractal = new UserFormulaCoupledEscapingOrConverging(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, converging_smooth_algorithm, coupling, user_formula_coupled, coupling_method, coupling_amplitude, coupling_frequency, coupling_seed, ots, sts, xJuliaCenter, yJuliaCenter);
                }
                break;
            case MainWindow.FROTHY_BASIN:
                fractal = new FrothyBasin(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.SZEGEDI_BUTTERFLY1:
                fractal = new SzegediButterfly1(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.SZEGEDI_BUTTERFLY2:
                fractal = new SzegediButterfly2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COUPLED_MANDELBROT:
                fractal = new CoupledMandelbrot(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.COUPLED_MANDELBROT_BURNING_SHIP:
                fractal = new CoupledMandelbrotBurningShip(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.GENERIC_CaZbdZe:
                fractal = new GenericCaZbdZe(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, gcs, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LYAPUNOV:
                fractal = new Lyapunov(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, lyapunovExpression, useLyapunovExponent, lyapunovFunction, lyapunovExponentFunction, lyapunovVariableId, lyapunovInitialValue, lyapunovInitializationIteratons, lyapunovskipBailoutCheck, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.USER_FORMULA_NOVA:
                fractal = new UserFormulaNova(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, nova_method, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, user_fz_formula, user_dfz_formula, user_ddfz_formula, user_dddfz_formula, user_relaxation_formula, user_nova_addend_formula, laguerre_deg, newton_hines_k, defaultNovaInitialValue, useGlobalMethod, globalMethodFactor, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.GENERIC_CpAZpBC:
                fractal = new GenericCpAZpBC(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, gcps, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MANDEL_NEWTON:
                fractal = new MandelNewton(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.LAMBERT_W_VARIATION:
                fractal = new LambertWVariation(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.NEWTON_THIRD_DEGREE_PARAMETER_SPACE:
                fractal = new NewtonThirdDegreeParameterSpace(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, converging_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET_PATAKI2:
                fractal = new MagnetPataki2(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET_PATAKI3:
                fractal = new MagnetPataki3(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET_PATAKI4:
                fractal = new MagnetPataki4(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET_PATAKI5:
                fractal = new MagnetPataki5(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, xJuliaCenter, yJuliaCenter);
                break;
            case MainWindow.MAGNET_PATAKIK:
                fractal = new MagnetPatakiK(xCenter, yCenter, size, max_iterations, bailout_test_algorithm, bailout, bailout_test_user_formula, bailout_test_user_formula2, bailout_test_comparison, n_norm, out_coloring_algorithm, user_out_coloring_algorithm, outcoloring_formula, user_outcoloring_conditions, user_outcoloring_condition_formula, in_coloring_algorithm, user_in_coloring_algorithm, incoloring_formula, user_incoloring_conditions, user_incoloring_condition_formula, smoothing, periodicity_checking, plane_type, apply_plane_on_julia, apply_plane_on_julia_seed, rotation_vals, rotation_center, user_plane, user_plane_algorithm, user_plane_conditions, user_plane_condition_formula, plane_transform_center, plane_transform_angle, plane_transform_radius, plane_transform_scales, plane_transform_wavelength, waveType, plane_transform_angle2, plane_transform_sides, plane_transform_amount, inflections_re, inflections_im, inflectionsPower, escaping_smooth_algorithm, ots, sts, z_exponent, xJuliaCenter, yJuliaCenter);
                break;

        }

        fractal.setJuliterOptions(juliter, juliterIterations, juliterIncludeInitialIterations);
        fractal.setPertubationOption(perturbation, perturbation_vals, variable_perturbation, user_perturbation_algorithm, perturbation_user_formula, user_perturbation_conditions, user_perturbation_condition_formula, plane_transform_center);

        if(function == MainWindow.USER_FORMULA || function == MainWindow.USER_FORMULA_CONDITIONAL || function == MainWindow.USER_FORMULA_ITERATION_BASED || function == MainWindow.USER_FORMULA_COUPLED
                || function == MainWindow.USER_FORMULA_NOVA || function == MainWindow.LYAPUNOV || function == MainWindow.LAMBDA_FN_FN) {
            fractal.setInitialValueOption(init_value, initial_vals, variable_init_value, user_initial_value_algorithm, initial_value_user_formula, user_initial_value_conditions, user_initial_value_condition_formula, plane_transform_center);
        }

        fractal.setFunctionId(function);
        fractal.preFilterFactory(preffs);
        fractal.postFilterFactory(postffs);
        fractal.influencePlaneFactory(ips);

        if(ptr != null) {
            if(ptr.getSettings().hasConvergentBailout()) {
                fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
            }
        }
        else if(ptrExpander != null) {
            if(ptrExpander.getSettings().hasConvergentBailout()) {
                fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
            }
        }
        else {
            fractal.ConvergentBailoutConditionFactory(cbs.convergent_bailout_test_algorithm, fractal.getConvergentBailout(), cbs.convergent_bailout_test_user_formula, cbs.convergent_bailout_test_user_formula2, cbs.convergent_bailout_test_comparison, cbs.convergent_n_norm, plane_transform_center);
        }

        fractal.setSize(dsize);
        fractal.setPolar(polar_projection);

        GenericStatistic statistic = fractal.getStatisticInstance();
        if(statistic != null) {
            statistic.setSize(dsize, height_ratio);
            statistic.setInterpolationMethod(method);
            statistic.setEscapingSmoothingAlgorithm(escaping_smooth_algorithm);
            statistic.setConvergingSmoothingAlgorithm(converging_smooth_algorithm);
        }

        fractal.setSeed(new BigComplex(xJuliaCenterAf, yJuliaCenterAf));

        fractal.setWorkSpaceData();

        Complex[] values = new Complex[Parser.EXTRA_VARS];
        for(int i = 0; i < values.length; i++) {
            values[i] = new Complex(variable_re[i], variable_im[i]);
        }
        fractal.setInitialVariablesValues(values);

        return fractal;

    }

    public static int getGradientColor(int index) {

        return gradient[index % gradient.length];

    }

    public void setTrueColoringOptions(TrueColorSettings tcs) {

        fractal.setTrueColorAlgorithm(tcs);
        usesTrueColorIn = tcs.trueColorIn;
        TrueColorAlgorithm.palette_outcoloring = palette_outcoloring;
        TrueColorAlgorithm.palette_incoloring = palette_incoloring;
        TrueColorAlgorithm.color_transfer_outcoloring = color_transfer_outcoloring;
        TrueColorAlgorithm.color_transfer_incoloring = color_transfer_incoloring;
        TrueColorAlgorithm.usePaletteForInColoring = usePaletteForInColoring;
        TrueColorAlgorithm.color_cycling_location_outcoloring = color_cycling_location_outcoloring;
        TrueColorAlgorithm.color_cycling_location_incoloring = color_cycling_location_incoloring;
        TrueColorAlgorithm.gradient = gradient;
        TrueColorAlgorithm.gradient_offset = gradient_offset;

    }

    public void calculateReferenceFastJulia(Location loc) {

        Fractal.ReferenceCalculationTime = 0;
        Fractal.SecondReferenceCalculationTime = 0;
        Fractal.SACalculationTime = 0;
        Fractal.BLACalculationTime = 0;
        Fractal.Nanomb1CalculationTime = 0;

        Fractal.total_bla_iterations = new LongAdder();
        Fractal.total_bla_steps =  new LongAdder();
        Fractal.total_perturb_iterations =  new LongAdder();
        Fractal.total_nanomb1_skipped_iterations = new LongAdder();
        Fractal.total_double_iterations = new LongAdder();
        Fractal.total_scaled_iterations = new LongAdder();
        Fractal.total_float_exp_iterations = new LongAdder();

        GenericComplex temp = loc.getReferencePoint();

        Fractal.clearReferences(true, false);
        fractal.calculateReferencePoint(temp, size, useExtendedRange(size, fractal), fractal.getStartingIterations(), fractal.getSecondStartingIterations(), loc, null);

    }

    public static int getHighPrecisionLibrary(Apfloat size, Fractal f) {

        if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_DOUBLEDOUBLE) {
            return Constants.ARBITRARY_DOUBLEDOUBLE;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_BUILT_IN) {
            if(f.supportsBignum()) {
                return Constants.ARBITRARY_BUILT_IN;
            }

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_BIGINT) {
            if(f.supportsBigIntnum()) {
                return Constants.ARBITRARY_BIGINT;
            }

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_MPFR && !LibMpfr.hasError()) {
            if(f.supportsMpfrBignum()) {
                return Constants.ARBITRARY_MPFR;
            }

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_MPFR && LibMpfr.hasError()) {

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            if(f.supportsBignum()) {
                return Constants.ARBITRARY_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.ARBITRARY_BIGINT;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_MPIR && !LibMpir.hasError()) {
            if(f.supportsMpirBignum()) {
                return Constants.ARBITRARY_MPIR;
            }

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_MPIR && LibMpir.hasError()) {

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            if(f.supportsBignum()) {
                return Constants.ARBITRARY_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.ARBITRARY_BIGINT;
            }

            return Constants.ARBITRARY_APFLOAT;
        }
        else if(TaskRender.HIGH_PRECISION_LIB == Constants.ARBITRARY_AUTOMATIC) {

            if(size.doubleValue() > f.getDoubleDoubleLimit()) {
                return Constants.ARBITRARY_DOUBLEDOUBLE;
            }

            if(!LibMpir.hasError() && f.supportsMpirBignum() && (MpirBigNum.precision >= 1200 || (!f.supportsBigIntnum() && !f.supportsBignum()))) {
                return Constants.ARBITRARY_MPIR;
            }

            if(!LibMpfr.hasError() && f.supportsMpfrBignum() && (MpfrBigNum.precision >= 1350 || (!f.supportsBigIntnum() && !f.supportsBignum()))) {
                return Constants.ARBITRARY_MPFR;
            }

            if(f.supportsBignum()) {
                return Constants.ARBITRARY_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.ARBITRARY_BIGINT;
            }

            return Constants.ARBITRARY_APFLOAT;
        }

        return Constants.ARBITRARY_APFLOAT;
    }

    public static int getBignumLibrary(Apfloat size, Fractal f) {

        double dsize = size.doubleValue();
        if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_DOUBLE) {
            return Constants.BIGNUM_DOUBLE;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_DOUBLEDOUBLE) {
            return Constants.BIGNUM_DOUBLEDOUBLE;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_BUILT_IN) {
            if(f.supportsBignum()) {
                return Constants.BIGNUM_BUILT_IN;
            }

            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_BIGINT) {
            if(f.supportsBigIntnum()) {
                return Constants.BIGNUM_BIGINT;
            }

            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_MPFR && !LibMpfr.hasError()) {
            if(f.supportsMpfrBignum()) {
                return Constants.BIGNUM_MPFR;
            }

            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_MPFR && LibMpfr.hasError()) {
            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            if(f.supportsBignum()) {
                return Constants.BIGNUM_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.BIGNUM_BIGINT;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_MPIR && !LibMpir.hasError()) {
            if(f.supportsMpirBignum()) {
                return Constants.BIGNUM_MPIR;
            }

            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_MPIR && LibMpir.hasError()) {
            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            if(f.supportsBignum()) {
                return Constants.BIGNUM_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.BIGNUM_BIGINT;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC) {
            if(f.supportsDouble() && dsize > f.getDoubleLimit()) {
                return Constants.BIGNUM_DOUBLE;
            }

            if(f.supportsDoubleDouble() && dsize > f.getDoubleDoubleLimit()) {
                return Constants.BIGNUM_DOUBLEDOUBLE;
            }

            if(!LibMpir.hasError() && f.supportsMpirBignum() && (MpirBigNum.precision >= 1200 || (!f.supportsBigIntnum() && !f.supportsBignum()))) { //(f.supportsPeriod() && DETECT_PERIOD && MpfrBigNum.precision >= 450)
                return Constants.BIGNUM_MPIR;
            }

            if(!LibMpfr.hasError() && f.supportsMpfrBignum() && (MpfrBigNum.precision >= 1350 || (!f.supportsBigIntnum() && !f.supportsBignum()))) { //(f.supportsPeriod() && DETECT_PERIOD && MpfrBigNum.precision >= 450)
                return Constants.BIGNUM_MPFR;
            }

            if(f.supportsBignum()) {
                return Constants.BIGNUM_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.BIGNUM_BIGINT;
            }

            return Constants.BIGNUM_APFLOAT;
        }
        else if(TaskRender.BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC_ONLY_BIGNUM) {
            if(!LibMpir.hasError() && f.supportsMpirBignum() && (MpirBigNum.precision >= 1200 || (!f.supportsBigIntnum() && !f.supportsBignum()))) { //(f.supportsPeriod() && DETECT_PERIOD && MpfrBigNum.precision >= 450)
                return Constants.BIGNUM_MPIR;
            }

            if(!LibMpfr.hasError() && f.supportsMpfrBignum() && (MpfrBigNum.precision >= 1350 || (!f.supportsBigIntnum() && !f.supportsBignum()))) { //(f.supportsPeriod() && DETECT_PERIOD && MpfrBigNum.precision >= 450)
                return Constants.BIGNUM_MPFR;
            }

            if(f.supportsBignum()) {
                return Constants.BIGNUM_BUILT_IN;
            }

            if(f.supportsBigIntnum()) {
                return Constants.BIGNUM_BIGINT;
            }

            return Constants.BIGNUM_APFLOAT;
        }

        return Constants.BIGNUM_APFLOAT;
    }

    public static boolean useExtendedRange(Apfloat size, Fractal f) {
        return f.needsExtendedRange() || size.compareTo(MyApfloat.MAX_DOUBLE_SIZE) < 0;
    }

    /*public void calcDeltaRef(GenericComplex DeltaSub0In) {

        if(DeltaSub0In instanceof Complex) {
            return;
        }

        MantExpComplex DeltaSub0 = (MantExpComplex)DeltaSub0In;
        MantExpComplex z = MantExpComplex.create();
        MantExpComplex DeltaSubN = MantExpComplex.create();
        int RefIteration = 0;
        int MaxRefIteration = fractal.getReferenceFinalIterationNumber(true, Fractal.referenceData);
        MantExp norm_squared_m = new MantExp();

//        PrintWriter printWriter = null;
//        try {
//            FileWriter fileWriter = new FileWriter("DeltaRef.out");
//            printWriter = new PrintWriter(fileWriter);
//        }
//        catch (Exception ex) {}

        DeepReference newReference = new DeepReference(max_iterations);

        int nextBigDataIndex = 0;
        int nextBigDataIter = Mandelbrot.BigDataIter.get(nextBigDataIndex);

        PrintWriter printWriter = null;
        try {
            FileWriter fileWriter = new FileWriter("RefDelta.out");
            printWriter = new PrintWriter(fileWriter);
        }
        catch (Exception ex) {}


        int iterations;
        for (iterations = 0; iterations < max_iterations; iterations++) {

            Fractal.setArrayDeepValue(newReference, RefIteration, z);
            printWriter.println(z);
            if (norm_squared_m.compareTo(new MantExp(4)) >= 0) {
               break;
            }

            if(RefIteration == nextBigDataIter) {
                DeltaSubN.Normalize();
                DeltaSub0.Normalize();
                GenericComplex p = new BigNumComplex(BigNum.create(DeltaSubN.getRe()), BigNum.create(DeltaSubN.getIm()));
                GenericComplex c = new BigNumComplex(BigNum.create(DeltaSub0.getRe()), BigNum.create(DeltaSub0.getIm()));
                DeltaSubN = Mandelbrot.BigData.get(nextBigDataIndex).times2().plus_mutable(p).times_mutable(p).plus_mutable(c).toMantExpComplex();
                //return getArrayDeepValue(referenceDeep, RefIteration).times2_mutable().plus_mutable(DeltaSubN).times_mutable(DeltaSubN).plus_mutable(DeltaSub0);
            }
            else {
                DeltaSubN = fractal.perturbationFunction(DeltaSubN, DeltaSub0, RefIteration);
            }

            RefIteration++;

            if (max_iterations > 1) {
                if(RefIteration == nextBigDataIter) {
                    DeltaSubN.Normalize();
                    GenericComplex p = new BigNumComplex(BigNum.create(DeltaSubN.getRe()), BigNum.create(DeltaSubN.getIm()));
                    z = Mandelbrot.BigData.get(nextBigDataIndex).plus(p).toMantExpComplex();
                }
                else {
                    z = Fractal.getArrayDeepValue(Fractal.referenceDeep, RefIteration).plus_mutable(DeltaSubN);
                }
            }

            norm_squared_m = z.norm_squared();
            if (norm_squared_m.compareToBothPositive(DeltaSubN.norm_squared()) < 0 || RefIteration >= MaxRefIteration) {
                if(RefIteration == nextBigDataIter) {
                    DeltaSubN = Mandelbrot.BigData.get(nextBigDataIndex).toMantExpComplex();
                }
                else {
                    DeltaSubN = z;
                }
                RefIteration = 0;
                nextBigDataIndex = 0;
                nextBigDataIter = Mandelbrot.BigDataIter.get(nextBigDataIndex);
            }

            DeltaSubN.Normalize();

            if(RefIteration > nextBigDataIter) {
                nextBigDataIndex++;

                if(nextBigDataIndex < Mandelbrot.BigDataIter.size()) {
                    nextBigDataIter = Mandelbrot.BigDataIter.get(nextBigDataIndex);
                }
                else {
                    nextBigDataIter = max_iterations;
                }
            }

        }

        printWriter.close();

        //Fractal.referenceData.MaxRefIteration = iterations - 1;
        //Fractal.referenceDeepData.Reference = newReference;

    }*/

    public void initializeHighPrecision() {
        Fractal.total_iterations = new LongAdder();
        Fractal.total_min_iterations = new LongAccumulator(Math::min, Long.MAX_VALUE);
        Fractal.total_max_iterations = new LongAccumulator(Math::max, Long.MIN_VALUE);
        Fractal.total_max_iterations_ignore_max_iter = new LongAccumulator(Math::max, Long.MIN_VALUE);
    }

    public void calculateReference(Location loc) {

        Fractal.ReferenceCalculationTime = 0;
        Fractal.SecondReferenceCalculationTime = 0;
        Fractal.SACalculationTime = 0;
        Fractal.BLACalculationTime = 0;
        Fractal.Nanomb1CalculationTime = 0;

        Fractal.total_bla_iterations =  new LongAdder();
        Fractal.total_bla_steps =  new LongAdder();
        Fractal.total_perturb_iterations =  new LongAdder();
        Fractal.total_nanomb1_skipped_iterations = new LongAdder();
        Fractal.total_double_iterations = new LongAdder();
        Fractal.total_scaled_iterations = new LongAdder();
        Fractal.total_float_exp_iterations = new LongAdder();
        Fractal.total_rebases = new LongAdder();
        Fractal.total_realigns = new LongAdder();
        Fractal.total_iterations = new LongAdder();
        Fractal.total_min_iterations = new LongAccumulator(Math::min, Long.MAX_VALUE);
        Fractal.total_max_iterations = new LongAccumulator(Math::max, Long.MIN_VALUE);
        Fractal.total_max_iterations_ignore_max_iter = new LongAccumulator(Math::max, Long.MIN_VALUE);

        int old_max = progress.getMaximum();
        int cur_val = progress.getValue();

        GenericComplex temp = loc.getReferencePoint();

        boolean isDeep = useExtendedRange(size, fractal);

        int max_ref_iterations = fractal.getReferenceMaxIterations();

//        if(isDeep && Fractal.referenceDeep != null) { //Test
//            //Fractal.DetectedPeriod = 0;
//            calcDeltaRef(loc.getComplex(MainWindow.PointX, MainWindow.PointY));
//            //fractal.calculateBLA2Wrapper(isDeep, loc, progress);
//            //return;
//        }

        boolean referencesArePresent = !(Fractal.referenceDeep == null && isDeep) && !(Fractal.reference == null && !isDeep);
        boolean refTypeIsTheSame = Fractal.refPoint != null && temp.getClass().equals(Fractal.refPoint.getClass()) && Fractal.RefType.equals(fractal.getRefType());
        boolean detectPeriod = TaskRender.DETECT_PERIOD && fractal.supportsPeriod() && fractal.getUserPeriod() == 0;
        boolean hasStoppedReferenceCalculation = detectPeriod && TaskRender.STOP_REFERENCE_CALCULATION_AFTER_DETECTED_PERIOD && Fractal.DetectedPeriod != 0 &&  fractal.getUserPeriod() == 0 && fractal.canStopOnDetectedPeriod();

        if(refTypeIsTheSame && referencesArePresent && temp.compare(Fractal.refPoint) == 0) {

            if(!hasStoppedReferenceCalculation && max_ref_iterations > fractal.getReferenceLength()) {
                fractal.calculateReferencePoint(temp, size, isDeep, fractal.getNextIterations(), fractal.getSecondNextIterations(), loc, progress);
            }
            else if(detectPeriod && CALCULATE_PERIOD_EVERY_TIME_FROM_START && (size.compareTo(Fractal.LastCalculationSize) != 0 || fractal.getPeriod() == 0)) {
                Fractal.clearReferences(true, false);
                fractal.calculateReferencePoint(temp, size, isDeep, fractal.getStartingIterations(), fractal.getSecondStartingIterations(), loc, progress);
            }
            else if(detectPeriod && !CALCULATE_PERIOD_EVERY_TIME_FROM_START && (size.compareTo(Fractal.LastCalculationSize) < 0 || fractal.getPeriod() == 0) && fractal.shouldRecalculateForPeriodDetection(isDeep, loc)) {
                if(fractal.getPeriodDetectionAlgorithm() == 1
                        && hasStoppedReferenceCalculation
                        && !(APPROXIMATION_ALGORITHM == 3 && fractal.supportsNanomb1())
                        && !(APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation())
                        && ((isDeep && Fractal.referenceData.mdzdc != null) || (!isDeep && Fractal.referenceData.dzdc != null))
                ) {
                    Fractal.DetectedPeriod = 0;
                    fractal.calculateReferencePoint(temp, size, isDeep, fractal.getNextIterations(), fractal.getSecondNextIterations(), loc, progress);
                }
                else {
                    Fractal.clearReferences(true, false);
                    fractal.calculateReferencePoint(temp, size, isDeep, fractal.getStartingIterations(), fractal.getSecondStartingIterations(), loc, progress);
                }
            }
            else {
                if (APPROXIMATION_ALGORITHM == 1 && fractal.supportsSeriesApproximation()
                        && size.compareTo(MyApfloat.SA_START_SIZE) <= 0
                && (Fractal.coefficients == null || Fractal.SAMaxSkip != TaskRender.SERIES_APPROXIMATION_MAX_SKIP_ITER
                        || Fractal.SAOOMDiff != TaskRender.SERIES_APPROXIMATION_OOM_DIFFERENCE
                        || Fractal.SATerms != TaskRender.SERIES_APPROXIMATION_TERMS
                        || Fractal.SASize != loc.getMaxSizeInImage().log2approx()
                        || Fractal.SAskippedIterations == 0)
                ) {
                    fractal.calculateSeriesWrapper(size, isDeep, loc, progress);
                }
                else if(APPROXIMATION_ALGORITHM == 2 && fractal.supportsBilinearApproximation() && (Fractal.B == null || (isDeep && Fractal.B.bdeep == null)
                        || (!isDeep && Fractal.B.b == null)
                        || BLA_BITS != Fractal.BLAbits
                        || fractal.getBLALength() != Fractal.B.M
                        || loc.getMaxSizeInImage().compareToBothPositive(Fractal.BLASize) != 0
                        || BLA_STARTING_LEVEL != Fractal.BLAStartingLevel
                )) {
                    fractal.calculateBLAWrapper(isDeep, loc, progress);
                }
                else if(APPROXIMATION_ALGORITHM == 4 && fractal.supportsBilinearApproximation2()
                 && (loc.getSize().compareToBothPositive(Fractal.BLA2Size) != 0
                     || fractal.BLA2ParamsDiffer()
                    || (isDeep && fractal.useFullFloatExp() != Fractal.BLA2UsedFullFloatExp)
                        || Fractal.laReference == null || !Fractal.laReference.isValid)) {

                    if(Fractal.laReference == null ||
                            !Fractal.laReference.isValid
                            || fractal.BLA2ParamsDiffer()
                            || (isDeep && fractal.useFullFloatExp() != Fractal.BLA2UsedFullFloatExp)
                            //|| (isDeep && !fractal.useFullFloatExp())
                            || (isDeep && fractal.useFullFloatExp() && LAReference.CONVERT_TO_DOUBLE_WHEN_POSSIBLE)
                            || (isDeep != Fractal.laReference.calculatedForDeep)
                    ) {
                        fractal.calculateBLA2Wrapper(isDeep, loc, progress);
                    }
                    else if(Fractal.laReference.isValid){
                        fractal.calculateBLA2ATWrapper(loc, progress);
                    }
                }

                fractal.clearUnusedReferences(isDeep);
                fractal.finalizeReference();
            }


            progress.setString(null);
            progress.setMaximum(old_max);
            progress.setValue(cur_val);
            progress.setForeground(MainWindow.progress_color);
            return;

        }

        if(fractal.isJulia()) {
            Fractal.clearReferences(!(referencesArePresent && refTypeIsTheSame), false);//Dont clear the julia refs if only the ref point changes
        }
        else {
            Fractal.clearReferences(true, false);
        }
        fractal.calculateReferencePoint(temp, size, isDeep, fractal.getStartingIterations(), fractal.getSecondStartingIterations(), loc, progress);

        progress.setString(null);
        progress.setMaximum(old_max);
        progress.setValue(cur_val);
        progress.setForeground(MainWindow.progress_color);

    }

    public boolean isQuickRender() {
        return quickRender;
    }

    public boolean isFastJulia() {
        return action == FAST_JULIA || action == FAST_JULIA_POLAR;
    }

    public boolean isJulia() {
        return (action == NORMAL || action == NORMAL_EXPANDER || action == POLAR || action == POLAR_EXPANDER) && julia;
    }

    public boolean isNonJulia() {
        return (action == NORMAL || action == NORMAL_EXPANDER || action == POLAR || action == POLAR_EXPANDER) && !julia;
    }

    public boolean isJuliaMap() {
        return action == JULIA_MAP || action == JULIA_MAP_POLAR;
    }

    public boolean isDomainColoring() {
        return action == DOMAIN || action == DOMAIN_POLAR || action == DOMAIN_EXPANDER || action == DOMAIN_POLAR_EXPANDER;
    }

    public static boolean allocateMPFR() {
        if(HIGH_PRECISION_CALCULATION) {
            return (HIGH_PRECISION_LIB == Constants.ARBITRARY_MPFR || (HIGH_PRECISION_LIB == Constants.ARBITRARY_AUTOMATIC && LibMpir.hasError())) && !LibMpfr.hasError();
        }

        return (BIGNUM_LIBRARY == Constants.BIGNUM_MPFR || ((BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC || BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC_ONLY_BIGNUM) && LibMpir.hasError())) && !LibMpfr.hasError();
    }

    public static boolean allocateMPIR() {
        if(HIGH_PRECISION_CALCULATION) {
            return (HIGH_PRECISION_LIB == Constants.ARBITRARY_MPIR || HIGH_PRECISION_LIB == Constants.ARBITRARY_AUTOMATIC) && !LibMpir.hasError();
        }

        return (BIGNUM_LIBRARY == Constants.BIGNUM_MPIR || BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC || BIGNUM_LIBRARY == Constants.BIGNUM_AUTOMATIC_ONLY_BIGNUM) && !LibMpir.hasError();
    }

    public static void deleteLibs() {
        LibMpfr.delete();
        LibMpir.delete();
    }

    public void setUsesSquareChunks(boolean v) {
        usesSquareChunks = v;
    }

    public boolean usesSuccessiveRefinement() {
        return false;
    }

    public boolean hasSuccessiveRefinement() {
        return false;
    }

    public boolean hasCircularLogic() {
        return false;
    }

    private int getPaletteLength(boolean escaped) {
        return  (!escaped && usePaletteForInColoring) ? palette_incoloring.getPaletteLength() : palette_outcoloring.getPaletteLength();
    }

    private void setPostProcessingBlending() {

        ens_blending = blendingFactory(COLOR_SMOOTHING_METHOD, ens.en_color_blending);
        ens_blending.setReverseColors(ens.en_reverse_color_blending);

        rps_blending = blendingFactory(COLOR_SMOOTHING_METHOD, rps.rp_color_blending);
        rps_blending.setReverseColors(rps.rp_reverse_color_blending);

        ndes_blending = blendingFactory(COLOR_SMOOTHING_METHOD, ndes.nde_color_blending);
        ndes_blending.setReverseColors(ndes.nde_reverse_color_blending);

        hss_blending = blendingFactory(COLOR_SMOOTHING_METHOD, hss.hs_color_blending);
        hss_blending.setReverseColors(hss.hs_reverse_color_blending);

        ofs_blending = blendingFactory(COLOR_SMOOTHING_METHOD, ofs.of_color_blending);
        ofs_blending.setReverseColors(ofs.of_reverse_color_blending);

    }
}
